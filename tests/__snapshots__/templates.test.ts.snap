// Bun Snapshot v1, https://bun.sh/docs/test/snapshots

exports[`rolldown-plugin-solid src should transform templates and event delegation 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
const equalFn = (a, b) => a === b;
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}

//#endregion
//#region node_modules/solid-js/web/dist/web.js
const Properties = /* @__PURE__ */ new Set([
	"className",
	"value",
	"readOnly",
	"noValidate",
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"adAuctionHeaders",
	"allowFullscreen",
	"browsingTopics",
	"defaultChecked",
	"defaultMuted",
	"defaultSelected",
	"disablePictureInPicture",
	"disableRemotePlayback",
	"preservesPitch",
	"shadowRootClonable",
	"shadowRootCustomElementRegistry",
	"shadowRootDelegatesFocus",
	"shadowRootSerializable",
	"sharedStorageWritable",
	...[
		"allowfullscreen",
		"async",
		"alpha",
		"autofocus",
		"autoplay",
		"checked",
		"controls",
		"default",
		"disabled",
		"formnovalidate",
		"hidden",
		"indeterminate",
		"inert",
		"ismap",
		"loop",
		"multiple",
		"muted",
		"nomodule",
		"novalidate",
		"open",
		"playsinline",
		"readonly",
		"required",
		"reversed",
		"seamless",
		"selected",
		"adauctionheaders",
		"browsingtopics",
		"credentialless",
		"defaultchecked",
		"defaultmuted",
		"defaultselected",
		"defer",
		"disablepictureinpicture",
		"disableremoteplayback",
		"preservespitch",
		"shadowrootclonable",
		"shadowrootcustomelementregistry",
		"shadowrootdelegatesfocus",
		"shadowrootserializable",
		"sharedstoragewritable"
	]
]);
const ChildProperties = /* @__PURE__ */ new Set([
	"innerHTML",
	"textContent",
	"innerText",
	"children"
]);
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
function getPropAlias(prop, tagName) {
	const a = PropAliases[prop];
	return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
}
const DelegatedEvents = /* @__PURE__ */ new Set([
	"beforeinput",
	"click",
	"dblclick",
	"contextmenu",
	"focusin",
	"focusout",
	"input",
	"keydown",
	"keyup",
	"mousedown",
	"mousemove",
	"mouseout",
	"mouseover",
	"mouseup",
	"pointerdown",
	"pointermove",
	"pointerout",
	"pointerover",
	"pointerup",
	"touchend",
	"touchmove",
	"touchstart"
]);
const SVGNamespace = {
	xlink: "http://www.w3.org/1999/xlink",
	xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(parentNode, a, b) {
	let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
	while (aStart < aEnd || bStart < bEnd) {
		if (a[aStart] === b[bStart]) {
			aStart++;
			bStart++;
			continue;
		}
		while (a[aEnd - 1] === b[bEnd - 1]) {
			aEnd--;
			bEnd--;
		}
		if (aEnd === aStart) {
			const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
			while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
		} else if (bEnd === bStart) while (aStart < aEnd) {
			if (!map || !map.has(a[aStart])) a[aStart].remove();
			aStart++;
		}
		else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
			const node = a[--aEnd].nextSibling;
			parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
			parentNode.insertBefore(b[--bEnd], node);
			a[aEnd] = b[bEnd];
		} else {
			if (!map) {
				map = /* @__PURE__ */ new Map();
				let i = bStart;
				while (i < bEnd) map.set(b[i], i++);
			}
			const index = map.get(a[aStart]);
			if (index != null) if (bStart < index && index < bEnd) {
				let i = aStart, sequence = 1, t;
				while (++i < aEnd && i < bEnd) {
					if ((t = map.get(a[i])) == null || t !== index + sequence) break;
					sequence++;
				}
				if (sequence > index - bStart) {
					const node = a[aStart];
					while (bStart < index) parentNode.insertBefore(b[bStart++], node);
				} else parentNode.replaceChild(b[bStart++], a[aStart++]);
			} else aStart++;
			else a[aStart++].remove();
		}
	}
}
const $$EVENTS = "_$DX_DELEGATE";
function template(html, isImportNode, isSVG, isMathML) {
	let node;
	const create = () => {
		const t = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
		t.innerHTML = html;
		return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;
	};
	const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
	fn.cloneNode = fn;
	return fn;
}
function delegateEvents(eventNames, document$1 = window.document) {
	const e = document$1[$$EVENTS] || (document$1[$$EVENTS] = /* @__PURE__ */ new Set());
	for (let i = 0, l = eventNames.length; i < l; i++) {
		const name = eventNames[i];
		if (!e.has(name)) {
			e.add(name);
			document$1.addEventListener(name, eventHandler);
		}
	}
}
function setAttribute(node, name, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttribute(name);
	else node.setAttribute(name, value);
}
function setAttributeNS(node, namespace, name, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttributeNS(namespace, name);
	else node.setAttributeNS(namespace, name, value);
}
function setBoolAttribute(node, name, value) {
	if (isHydrating(node)) return;
	value ? node.setAttribute(name, "") : node.removeAttribute(name);
}
function className(node, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttribute("class");
	else node.className = value;
}
function addEventListener(node, name, handler, delegate) {
	if (delegate) if (Array.isArray(handler)) {
		node[\`$$\${name}\`] = handler[0];
		node[\`$$\${name}Data\`] = handler[1];
	} else node[\`$$\${name}\`] = handler;
	else if (Array.isArray(handler)) {
		const handlerFn = handler[0];
		node.addEventListener(name, handler[0] = (e) => handlerFn.call(node, handler[1], e));
	} else node.addEventListener(name, handler, typeof handler !== "function" && handler);
}
function classList(node, value, prev = {}) {
	const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
	let i, len;
	for (i = 0, len = prevKeys.length; i < len; i++) {
		const key = prevKeys[i];
		if (!key || key === "undefined" || value[key]) continue;
		toggleClassKey(node, key, false);
		delete prev[key];
	}
	for (i = 0, len = classKeys.length; i < len; i++) {
		const key = classKeys[i], classValue = !!value[key];
		if (!key || key === "undefined" || prev[key] === classValue || !classValue) continue;
		toggleClassKey(node, key, true);
		prev[key] = classValue;
	}
	return prev;
}
function style(node, value, prev) {
	if (!value) return prev ? setAttribute(node, "style") : value;
	const nodeStyle = node.style;
	if (typeof value === "string") return nodeStyle.cssText = value;
	typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
	prev || (prev = {});
	value || (value = {});
	let v, s;
	for (s in prev) {
		value[s] ?? nodeStyle.removeProperty(s);
		delete prev[s];
	}
	for (s in value) {
		v = value[s];
		if (v !== prev[s]) {
			nodeStyle.setProperty(s, v);
			prev[s] = v;
		}
	}
	return prev;
}
function spread(node, props = {}, isSVG, skipChildren) {
	const prevProps = {};
	if (!skipChildren) createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
	createRenderEffect(() => typeof props.ref === "function" && use(props.ref, node));
	createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
	return prevProps;
}
function use(fn, element, arg) {
	return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
	if (marker !== void 0 && !initial) initial = [];
	if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
	createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
	props || (props = {});
	for (const prop in prevProps) if (!(prop in props)) {
		if (prop === "children") continue;
		prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);
	}
	for (const prop in props) {
		if (prop === "children") {
			if (!skipChildren) insertExpression(node, props.children);
			continue;
		}
		const value = props[prop];
		prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);
	}
}
function isHydrating(node) {
	return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function toPropertyName(name) {
	return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
}
function toggleClassKey(node, key, value) {
	const classNames = key.trim().split(/\\s+/);
	for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);
}
function assignProp(node, prop, value, prev, isSVG, skipRef, props) {
	let isCE, isProp, isChildProp, propAlias, forceProp;
	if (prop === "style") return style(node, value, prev);
	if (prop === "classList") return classList(node, value, prev);
	if (value === prev) return prev;
	if (prop === "ref") {
		if (!skipRef) value(node);
	} else if (prop.slice(0, 3) === "on:") {
		const e = prop.slice(3);
		prev && node.removeEventListener(e, prev, typeof prev !== "function" && prev);
		value && node.addEventListener(e, value, typeof value !== "function" && value);
	} else if (prop.slice(0, 10) === "oncapture:") {
		const e = prop.slice(10);
		prev && node.removeEventListener(e, prev, true);
		value && node.addEventListener(e, value, true);
	} else if (prop.slice(0, 2) === "on") {
		const name = prop.slice(2).toLowerCase();
		const delegate = DelegatedEvents.has(name);
		if (!delegate && prev) {
			const h = Array.isArray(prev) ? prev[0] : prev;
			node.removeEventListener(name, h);
		}
		if (delegate || value) {
			addEventListener(node, name, value, delegate);
			delegate && delegateEvents([name]);
		}
	} else if (prop.slice(0, 5) === "attr:") setAttribute(node, prop.slice(5), value);
	else if (prop.slice(0, 5) === "bool:") setBoolAttribute(node, prop.slice(5), value);
	else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-") || "is" in props)) {
		if (forceProp) {
			prop = prop.slice(5);
			isProp = true;
		} else if (isHydrating(node)) return value;
		if (prop === "class" || prop === "className") className(node, value);
		else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;
		else node[propAlias || prop] = value;
	} else {
		const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
		if (ns) setAttributeNS(node, ns, prop, value);
		else setAttribute(node, Aliases[prop] || prop, value);
	}
	return value;
}
function eventHandler(e) {
	if (sharedConfig.registry && sharedConfig.events) {
		if (sharedConfig.events.find(([el, ev]) => ev === e)) return;
	}
	let node = e.target;
	const key = \`$$\${e.type}\`;
	const oriTarget = e.target;
	const oriCurrentTarget = e.currentTarget;
	const retarget = (value) => Object.defineProperty(e, "target", {
		configurable: true,
		value
	});
	const handleNode = () => {
		const handler = node[key];
		if (handler && !node.disabled) {
			const data = node[\`\${key}Data\`];
			data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
			if (e.cancelBubble) return;
		}
		node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
		return true;
	};
	const walkUpTree = () => {
		while (handleNode() && (node = node._$host || node.parentNode || node.host));
	};
	Object.defineProperty(e, "currentTarget", {
		configurable: true,
		get() {
			return node || document;
		}
	});
	if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
	if (e.composedPath) {
		const path = e.composedPath();
		retarget(path[0]);
		for (let i = 0; i < path.length - 2; i++) {
			node = path[i];
			if (!handleNode()) break;
			if (node._$host) {
				node = node._$host;
				walkUpTree();
				break;
			}
			if (node.parentNode === oriCurrentTarget) break;
		}
	} else walkUpTree();
	retarget(oriTarget);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
	const hydrating = isHydrating(parent);
	if (hydrating) {
		!current && (current = [...parent.childNodes]);
		let cleaned = [];
		for (let i = 0; i < current.length; i++) {
			const node = current[i];
			if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
			else cleaned.push(node);
		}
		current = cleaned;
	}
	while (typeof current === "function") current = current();
	if (value === current) return current;
	const t = typeof value, multi = marker !== void 0;
	parent = multi && current[0] && current[0].parentNode || parent;
	if (t === "string" || t === "number") {
		if (hydrating) return current;
		if (t === "number") {
			value = value.toString();
			if (value === current) return current;
		}
		if (multi) {
			let node = current[0];
			if (node && node.nodeType === 3) node.data !== value && (node.data = value);
			else node = document.createTextNode(value);
			current = cleanChildren(parent, current, marker, node);
		} else if (current !== "" && typeof current === "string") current = parent.firstChild.data = value;
		else current = parent.textContent = value;
	} else if (value == null || t === "boolean") {
		if (hydrating) return current;
		current = cleanChildren(parent, current, marker);
	} else if (t === "function") {
		createRenderEffect(() => {
			let v = value();
			while (typeof v === "function") v = v();
			current = insertExpression(parent, v, current, marker);
		});
		return () => current;
	} else if (Array.isArray(value)) {
		const array = [];
		const currentArray = current && Array.isArray(current);
		if (normalizeIncomingArray(array, value, current, unwrapArray)) {
			createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
			return () => current;
		}
		if (hydrating) {
			if (!array.length) return current;
			if (marker === void 0) return current = [...parent.childNodes];
			let node = array[0];
			if (node.parentNode !== parent) return current;
			const nodes = [node];
			while ((node = node.nextSibling) !== marker) nodes.push(node);
			return current = nodes;
		}
		if (array.length === 0) {
			current = cleanChildren(parent, current, marker);
			if (multi) return current;
		} else if (currentArray) if (current.length === 0) appendNodes(parent, array, marker);
		else reconcileArrays(parent, current, array);
		else {
			current && cleanChildren(parent);
			appendNodes(parent, array);
		}
		current = array;
	} else if (value.nodeType) {
		if (hydrating && value.parentNode) return current = multi ? [value] : value;
		if (Array.isArray(current)) {
			if (multi) return current = cleanChildren(parent, current, marker, value);
			cleanChildren(parent, current, null, value);
		} else if (current == null || current === "" || !parent.firstChild) parent.appendChild(value);
		else parent.replaceChild(value, parent.firstChild);
		current = value;
	}
	return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
	let dynamic = false;
	for (let i = 0, len = array.length; i < len; i++) {
		let item = array[i], prev = current && current[normalized.length], t;
		if (item == null || item === true || item === false);
		else if ((t = typeof item) === "object" && item.nodeType) normalized.push(item);
		else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
		else if (t === "function") if (unwrap) {
			while (typeof item === "function") item = item();
			dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
		} else {
			normalized.push(item);
			dynamic = true;
		}
		else {
			const value = String(item);
			if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
			else normalized.push(document.createTextNode(value));
		}
	}
	return dynamic;
}
function appendNodes(parent, array, marker = null) {
	for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
	if (marker === void 0) return parent.textContent = "";
	const node = replacement || document.createTextNode("");
	if (current.length) {
		let inserted = false;
		for (let i = current.length - 1; i >= 0; i--) {
			const el = current[i];
			if (node !== el) {
				const isParent = el.parentNode === parent;
				if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
				else isParent && el.remove();
			} else inserted = true;
		}
	} else parent.insertBefore(node, marker);
	return [node];
}

//#endregion
//#region tests/fixtures/templates.tsx
var _tmpl$ = /* @__PURE__ */ template(\`<svg width=100 height=100><circle cx=50 cy=50 r=40 fill=red></circle><foreignObject x=10 y=10 width=80 height=80><div><p>HTML content inside SVG\`), _tmpl$2 = /* @__PURE__ */ template(\`<div><svg><g><rect x=0 y=0 width=100 height=100>\`), _tmpl$3 = /* @__PURE__ */ template(\`<div><button>Click me</button><div>Hover me</div><input><form><select><option value=1>Option 1</option><option value=2>Option 2\`), _tmpl$4 = /* @__PURE__ */ template(\`<div class=container><h1>Title</h1><ul></ul><div style=color:red;font-size:16px>Styled content\`), _tmpl$5 = /* @__PURE__ */ template(\`<p>Conditional content\`), _tmpl$6 = /* @__PURE__ */ template(\`<li>\`), _tmpl$7 = /* @__PURE__ */ template(\`<div id=test class=my-class data-testid=element aria-label="Accessible element"role=button tabindex=0><img src=test.jpg alt="test image"width=100 height=100><input type=text placeholder="Enter text"required>\`), _tmpl$8 = /* @__PURE__ */ template(\`<svg width=100 height=100><circle cx=50 cy=50 r=40 fill=red></circle><rect x=10 y=10 width=30 height=30 fill=blue></rect><text x=50 y=50 text-anchor=middle>SVG Text\`), _tmpl$9 = /* @__PURE__ */ template(\`<head><title>SSR Test</title><meta charset=utf-8><meta name=viewport content="width=device-width">\`), _tmpl$0 = /* @__PURE__ */ template(\`<div><script>console.log('test');<\\/script><style>body \\{ margin: 0; }\`), _tmpl$1 = /* @__PURE__ */ template(\`<div><p>Static content</p><div></div><ul>\`), _tmpl$10 = /* @__PURE__ */ template(\`<li>Item \`), _tmpl$11 = /* @__PURE__ */ template(\`<div>Spread attributes\`), _tmpl$12 = /* @__PURE__ */ template(\`<table><thead><tr><th>Header 1</th><th>Header 2</th></tr></thead><tbody><tr><td>Cell 1</td><td>Cell 2\`), _tmpl$13 = /* @__PURE__ */ template(\`<div><section><article><header><h1>Title</h1></header><main><p>Content</p></main><footer><small>Footer</small></footer></article></section><table><tr><td>Cell 1</td><td>Cell 2</td></tr></table><img src=test.jpg alt=test><br><hr>\`);
function TestSvgWrap() {
	return _tmpl$();
}
function TestNestedSvg() {
	return _tmpl$2();
}
function TestEventDelegation() {
	return (() => {
		var _el$3 = _tmpl$3(), _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$5.nextSibling, _el$7 = _el$6.nextSibling, _el$8 = _el$7.firstChild;
		_el$4.$$click = () => console.log("click");
		_el$5.$$mouseover = () => console.log("hover");
		_el$6.$$input = (e) => console.log(e.target.value);
		_el$7.addEventListener("submit", (e) => e.preventDefault());
		_el$8.addEventListener("change", (e) => console.log(e.target.value));
		return _el$3;
	})();
}
function TestComplexTemplates() {
	const items = [
		"a",
		"b",
		"c"
	];
	return (() => {
		var _el$9 = _tmpl$4(), _el$1 = _el$9.firstChild.nextSibling;
		_el$1.nextSibling;
		insert(_el$9, _tmpl$5(), _el$1);
		insert(_el$1, () => items.map((item) => (() => {
			var _el$12 = _tmpl$6();
			insert(_el$12, item);
			return _el$12;
		})()));
		return _el$9;
	})();
}
function TestAttributeTemplates() {
	return (() => {
		var _el$13 = _tmpl$7(), _el$15 = _el$13.firstChild.nextSibling;
		_el$15.disabled = false;
		return _el$13;
	})();
}
function TestSVGTemplates() {
	return _tmpl$8();
}
function TestSSRHeadElement() {
	return _tmpl$9();
}
function TestSSRScriptStyle() {
	return _tmpl$0();
}
function TestSSRHydration() {
	return (() => {
		var _el$19 = _tmpl$1(), _el$21 = _el$19.firstChild.nextSibling, _el$22 = _el$21.nextSibling;
		insert(_el$21, () => \`Dynamic content: \${Date.now()}\`);
		insert(_el$22, () => [
			1,
			2,
			3
		].map((item) => (() => {
			var _el$23 = _tmpl$10();
			_el$23.firstChild;
			insert(_el$23, item, null);
			return _el$23;
		})()));
		return _el$19;
	})();
}
function TestSSRSpreadAttributes() {
	const props = {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	};
	return (() => {
		var _el$25 = _tmpl$11();
		spread(_el$25, props, false, true);
		return _el$25;
	})();
}
function TestSSRSpecialElements() {
	return _tmpl$12();
}
function TestValidationScenarios() {
	return _tmpl$13();
}
delegateEvents([
	"click",
	"mouseover",
	"input"
]);

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid dist should transform templates and event delegation 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
const equalFn = (a, b) => a === b;
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}

//#endregion
//#region node_modules/solid-js/web/dist/web.js
const Properties = /* @__PURE__ */ new Set([
	"className",
	"value",
	"readOnly",
	"noValidate",
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"adAuctionHeaders",
	"allowFullscreen",
	"browsingTopics",
	"defaultChecked",
	"defaultMuted",
	"defaultSelected",
	"disablePictureInPicture",
	"disableRemotePlayback",
	"preservesPitch",
	"shadowRootClonable",
	"shadowRootCustomElementRegistry",
	"shadowRootDelegatesFocus",
	"shadowRootSerializable",
	"sharedStorageWritable",
	...[
		"allowfullscreen",
		"async",
		"alpha",
		"autofocus",
		"autoplay",
		"checked",
		"controls",
		"default",
		"disabled",
		"formnovalidate",
		"hidden",
		"indeterminate",
		"inert",
		"ismap",
		"loop",
		"multiple",
		"muted",
		"nomodule",
		"novalidate",
		"open",
		"playsinline",
		"readonly",
		"required",
		"reversed",
		"seamless",
		"selected",
		"adauctionheaders",
		"browsingtopics",
		"credentialless",
		"defaultchecked",
		"defaultmuted",
		"defaultselected",
		"defer",
		"disablepictureinpicture",
		"disableremoteplayback",
		"preservespitch",
		"shadowrootclonable",
		"shadowrootcustomelementregistry",
		"shadowrootdelegatesfocus",
		"shadowrootserializable",
		"sharedstoragewritable"
	]
]);
const ChildProperties = /* @__PURE__ */ new Set([
	"innerHTML",
	"textContent",
	"innerText",
	"children"
]);
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
function getPropAlias(prop, tagName) {
	const a = PropAliases[prop];
	return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
}
const DelegatedEvents = /* @__PURE__ */ new Set([
	"beforeinput",
	"click",
	"dblclick",
	"contextmenu",
	"focusin",
	"focusout",
	"input",
	"keydown",
	"keyup",
	"mousedown",
	"mousemove",
	"mouseout",
	"mouseover",
	"mouseup",
	"pointerdown",
	"pointermove",
	"pointerout",
	"pointerover",
	"pointerup",
	"touchend",
	"touchmove",
	"touchstart"
]);
const SVGNamespace = {
	xlink: "http://www.w3.org/1999/xlink",
	xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(parentNode, a, b) {
	let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
	while (aStart < aEnd || bStart < bEnd) {
		if (a[aStart] === b[bStart]) {
			aStart++;
			bStart++;
			continue;
		}
		while (a[aEnd - 1] === b[bEnd - 1]) {
			aEnd--;
			bEnd--;
		}
		if (aEnd === aStart) {
			const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
			while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
		} else if (bEnd === bStart) while (aStart < aEnd) {
			if (!map || !map.has(a[aStart])) a[aStart].remove();
			aStart++;
		}
		else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
			const node = a[--aEnd].nextSibling;
			parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
			parentNode.insertBefore(b[--bEnd], node);
			a[aEnd] = b[bEnd];
		} else {
			if (!map) {
				map = /* @__PURE__ */ new Map();
				let i = bStart;
				while (i < bEnd) map.set(b[i], i++);
			}
			const index = map.get(a[aStart]);
			if (index != null) if (bStart < index && index < bEnd) {
				let i = aStart, sequence = 1, t;
				while (++i < aEnd && i < bEnd) {
					if ((t = map.get(a[i])) == null || t !== index + sequence) break;
					sequence++;
				}
				if (sequence > index - bStart) {
					const node = a[aStart];
					while (bStart < index) parentNode.insertBefore(b[bStart++], node);
				} else parentNode.replaceChild(b[bStart++], a[aStart++]);
			} else aStart++;
			else a[aStart++].remove();
		}
	}
}
const $$EVENTS = "_$DX_DELEGATE";
function template(html, isImportNode, isSVG, isMathML) {
	let node;
	const create = () => {
		const t = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
		t.innerHTML = html;
		return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;
	};
	const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
	fn.cloneNode = fn;
	return fn;
}
function delegateEvents(eventNames, document$1 = window.document) {
	const e = document$1[$$EVENTS] || (document$1[$$EVENTS] = /* @__PURE__ */ new Set());
	for (let i = 0, l = eventNames.length; i < l; i++) {
		const name = eventNames[i];
		if (!e.has(name)) {
			e.add(name);
			document$1.addEventListener(name, eventHandler);
		}
	}
}
function setAttribute(node, name, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttribute(name);
	else node.setAttribute(name, value);
}
function setAttributeNS(node, namespace, name, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttributeNS(namespace, name);
	else node.setAttributeNS(namespace, name, value);
}
function setBoolAttribute(node, name, value) {
	if (isHydrating(node)) return;
	value ? node.setAttribute(name, "") : node.removeAttribute(name);
}
function className(node, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttribute("class");
	else node.className = value;
}
function addEventListener(node, name, handler, delegate) {
	if (delegate) if (Array.isArray(handler)) {
		node[\`$$\${name}\`] = handler[0];
		node[\`$$\${name}Data\`] = handler[1];
	} else node[\`$$\${name}\`] = handler;
	else if (Array.isArray(handler)) {
		const handlerFn = handler[0];
		node.addEventListener(name, handler[0] = (e) => handlerFn.call(node, handler[1], e));
	} else node.addEventListener(name, handler, typeof handler !== "function" && handler);
}
function classList(node, value, prev = {}) {
	const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
	let i, len;
	for (i = 0, len = prevKeys.length; i < len; i++) {
		const key = prevKeys[i];
		if (!key || key === "undefined" || value[key]) continue;
		toggleClassKey(node, key, false);
		delete prev[key];
	}
	for (i = 0, len = classKeys.length; i < len; i++) {
		const key = classKeys[i], classValue = !!value[key];
		if (!key || key === "undefined" || prev[key] === classValue || !classValue) continue;
		toggleClassKey(node, key, true);
		prev[key] = classValue;
	}
	return prev;
}
function style(node, value, prev) {
	if (!value) return prev ? setAttribute(node, "style") : value;
	const nodeStyle = node.style;
	if (typeof value === "string") return nodeStyle.cssText = value;
	typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
	prev || (prev = {});
	value || (value = {});
	let v, s;
	for (s in prev) {
		value[s] ?? nodeStyle.removeProperty(s);
		delete prev[s];
	}
	for (s in value) {
		v = value[s];
		if (v !== prev[s]) {
			nodeStyle.setProperty(s, v);
			prev[s] = v;
		}
	}
	return prev;
}
function spread(node, props = {}, isSVG, skipChildren) {
	const prevProps = {};
	if (!skipChildren) createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
	createRenderEffect(() => typeof props.ref === "function" && use(props.ref, node));
	createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
	return prevProps;
}
function use(fn, element, arg) {
	return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
	if (marker !== void 0 && !initial) initial = [];
	if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
	createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
	props || (props = {});
	for (const prop in prevProps) if (!(prop in props)) {
		if (prop === "children") continue;
		prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);
	}
	for (const prop in props) {
		if (prop === "children") {
			if (!skipChildren) insertExpression(node, props.children);
			continue;
		}
		const value = props[prop];
		prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);
	}
}
function isHydrating(node) {
	return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function toPropertyName(name) {
	return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
}
function toggleClassKey(node, key, value) {
	const classNames = key.trim().split(/\\s+/);
	for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);
}
function assignProp(node, prop, value, prev, isSVG, skipRef, props) {
	let isCE, isProp, isChildProp, propAlias, forceProp;
	if (prop === "style") return style(node, value, prev);
	if (prop === "classList") return classList(node, value, prev);
	if (value === prev) return prev;
	if (prop === "ref") {
		if (!skipRef) value(node);
	} else if (prop.slice(0, 3) === "on:") {
		const e = prop.slice(3);
		prev && node.removeEventListener(e, prev, typeof prev !== "function" && prev);
		value && node.addEventListener(e, value, typeof value !== "function" && value);
	} else if (prop.slice(0, 10) === "oncapture:") {
		const e = prop.slice(10);
		prev && node.removeEventListener(e, prev, true);
		value && node.addEventListener(e, value, true);
	} else if (prop.slice(0, 2) === "on") {
		const name = prop.slice(2).toLowerCase();
		const delegate = DelegatedEvents.has(name);
		if (!delegate && prev) {
			const h = Array.isArray(prev) ? prev[0] : prev;
			node.removeEventListener(name, h);
		}
		if (delegate || value) {
			addEventListener(node, name, value, delegate);
			delegate && delegateEvents([name]);
		}
	} else if (prop.slice(0, 5) === "attr:") setAttribute(node, prop.slice(5), value);
	else if (prop.slice(0, 5) === "bool:") setBoolAttribute(node, prop.slice(5), value);
	else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-") || "is" in props)) {
		if (forceProp) {
			prop = prop.slice(5);
			isProp = true;
		} else if (isHydrating(node)) return value;
		if (prop === "class" || prop === "className") className(node, value);
		else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;
		else node[propAlias || prop] = value;
	} else {
		const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
		if (ns) setAttributeNS(node, ns, prop, value);
		else setAttribute(node, Aliases[prop] || prop, value);
	}
	return value;
}
function eventHandler(e) {
	if (sharedConfig.registry && sharedConfig.events) {
		if (sharedConfig.events.find(([el, ev]) => ev === e)) return;
	}
	let node = e.target;
	const key = \`$$\${e.type}\`;
	const oriTarget = e.target;
	const oriCurrentTarget = e.currentTarget;
	const retarget = (value) => Object.defineProperty(e, "target", {
		configurable: true,
		value
	});
	const handleNode = () => {
		const handler = node[key];
		if (handler && !node.disabled) {
			const data = node[\`\${key}Data\`];
			data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
			if (e.cancelBubble) return;
		}
		node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
		return true;
	};
	const walkUpTree = () => {
		while (handleNode() && (node = node._$host || node.parentNode || node.host));
	};
	Object.defineProperty(e, "currentTarget", {
		configurable: true,
		get() {
			return node || document;
		}
	});
	if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
	if (e.composedPath) {
		const path = e.composedPath();
		retarget(path[0]);
		for (let i = 0; i < path.length - 2; i++) {
			node = path[i];
			if (!handleNode()) break;
			if (node._$host) {
				node = node._$host;
				walkUpTree();
				break;
			}
			if (node.parentNode === oriCurrentTarget) break;
		}
	} else walkUpTree();
	retarget(oriTarget);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
	const hydrating = isHydrating(parent);
	if (hydrating) {
		!current && (current = [...parent.childNodes]);
		let cleaned = [];
		for (let i = 0; i < current.length; i++) {
			const node = current[i];
			if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
			else cleaned.push(node);
		}
		current = cleaned;
	}
	while (typeof current === "function") current = current();
	if (value === current) return current;
	const t = typeof value, multi = marker !== void 0;
	parent = multi && current[0] && current[0].parentNode || parent;
	if (t === "string" || t === "number") {
		if (hydrating) return current;
		if (t === "number") {
			value = value.toString();
			if (value === current) return current;
		}
		if (multi) {
			let node = current[0];
			if (node && node.nodeType === 3) node.data !== value && (node.data = value);
			else node = document.createTextNode(value);
			current = cleanChildren(parent, current, marker, node);
		} else if (current !== "" && typeof current === "string") current = parent.firstChild.data = value;
		else current = parent.textContent = value;
	} else if (value == null || t === "boolean") {
		if (hydrating) return current;
		current = cleanChildren(parent, current, marker);
	} else if (t === "function") {
		createRenderEffect(() => {
			let v = value();
			while (typeof v === "function") v = v();
			current = insertExpression(parent, v, current, marker);
		});
		return () => current;
	} else if (Array.isArray(value)) {
		const array = [];
		const currentArray = current && Array.isArray(current);
		if (normalizeIncomingArray(array, value, current, unwrapArray)) {
			createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
			return () => current;
		}
		if (hydrating) {
			if (!array.length) return current;
			if (marker === void 0) return current = [...parent.childNodes];
			let node = array[0];
			if (node.parentNode !== parent) return current;
			const nodes = [node];
			while ((node = node.nextSibling) !== marker) nodes.push(node);
			return current = nodes;
		}
		if (array.length === 0) {
			current = cleanChildren(parent, current, marker);
			if (multi) return current;
		} else if (currentArray) if (current.length === 0) appendNodes(parent, array, marker);
		else reconcileArrays(parent, current, array);
		else {
			current && cleanChildren(parent);
			appendNodes(parent, array);
		}
		current = array;
	} else if (value.nodeType) {
		if (hydrating && value.parentNode) return current = multi ? [value] : value;
		if (Array.isArray(current)) {
			if (multi) return current = cleanChildren(parent, current, marker, value);
			cleanChildren(parent, current, null, value);
		} else if (current == null || current === "" || !parent.firstChild) parent.appendChild(value);
		else parent.replaceChild(value, parent.firstChild);
		current = value;
	}
	return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
	let dynamic = false;
	for (let i = 0, len = array.length; i < len; i++) {
		let item = array[i], prev = current && current[normalized.length], t;
		if (item == null || item === true || item === false);
		else if ((t = typeof item) === "object" && item.nodeType) normalized.push(item);
		else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
		else if (t === "function") if (unwrap) {
			while (typeof item === "function") item = item();
			dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
		} else {
			normalized.push(item);
			dynamic = true;
		}
		else {
			const value = String(item);
			if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
			else normalized.push(document.createTextNode(value));
		}
	}
	return dynamic;
}
function appendNodes(parent, array, marker = null) {
	for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
	if (marker === void 0) return parent.textContent = "";
	const node = replacement || document.createTextNode("");
	if (current.length) {
		let inserted = false;
		for (let i = current.length - 1; i >= 0; i--) {
			const el = current[i];
			if (node !== el) {
				const isParent = el.parentNode === parent;
				if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
				else isParent && el.remove();
			} else inserted = true;
		}
	} else parent.insertBefore(node, marker);
	return [node];
}

//#endregion
//#region tests/fixtures/templates.tsx
var _tmpl$ = /* @__PURE__ */ template(\`<svg width=100 height=100><circle cx=50 cy=50 r=40 fill=red></circle><foreignObject x=10 y=10 width=80 height=80><div><p>HTML content inside SVG\`), _tmpl$2 = /* @__PURE__ */ template(\`<div><svg><g><rect x=0 y=0 width=100 height=100>\`), _tmpl$3 = /* @__PURE__ */ template(\`<div><button>Click me</button><div>Hover me</div><input><form><select><option value=1>Option 1</option><option value=2>Option 2\`), _tmpl$4 = /* @__PURE__ */ template(\`<div class=container><h1>Title</h1><ul></ul><div style=color:red;font-size:16px>Styled content\`), _tmpl$5 = /* @__PURE__ */ template(\`<p>Conditional content\`), _tmpl$6 = /* @__PURE__ */ template(\`<li>\`), _tmpl$7 = /* @__PURE__ */ template(\`<div id=test class=my-class data-testid=element aria-label="Accessible element"role=button tabindex=0><img src=test.jpg alt="test image"width=100 height=100><input type=text placeholder="Enter text"required>\`), _tmpl$8 = /* @__PURE__ */ template(\`<svg width=100 height=100><circle cx=50 cy=50 r=40 fill=red></circle><rect x=10 y=10 width=30 height=30 fill=blue></rect><text x=50 y=50 text-anchor=middle>SVG Text\`), _tmpl$9 = /* @__PURE__ */ template(\`<head><title>SSR Test</title><meta charset=utf-8><meta name=viewport content="width=device-width">\`), _tmpl$0 = /* @__PURE__ */ template(\`<div><script>console.log('test');<\\/script><style>body \\{ margin: 0; }\`), _tmpl$1 = /* @__PURE__ */ template(\`<div><p>Static content</p><div></div><ul>\`), _tmpl$10 = /* @__PURE__ */ template(\`<li>Item \`), _tmpl$11 = /* @__PURE__ */ template(\`<div>Spread attributes\`), _tmpl$12 = /* @__PURE__ */ template(\`<table><thead><tr><th>Header 1</th><th>Header 2</th></tr></thead><tbody><tr><td>Cell 1</td><td>Cell 2\`), _tmpl$13 = /* @__PURE__ */ template(\`<div><section><article><header><h1>Title</h1></header><main><p>Content</p></main><footer><small>Footer</small></footer></article></section><table><tr><td>Cell 1</td><td>Cell 2</td></tr></table><img src=test.jpg alt=test><br><hr>\`);
function TestSvgWrap() {
	return _tmpl$();
}
function TestNestedSvg() {
	return _tmpl$2();
}
function TestEventDelegation() {
	return (() => {
		var _el$3 = _tmpl$3(), _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$5.nextSibling, _el$7 = _el$6.nextSibling, _el$8 = _el$7.firstChild;
		_el$4.$$click = () => console.log("click");
		_el$5.$$mouseover = () => console.log("hover");
		_el$6.$$input = (e) => console.log(e.target.value);
		_el$7.addEventListener("submit", (e) => e.preventDefault());
		_el$8.addEventListener("change", (e) => console.log(e.target.value));
		return _el$3;
	})();
}
function TestComplexTemplates() {
	const items = [
		"a",
		"b",
		"c"
	];
	return (() => {
		var _el$9 = _tmpl$4(), _el$1 = _el$9.firstChild.nextSibling;
		_el$1.nextSibling;
		insert(_el$9, _tmpl$5(), _el$1);
		insert(_el$1, () => items.map((item) => (() => {
			var _el$12 = _tmpl$6();
			insert(_el$12, item);
			return _el$12;
		})()));
		return _el$9;
	})();
}
function TestAttributeTemplates() {
	return (() => {
		var _el$13 = _tmpl$7(), _el$15 = _el$13.firstChild.nextSibling;
		_el$15.disabled = false;
		return _el$13;
	})();
}
function TestSVGTemplates() {
	return _tmpl$8();
}
function TestSSRHeadElement() {
	return _tmpl$9();
}
function TestSSRScriptStyle() {
	return _tmpl$0();
}
function TestSSRHydration() {
	return (() => {
		var _el$19 = _tmpl$1(), _el$21 = _el$19.firstChild.nextSibling, _el$22 = _el$21.nextSibling;
		insert(_el$21, () => \`Dynamic content: \${Date.now()}\`);
		insert(_el$22, () => [
			1,
			2,
			3
		].map((item) => (() => {
			var _el$23 = _tmpl$10();
			_el$23.firstChild;
			insert(_el$23, item, null);
			return _el$23;
		})()));
		return _el$19;
	})();
}
function TestSSRSpreadAttributes() {
	const props = {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	};
	return (() => {
		var _el$25 = _tmpl$11();
		spread(_el$25, props, false, true);
		return _el$25;
	})();
}
function TestSSRSpecialElements() {
	return _tmpl$12();
}
function TestValidationScenarios() {
	return _tmpl$13();
}
delegateEvents([
	"click",
	"mouseover",
	"input"
]);

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid src should transform templates with SSR 1`] = `
"//#region node_modules/solid-js/dist/server.js
const ERROR = Symbol("error");
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function handleError(err, owner = Owner) {
	const fns = owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	try {
		for (const f$1 of fns) f$1(error);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
let Owner = null;
function createOwner() {
	const o$2 = {
		owner: Owner,
		context: Owner ? Owner.context : null,
		owned: null,
		cleanups: null
	};
	if (Owner) if (!Owner.owned) Owner.owned = [o$2];
	else Owner.owned.push(o$2);
	return o$2;
}
function createMemo(fn, value) {
	Owner = createOwner();
	let v$2;
	try {
		v$2 = fn(value);
	} catch (err) {
		handleError(err);
	} finally {
		Owner = Owner.owner;
	}
	return () => v$2;
}
function createContext(defaultValue) {
	const id = Symbol("context");
	return {
		id,
		Provider: createProvider(id),
		defaultValue
	};
}
function children(fn) {
	const memo = createMemo(() => resolveChildren(fn()));
	memo.toArray = () => {
		const c$2 = memo();
		return Array.isArray(c$2) ? c$2 : c$2 != null ? [c$2] : [];
	};
	return memo;
}
function resolveChildren(children$1) {
	if (typeof children$1 === "function" && !children$1.length) return resolveChildren(children$1());
	if (Array.isArray(children$1)) {
		const results = [];
		for (let i$1 = 0; i$1 < children$1.length; i$1++) {
			const result = resolveChildren(children$1[i$1]);
			Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
		}
		return results;
	}
	return children$1;
}
function createProvider(id) {
	return function provider(props) {
		return createMemo(() => {
			Owner.context = {
				...Owner.context,
				[id]: props.value
			};
			return children(() => props.children);
		});
	};
}
const sharedConfig = {
	context: void 0,
	getContextId() {
		if (!this.context) throw new Error(\`getContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count);
	},
	getNextContextId() {
		if (!this.context) throw new Error(\`getNextContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
const SuspenseContext = createContext();

//#endregion
//#region node_modules/seroval/dist/esm/production/index.mjs
var L$1 = ((i$1) => (i$1[i$1.AggregateError = 1] = "AggregateError", i$1[i$1.ArrowFunction = 2] = "ArrowFunction", i$1[i$1.ErrorPrototypeStack = 4] = "ErrorPrototypeStack", i$1[i$1.ObjectAssign = 8] = "ObjectAssign", i$1[i$1.BigIntTypedArray = 16] = "BigIntTypedArray", i$1[i$1.RegExp = 32] = "RegExp", i$1))(L$1 || {});
var v$1 = Symbol.asyncIterator, mr = Symbol.hasInstance, R = Symbol.isConcatSpreadable, C = Symbol.iterator, pr = Symbol.match, dr = Symbol.matchAll, gr = Symbol.replace, yr = Symbol.search, Nr = Symbol.species, br = Symbol.split, vr = Symbol.toPrimitive, P$1 = Symbol.toStringTag, Cr = Symbol.unscopables;
var rt = {
	0: "Symbol.asyncIterator",
	1: "Symbol.hasInstance",
	2: "Symbol.isConcatSpreadable",
	3: "Symbol.iterator",
	4: "Symbol.match",
	5: "Symbol.matchAll",
	6: "Symbol.replace",
	7: "Symbol.search",
	8: "Symbol.species",
	9: "Symbol.split",
	10: "Symbol.toPrimitive",
	11: "Symbol.toStringTag",
	12: "Symbol.unscopables"
}, ve = {
	[v$1]: 0,
	[mr]: 1,
	[R]: 2,
	[C]: 3,
	[pr]: 4,
	[dr]: 5,
	[gr]: 6,
	[yr]: 7,
	[Nr]: 8,
	[br]: 9,
	[vr]: 10,
	[P$1]: 11,
	[Cr]: 12
}, tt = {
	0: v$1,
	1: mr,
	2: R,
	3: C,
	4: pr,
	5: dr,
	6: gr,
	7: yr,
	8: Nr,
	9: br,
	10: vr,
	11: P$1,
	12: Cr
}, nt = {
	2: "!0",
	3: "!1",
	1: "void 0",
	0: "null",
	4: "-0",
	5: "1/0",
	6: "-1/0",
	7: "0/0"
}, o$1 = void 0, ot = {
	2: !0,
	3: !1,
	1: o$1,
	0: null,
	4: -0,
	5: Number.POSITIVE_INFINITY,
	6: Number.NEGATIVE_INFINITY,
	7: NaN
};
function c$1(e, r, t, n$1, a, s, i$1, u$1, l$1, g$1, S, d$1) {
	return {
		t: e,
		i: r,
		s: t,
		c: n$1,
		m: a,
		p: s,
		e: i$1,
		a: u$1,
		f: l$1,
		b: g$1,
		o: S,
		l: d$1
	};
}
function F(e) {
	return c$1(2, o$1, e, o$1, o$1, o$1, o$1, o$1, o$1, o$1, o$1, o$1);
}
var J = F(2), Z = F(3), Ae = F(1), Ee = F(0), st = F(4), it = F(5), ut = F(6), lt = F(7);
var U = "__SEROVAL_REFS__", ce = "$R", Ie = \`self.\${ce}\`;
var Ar = /* @__PURE__ */ new Map(), j = /* @__PURE__ */ new Map();
typeof globalThis != "undefined" ? Object.defineProperty(globalThis, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof window != "undefined" ? Object.defineProperty(window, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof self != "undefined" ? Object.defineProperty(self, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof global != "undefined" && Object.defineProperty(global, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
});
var { toString: ys } = Object.prototype;
var re = () => {
	let e = {
		p: 0,
		s: 0,
		f: 0
	};
	return e.p = new Promise((r, t) => {
		e.s = r, e.f = t;
	}), e;
}, vn = (e, r) => {
	e.s(r), e.p.s = 1, e.p.v = r;
}, Cn = (e, r) => {
	e.f(r), e.p.s = 2, e.p.v = r;
}, yt = re.toString(), Nt = vn.toString(), bt = Cn.toString(), Rr = () => {
	let e = [], r = [], t = !0, n$1 = !1, a = 0, s = (l$1, g$1, S) => {
		for (S = 0; S < a; S++) r[S] && r[S][g$1](l$1);
	}, i$1 = (l$1, g$1, S, d$1) => {
		for (g$1 = 0, S = e.length; g$1 < S; g$1++) d$1 = e[g$1], !t && g$1 === S - 1 ? l$1[n$1 ? "return" : "throw"](d$1) : l$1.next(d$1);
	}, u$1 = (l$1, g$1) => (t && (g$1 = a++, r[g$1] = l$1), i$1(l$1), () => {
		t && (r[g$1] = r[a], r[a--] = void 0);
	});
	return {
		__SEROVAL_STREAM__: !0,
		on: (l$1) => u$1(l$1),
		next: (l$1) => {
			t && (e.push(l$1), s(l$1, "next"));
		},
		throw: (l$1) => {
			t && (e.push(l$1), s(l$1, "throw"), t = !1, n$1 = !1, r.length = 0);
		},
		return: (l$1) => {
			t && (e.push(l$1), s(l$1, "return"), t = !1, n$1 = !0, r.length = 0);
		}
	};
}, vt = Rr.toString(), Pr = (e) => (r) => () => {
	let t = 0, n$1 = {
		[e]: () => n$1,
		next: () => {
			if (t > r.d) return {
				done: !0,
				value: void 0
			};
			let a = t++, s = r.v[a];
			if (a === r.t) throw s;
			return {
				done: a === r.d,
				value: s
			};
		}
	};
	return n$1;
}, Ct = Pr.toString(), xr = (e, r) => (t) => () => {
	let n$1 = 0, a = -1, s = !1, i$1 = [], u$1 = [], l$1 = (S = 0, d$1 = u$1.length) => {
		for (; S < d$1; S++) u$1[S].s({
			done: !0,
			value: void 0
		});
	};
	t.on({
		next: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.s({
				done: !1,
				value: S
			}), i$1.push(S);
		},
		throw: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.f(S), l$1(), a = i$1.length, s = !0, i$1.push(S);
		},
		return: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.s({
				done: !0,
				value: S
			}), l$1(), a = i$1.length, i$1.push(S);
		}
	});
	let g$1 = {
		[e]: () => g$1,
		next: () => {
			if (a === -1) {
				let K$1 = n$1++;
				if (K$1 >= i$1.length) {
					let et = r();
					return u$1.push(et), et.p;
				}
				return {
					done: !1,
					value: i$1[K$1]
				};
			}
			if (n$1 > a) return {
				done: !0,
				value: void 0
			};
			let S = n$1++, d$1 = i$1[S];
			if (S !== a) return {
				done: !1,
				value: d$1
			};
			if (s) throw d$1;
			return {
				done: !0,
				value: d$1
			};
		}
	};
	return g$1;
}, At = xr.toString(), Or = (e) => {
	let r = atob(e), t = r.length, n$1 = new Uint8Array(t);
	for (let a = 0; a < t; a++) n$1[a] = r.charCodeAt(a);
	return n$1.buffer;
}, Et = Or.toString();
var An = Pr(C);
function te$1() {
	return Rr();
}
var En = xr(v$1, re);
var ae = ((t) => (t[t.Vanilla = 1] = "Vanilla", t[t.Cross = 2] = "Cross", t))(ae || {});
function ni(e) {
	return e;
}
var Eo = () => T, Io = Eo.toString(), qt = /=>/.test(Io);
var Ht = "hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_", Gt = Ht.length, Jt = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_", Kt = Jt.length;

//#endregion
//#region node_modules/seroval-plugins/dist/esm/production/web.mjs
var u = (e) => {
	let r = new AbortController(), a = r.abort.bind(r);
	return e.then(a, a), r;
};
function E(e) {
	e(this.reason);
}
function D(e) {
	this.addEventListener("abort", E.bind(this, e), { once: !0 });
}
function c(e) {
	return new Promise(D.bind(e));
}
var i = {}, O = ni({
	tag: "seroval-plugins/web/AbortSignal",
	extends: [ni({
		tag: "seroval-plugins/web/AbortControllerFactoryPlugin",
		test(e) {
			return e === i;
		},
		parse: {
			sync() {
				return i;
			},
			async async() {
				return await Promise.resolve(i);
			},
			stream() {
				return i;
			}
		},
		serialize() {
			return u.toString();
		},
		deserialize() {
			return u;
		}
	})],
	test(e) {
		return typeof AbortSignal == "undefined" ? !1 : e instanceof AbortSignal;
	},
	parse: {
		sync(e, r) {
			return e.aborted ? { reason: r.parse(e.reason) } : {};
		},
		async async(e, r) {
			if (e.aborted) return { reason: await r.parse(e.reason) };
			let a = await c(e);
			return { reason: await r.parse(a) };
		},
		stream(e, r) {
			if (e.aborted) return { reason: r.parse(e.reason) };
			let a = c(e);
			return {
				factory: r.parse(i),
				controller: r.parse(a)
			};
		}
	},
	serialize(e, r) {
		return e.reason ? "AbortSignal.abort(" + r.serialize(e.reason) + ")" : e.controller && e.factory ? "(" + r.serialize(e.factory) + ")(" + r.serialize(e.controller) + ").signal" : "(new AbortController).signal";
	},
	deserialize(e, r) {
		return e.reason ? AbortSignal.abort(r.deserialize(e.reason)) : e.controller ? u(r.deserialize(e.controller)).signal : new AbortController().signal;
	}
});
var B = ni({
	tag: "seroval-plugins/web/Blob",
	test(e) {
		return typeof Blob == "undefined" ? !1 : e instanceof Blob;
	},
	parse: { async async(e, r) {
		return {
			type: await r.parse(e.type),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new Blob([" + r.serialize(e.buffer) + "],{type:" + r.serialize(e.type) + "})";
	},
	deserialize(e, r) {
		return new Blob([r.deserialize(e.buffer)], { type: r.deserialize(e.type) });
	}
});
function d(e) {
	return {
		detail: e.detail,
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var L = ni({
	tag: "seroval-plugins/web/CustomEvent",
	test(e) {
		return typeof CustomEvent == "undefined" ? !1 : e instanceof CustomEvent;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(d(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(d(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(d(e))
			};
		}
	},
	serialize(e, r) {
		return "new CustomEvent(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new CustomEvent(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var q = ni({
	tag: "seroval-plugins/web/DOMException",
	test(e) {
		return typeof DOMException == "undefined" ? !1 : e instanceof DOMException;
	},
	parse: {
		sync(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		},
		async async(e, r) {
			return {
				name: await r.parse(e.name),
				message: await r.parse(e.message)
			};
		},
		stream(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		}
	},
	serialize(e, r) {
		return "new DOMException(" + r.serialize(e.message) + "," + r.serialize(e.name) + ")";
	},
	deserialize(e, r) {
		return new DOMException(r.deserialize(e.message), r.deserialize(e.name));
	}
});
function f(e) {
	return {
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var Y = ni({
	tag: "seroval-plugins/web/Event",
	test(e) {
		return typeof Event == "undefined" ? !1 : e instanceof Event;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(f(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		}
	},
	serialize(e, r) {
		return "new Event(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Event(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var m = ni({
	tag: "seroval-plugins/web/File",
	test(e) {
		return typeof File == "undefined" ? !1 : e instanceof File;
	},
	parse: { async async(e, r) {
		return {
			name: await r.parse(e.name),
			options: await r.parse({
				type: e.type,
				lastModified: e.lastModified
			}),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new File([" + r.serialize(e.buffer) + "]," + r.serialize(e.name) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new File([r.deserialize(e.buffer)], r.deserialize(e.name), r.deserialize(e.options));
	}
});
function y(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var o = {}, v = (e, r = new FormData(), a = 0, t = e.length, s) => {
	for (; a < t; a++) s = e[a], r.append(s[0], s[1]);
	return r;
}, K = ni({
	tag: "seroval-plugins/web/FormData",
	extends: [m, ni({
		tag: "seroval-plugins/web/FormDataFactory",
		test(e) {
			return e === o;
		},
		parse: {
			sync() {
				return o;
			},
			async async() {
				return await Promise.resolve(o);
			},
			stream() {
				return o;
			}
		},
		serialize() {
			return v.toString();
		},
		deserialize() {
			return o;
		}
	})],
	test(e) {
		return typeof FormData == "undefined" ? !1 : e instanceof FormData;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(o),
				entries: r.parse(y(e))
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(o),
				entries: await r.parse(y(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(o),
				entries: r.parse(y(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.entries) + ")";
	},
	deserialize(e, r) {
		return v(r.deserialize(e.entries));
	}
});
function g(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var l = ni({
	tag: "seroval-plugins/web/Headers",
	test(e) {
		return typeof Headers == "undefined" ? !1 : e instanceof Headers;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(g(e)) };
		},
		async async(e, r) {
			return { value: await r.parse(g(e)) };
		},
		stream(e, r) {
			return { value: r.parse(g(e)) };
		}
	},
	serialize(e, r) {
		return "new Headers(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new Headers(r.deserialize(e.value));
	}
});
var $ = ni({
	tag: "seroval-plugins/web/ImageData",
	test(e) {
		return typeof ImageData == "undefined" ? !1 : e instanceof ImageData;
	},
	parse: {
		sync(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		},
		async async(e, r) {
			return {
				data: await r.parse(e.data),
				width: await r.parse(e.width),
				height: await r.parse(e.height),
				options: await r.parse({ colorSpace: e.colorSpace })
			};
		},
		stream(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		}
	},
	serialize(e, r) {
		return "new ImageData(" + r.serialize(e.data) + "," + r.serialize(e.width) + "," + r.serialize(e.height) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new ImageData(r.deserialize(e.data), r.deserialize(e.width), r.deserialize(e.height), r.deserialize(e.options));
	}
});
var n = {}, P = (e) => new ReadableStream({ start: (r) => {
	e.on({
		next: (a) => {
			try {
				r.enqueue(a);
			} catch (t) {}
		},
		throw: (a) => {
			r.error(a);
		},
		return: () => {
			try {
				r.close();
			} catch (a) {}
		}
	});
} }), x = ni({
	tag: "seroval-plugins/web/ReadableStreamFactory",
	test(e) {
		return e === n;
	},
	parse: {
		sync() {
			return n;
		},
		async async() {
			return await Promise.resolve(n);
		},
		stream() {
			return n;
		}
	},
	serialize() {
		return P.toString();
	},
	deserialize() {
		return n;
	}
});
function w(e) {
	let r = te$1(), a = e.getReader();
	async function t() {
		try {
			let s = await a.read();
			s.done ? r.return(s.value) : (r.next(s.value), await t());
		} catch (s) {
			r.throw(s);
		}
	}
	return t().catch(() => {}), r;
}
var p = ni({
	tag: "seroval/plugins/web/ReadableStream",
	extends: [x],
	test(e) {
		return typeof ReadableStream == "undefined" ? !1 : e instanceof ReadableStream;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(n),
				stream: r.parse(te$1())
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(n),
				stream: await r.parse(w(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(n),
				stream: r.parse(w(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.stream) + ")";
	},
	deserialize(e, r) {
		return P(r.deserialize(e.stream));
	}
});
function N(e, r) {
	return {
		body: r,
		cache: e.cache,
		credentials: e.credentials,
		headers: e.headers,
		integrity: e.integrity,
		keepalive: e.keepalive,
		method: e.method,
		mode: e.mode,
		redirect: e.redirect,
		referrer: e.referrer,
		referrerPolicy: e.referrerPolicy
	};
}
var te = ni({
	tag: "seroval-plugins/web/Request",
	extends: [p, l],
	test(e) {
		return typeof Request == "undefined" ? !1 : e instanceof Request;
	},
	parse: {
		async async(e, r) {
			return {
				url: await r.parse(e.url),
				options: await r.parse(N(e, e.body && !e.bodyUsed ? await e.clone().arrayBuffer() : null))
			};
		},
		stream(e, r) {
			return {
				url: r.parse(e.url),
				options: r.parse(N(e, e.body && !e.bodyUsed ? e.clone().body : null))
			};
		}
	},
	serialize(e, r) {
		return "new Request(" + r.serialize(e.url) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Request(r.deserialize(e.url), r.deserialize(e.options));
	}
});
function h(e) {
	return {
		headers: e.headers,
		status: e.status,
		statusText: e.statusText
	};
}
var ne = ni({
	tag: "seroval-plugins/web/Response",
	extends: [p, l],
	test(e) {
		return typeof Response == "undefined" ? !1 : e instanceof Response;
	},
	parse: {
		async async(e, r) {
			return {
				body: await r.parse(e.body && !e.bodyUsed ? await e.clone().arrayBuffer() : null),
				options: await r.parse(h(e))
			};
		},
		stream(e, r) {
			return {
				body: r.parse(e.body && !e.bodyUsed ? e.clone().body : null),
				options: r.parse(h(e))
			};
		}
	},
	serialize(e, r) {
		return "new Response(" + r.serialize(e.body) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Response(r.deserialize(e.body), r.deserialize(e.options));
	}
});
var pe = ni({
	tag: "seroval-plugins/web/URL",
	test(e) {
		return typeof URL == "undefined" ? !1 : e instanceof URL;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(e.href) };
		},
		async async(e, r) {
			return { value: await r.parse(e.href) };
		},
		stream(e, r) {
			return { value: r.parse(e.href) };
		}
	},
	serialize(e, r) {
		return "new URL(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new URL(r.deserialize(e.value));
	}
});
var fe = ni({
	tag: "seroval-plugins/web/URLSearchParams",
	test(e) {
		return typeof URLSearchParams == "undefined" ? !1 : e instanceof URLSearchParams;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(e.toString()) };
		},
		async async(e, r) {
			return { value: await r.parse(e.toString()) };
		},
		stream(e, r) {
			return { value: r.parse(e.toString()) };
		}
	},
	serialize(e, r) {
		return "new URLSearchParams(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new URLSearchParams(r.deserialize(e.value));
	}
});

//#endregion
//#region node_modules/solid-js/web/dist/server.js
const booleans = [
	"allowfullscreen",
	"async",
	"alpha",
	"autofocus",
	"autoplay",
	"checked",
	"controls",
	"default",
	"disabled",
	"formnovalidate",
	"hidden",
	"indeterminate",
	"inert",
	"ismap",
	"loop",
	"multiple",
	"muted",
	"nomodule",
	"novalidate",
	"open",
	"playsinline",
	"readonly",
	"required",
	"reversed",
	"seamless",
	"selected",
	"adauctionheaders",
	"browsingtopics",
	"credentialless",
	"defaultchecked",
	"defaultmuted",
	"defaultselected",
	"defer",
	"disablepictureinpicture",
	"disableremoteplayback",
	"preservespitch",
	"shadowrootclonable",
	"shadowrootcustomelementregistry",
	"shadowrootdelegatesfocus",
	"shadowrootserializable",
	"sharedstoragewritable"
];
const BooleanAttributes = /* @__PURE__ */ new Set(booleans);
const Properties = /* @__PURE__ */ new Set([
	"className",
	"value",
	"readOnly",
	"noValidate",
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"adAuctionHeaders",
	"allowFullscreen",
	"browsingTopics",
	"defaultChecked",
	"defaultMuted",
	"defaultSelected",
	"disablePictureInPicture",
	"disableRemotePlayback",
	"preservesPitch",
	"shadowRootClonable",
	"shadowRootCustomElementRegistry",
	"shadowRootDelegatesFocus",
	"shadowRootSerializable",
	"sharedStorageWritable",
	...booleans
]);
const ChildProperties = /* @__PURE__ */ new Set([
	"innerHTML",
	"textContent",
	"innerText",
	"children"
]);
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
const ES2017FLAG = L$1.AggregateError | L$1.BigIntTypedArray;
const VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
function ssr(t, ...nodes) {
	if (nodes.length) {
		let result = "";
		for (let i$1 = 0; i$1 < nodes.length; i$1++) {
			result += t[i$1];
			const node = nodes[i$1];
			if (node !== void 0) result += resolveSSRNode(node);
		}
		t = result + t[nodes.length];
	}
	return { t };
}
function ssrClassList(value) {
	if (!value) return "";
	let classKeys = Object.keys(value), result = "";
	for (let i$1 = 0, len = classKeys.length; i$1 < len; i$1++) {
		const key = classKeys[i$1], classValue = !!value[key];
		if (!key || key === "undefined" || !classValue) continue;
		i$1 && (result += " ");
		result += escape(key);
	}
	return result;
}
function ssrStyle(value) {
	if (!value) return "";
	if (typeof value === "string") return escape(value, true);
	let result = "";
	const k = Object.keys(value);
	for (let i$1 = 0; i$1 < k.length; i$1++) {
		const s = k[i$1];
		const v$2 = value[s];
		if (v$2 != void 0) {
			if (i$1) result += ";";
			const r = escape(v$2, true);
			if (r != void 0 && r !== "undefined") result += \`\${s}:\${r}\`;
		}
	}
	return result;
}
function ssrStyleProperty(name, value) {
	return value != null ? name + value : "";
}
function ssrElement(tag, props, children$1, needsId) {
	if (props == null) props = {};
	else if (typeof props === "function") props = props();
	const skipChildren = VOID_ELEMENTS.test(tag);
	const keys = Object.keys(props);
	let result = \`<\${tag}\${needsId ? ssrHydrationKey() : ""} \`;
	let classResolved;
	for (let i$1 = 0; i$1 < keys.length; i$1++) {
		const prop = keys[i$1];
		if (ChildProperties.has(prop)) {
			if (children$1 === void 0 && !skipChildren) children$1 = tag === "script" || tag === "style" || prop === "innerHTML" ? props[prop] : escape(props[prop]);
			continue;
		}
		const value = props[prop];
		if (prop === "style") result += \`style="\${ssrStyle(value)}"\`;
		else if (prop === "class" || prop === "className" || prop === "classList") {
			if (classResolved) continue;
			let n$1;
			result += \`class="\${escape(((n$1 = props.class) ? n$1 + " " : "") + ((n$1 = props.className) ? n$1 + " " : ""), true) + ssrClassList(props.classList)}"\`;
			classResolved = true;
		} else if (BooleanAttributes.has(prop)) if (value) result += prop;
		else continue;
		else if (value == void 0 || prop === "ref" || prop.slice(0, 2) === "on" || prop.slice(0, 5) === "prop:") continue;
		else if (prop.slice(0, 5) === "bool:") {
			if (!value) continue;
			result += escape(prop.slice(5));
		} else if (prop.slice(0, 5) === "attr:") result += \`\${escape(prop.slice(5))}="\${escape(value, true)}"\`;
		else result += \`\${Aliases[prop] || escape(prop)}="\${escape(value, true)}"\`;
		if (i$1 !== keys.length - 1) result += " ";
	}
	if (skipChildren) return { t: result + "/>" };
	if (typeof children$1 === "function") children$1 = children$1();
	return { t: result + \`>\${resolveSSRNode(children$1, true)}</\${tag}>\` };
}
function ssrHydrationKey() {
	const hk = getHydrationKey();
	return hk ? \` data-hk="\${hk}"\` : "";
}
function escape(s, attr) {
	const t = typeof s;
	if (t !== "string") {
		if (!attr && t === "function") return escape(s());
		if (!attr && Array.isArray(s)) {
			s = s.slice();
			for (let i$1 = 0; i$1 < s.length; i$1++) s[i$1] = escape(s[i$1]);
			return s;
		}
		if (attr && t === "boolean") return String(s);
		return s;
	}
	const delim = attr ? "\\"" : "<";
	const escDelim = attr ? "&quot;" : "&lt;";
	let iDelim = s.indexOf(delim);
	let iAmp = s.indexOf("&");
	if (iDelim < 0 && iAmp < 0) return s;
	let left = 0, out = "";
	while (iDelim >= 0 && iAmp >= 0) if (iDelim < iAmp) {
		if (left < iDelim) out += s.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s.indexOf(delim, left);
	} else {
		if (left < iAmp) out += s.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s.indexOf("&", left);
	}
	if (iDelim >= 0) do {
		if (left < iDelim) out += s.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s.indexOf(delim, left);
	} while (iDelim >= 0);
	else while (iAmp >= 0) {
		if (left < iAmp) out += s.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s.indexOf("&", left);
	}
	return left < s.length ? out + s.substring(left) : out;
}
function resolveSSRNode(node, top) {
	const t = typeof node;
	if (t === "string") return node;
	if (node == null || t === "boolean") return "";
	if (Array.isArray(node)) {
		let prev = {};
		let mapped = "";
		for (let i$1 = 0, len = node.length; i$1 < len; i$1++) {
			if (!top && typeof prev !== "object" && typeof node[i$1] !== "object") mapped += \`<!--!$-->\`;
			mapped += resolveSSRNode(prev = node[i$1]);
		}
		return mapped;
	}
	if (t === "object") return node.t;
	if (t === "function") return resolveSSRNode(node());
	return String(node);
}
function getHydrationKey() {
	const hydrate = sharedConfig.context;
	return hydrate && !hydrate.noHydrate && sharedConfig.getNextContextId();
}

//#endregion
//#region tests/fixtures/templates.tsx
var _tmpl$ = "<svg width=\\"100\\" height=\\"100\\"><circle cx=\\"50\\" cy=\\"50\\" r=\\"40\\" fill=\\"red\\"></circle><foreignObject x=\\"10\\" y=\\"10\\" width=\\"80\\" height=\\"80\\"><div><p>HTML content inside SVG</p></div></foreignObject></svg>", _tmpl$2 = "<div><svg><g><rect x=\\"0\\" y=\\"0\\" width=\\"100\\" height=\\"100\\"></rect></g></svg></div>", _tmpl$3 = "<div><button>Click me</button><div>Hover me</div><input><form><select><option value=\\"1\\">Option 1</option><option value=\\"2\\">Option 2</option></select></form></div>", _tmpl$4 = [
	"<div class=\\"container\\"><h1>Title</h1>",
	"<ul>",
	"</ul><div style=\\"",
	"\\">Styled content</div></div>"
], _tmpl$5 = "<p>Conditional content</p>", _tmpl$6 = ["<li>", "</li>"], _tmpl$7 = "<div id=\\"test\\" class=\\"my-class\\" data-testid=\\"element\\" aria-label=\\"Accessible element\\" role=\\"button\\" tabindex=\\"0\\"><img src=\\"test.jpg\\" alt=\\"test image\\" width=\\"100\\" height=\\"100\\"><input type=\\"text\\" placeholder=\\"Enter text\\" required></div>", _tmpl$8 = "<svg width=\\"100\\" height=\\"100\\"><circle cx=\\"50\\" cy=\\"50\\" r=\\"40\\" fill=\\"red\\"></circle><rect x=\\"10\\" y=\\"10\\" width=\\"30\\" height=\\"30\\" fill=\\"blue\\"></rect><text x=\\"50\\" y=\\"50\\" text-anchor=\\"middle\\">SVG Text</text></svg>", _tmpl$9 = "<head><title>SSR Test</title><meta charset=\\"utf-8\\"><meta name=\\"viewport\\" content=\\"width=device-width\\"></head>", _tmpl$0 = "<div><script>console.log('test');<\\/script><style>body { margin: 0; }</style></div>", _tmpl$1 = [
	"<div><p>Static content</p><div>",
	"</div><ul>",
	"</ul></div>"
], _tmpl$10 = ["<li>Item ", "</li>"], _tmpl$11 = "<table><thead><tr><th>Header 1</th><th>Header 2</th></tr></thead><tbody><tr><td>Cell 1</td><td>Cell 2</td></tr></tbody></table>", _tmpl$12 = "<div><section><article><header><h1>Title</h1></header><main><p>Content</p></main><footer><small>Footer</small></footer></article></section><table><tr><td>Cell 1</td><td>Cell 2</td></tr></table><img src=\\"test.jpg\\" alt=\\"test\\"><br><hr></div>";
function TestSvgWrap() {
	return ssr(_tmpl$);
}
function TestNestedSvg() {
	return ssr(_tmpl$2);
}
function TestEventDelegation() {
	return ssr(_tmpl$3);
}
function TestComplexTemplates() {
	return ssr(_tmpl$4, _tmpl$5, escape([
		"a",
		"b",
		"c"
	].map((item) => ssr(_tmpl$6, escape(item)))), ssrStyleProperty("color:", "red") + ssrStyleProperty(";font-size:", "16px"));
}
function TestAttributeTemplates() {
	return ssr(_tmpl$7);
}
function TestSVGTemplates() {
	return ssr(_tmpl$8);
}
function TestSSRHeadElement() {
	return ssr(_tmpl$9);
}
function TestSSRScriptStyle() {
	return ssr(_tmpl$0);
}
function TestSSRHydration() {
	return ssr(_tmpl$1, \`Dynamic content: \${escape(Date.now())}\`, escape([
		1,
		2,
		3
	].map((item) => ssr(_tmpl$10, escape(item)))));
}
function TestSSRSpreadAttributes() {
	return ssrElement("div", {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	}, "Spread attributes", false);
}
function TestSSRSpecialElements() {
	return ssr(_tmpl$11);
}
function TestValidationScenarios() {
	return ssr(_tmpl$12);
}

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid dist should transform templates with SSR 1`] = `
"//#region node_modules/solid-js/dist/server.js
const ERROR = Symbol("error");
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function handleError(err, owner = Owner) {
	const fns = owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	try {
		for (const f$1 of fns) f$1(error);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
let Owner = null;
function createOwner() {
	const o$2 = {
		owner: Owner,
		context: Owner ? Owner.context : null,
		owned: null,
		cleanups: null
	};
	if (Owner) if (!Owner.owned) Owner.owned = [o$2];
	else Owner.owned.push(o$2);
	return o$2;
}
function createMemo(fn, value) {
	Owner = createOwner();
	let v$2;
	try {
		v$2 = fn(value);
	} catch (err) {
		handleError(err);
	} finally {
		Owner = Owner.owner;
	}
	return () => v$2;
}
function createContext(defaultValue) {
	const id = Symbol("context");
	return {
		id,
		Provider: createProvider(id),
		defaultValue
	};
}
function children(fn) {
	const memo = createMemo(() => resolveChildren(fn()));
	memo.toArray = () => {
		const c$2 = memo();
		return Array.isArray(c$2) ? c$2 : c$2 != null ? [c$2] : [];
	};
	return memo;
}
function resolveChildren(children$1) {
	if (typeof children$1 === "function" && !children$1.length) return resolveChildren(children$1());
	if (Array.isArray(children$1)) {
		const results = [];
		for (let i$1 = 0; i$1 < children$1.length; i$1++) {
			const result = resolveChildren(children$1[i$1]);
			Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
		}
		return results;
	}
	return children$1;
}
function createProvider(id) {
	return function provider(props) {
		return createMemo(() => {
			Owner.context = {
				...Owner.context,
				[id]: props.value
			};
			return children(() => props.children);
		});
	};
}
const sharedConfig = {
	context: void 0,
	getContextId() {
		if (!this.context) throw new Error(\`getContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count);
	},
	getNextContextId() {
		if (!this.context) throw new Error(\`getNextContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
const SuspenseContext = createContext();

//#endregion
//#region node_modules/seroval/dist/esm/production/index.mjs
var L$1 = ((i$1) => (i$1[i$1.AggregateError = 1] = "AggregateError", i$1[i$1.ArrowFunction = 2] = "ArrowFunction", i$1[i$1.ErrorPrototypeStack = 4] = "ErrorPrototypeStack", i$1[i$1.ObjectAssign = 8] = "ObjectAssign", i$1[i$1.BigIntTypedArray = 16] = "BigIntTypedArray", i$1[i$1.RegExp = 32] = "RegExp", i$1))(L$1 || {});
var v$1 = Symbol.asyncIterator, mr = Symbol.hasInstance, R = Symbol.isConcatSpreadable, C = Symbol.iterator, pr = Symbol.match, dr = Symbol.matchAll, gr = Symbol.replace, yr = Symbol.search, Nr = Symbol.species, br = Symbol.split, vr = Symbol.toPrimitive, P$1 = Symbol.toStringTag, Cr = Symbol.unscopables;
var rt = {
	0: "Symbol.asyncIterator",
	1: "Symbol.hasInstance",
	2: "Symbol.isConcatSpreadable",
	3: "Symbol.iterator",
	4: "Symbol.match",
	5: "Symbol.matchAll",
	6: "Symbol.replace",
	7: "Symbol.search",
	8: "Symbol.species",
	9: "Symbol.split",
	10: "Symbol.toPrimitive",
	11: "Symbol.toStringTag",
	12: "Symbol.unscopables"
}, ve = {
	[v$1]: 0,
	[mr]: 1,
	[R]: 2,
	[C]: 3,
	[pr]: 4,
	[dr]: 5,
	[gr]: 6,
	[yr]: 7,
	[Nr]: 8,
	[br]: 9,
	[vr]: 10,
	[P$1]: 11,
	[Cr]: 12
}, tt = {
	0: v$1,
	1: mr,
	2: R,
	3: C,
	4: pr,
	5: dr,
	6: gr,
	7: yr,
	8: Nr,
	9: br,
	10: vr,
	11: P$1,
	12: Cr
}, nt = {
	2: "!0",
	3: "!1",
	1: "void 0",
	0: "null",
	4: "-0",
	5: "1/0",
	6: "-1/0",
	7: "0/0"
}, o$1 = void 0, ot = {
	2: !0,
	3: !1,
	1: o$1,
	0: null,
	4: -0,
	5: Number.POSITIVE_INFINITY,
	6: Number.NEGATIVE_INFINITY,
	7: NaN
};
function c$1(e, r, t, n$1, a, s, i$1, u$1, l$1, g$1, S, d$1) {
	return {
		t: e,
		i: r,
		s: t,
		c: n$1,
		m: a,
		p: s,
		e: i$1,
		a: u$1,
		f: l$1,
		b: g$1,
		o: S,
		l: d$1
	};
}
function F(e) {
	return c$1(2, o$1, e, o$1, o$1, o$1, o$1, o$1, o$1, o$1, o$1, o$1);
}
var J = F(2), Z = F(3), Ae = F(1), Ee = F(0), st = F(4), it = F(5), ut = F(6), lt = F(7);
var U = "__SEROVAL_REFS__", ce = "$R", Ie = \`self.\${ce}\`;
var Ar = /* @__PURE__ */ new Map(), j = /* @__PURE__ */ new Map();
typeof globalThis != "undefined" ? Object.defineProperty(globalThis, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof window != "undefined" ? Object.defineProperty(window, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof self != "undefined" ? Object.defineProperty(self, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof global != "undefined" && Object.defineProperty(global, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
});
var { toString: ys } = Object.prototype;
var re = () => {
	let e = {
		p: 0,
		s: 0,
		f: 0
	};
	return e.p = new Promise((r, t) => {
		e.s = r, e.f = t;
	}), e;
}, vn = (e, r) => {
	e.s(r), e.p.s = 1, e.p.v = r;
}, Cn = (e, r) => {
	e.f(r), e.p.s = 2, e.p.v = r;
}, yt = re.toString(), Nt = vn.toString(), bt = Cn.toString(), Rr = () => {
	let e = [], r = [], t = !0, n$1 = !1, a = 0, s = (l$1, g$1, S) => {
		for (S = 0; S < a; S++) r[S] && r[S][g$1](l$1);
	}, i$1 = (l$1, g$1, S, d$1) => {
		for (g$1 = 0, S = e.length; g$1 < S; g$1++) d$1 = e[g$1], !t && g$1 === S - 1 ? l$1[n$1 ? "return" : "throw"](d$1) : l$1.next(d$1);
	}, u$1 = (l$1, g$1) => (t && (g$1 = a++, r[g$1] = l$1), i$1(l$1), () => {
		t && (r[g$1] = r[a], r[a--] = void 0);
	});
	return {
		__SEROVAL_STREAM__: !0,
		on: (l$1) => u$1(l$1),
		next: (l$1) => {
			t && (e.push(l$1), s(l$1, "next"));
		},
		throw: (l$1) => {
			t && (e.push(l$1), s(l$1, "throw"), t = !1, n$1 = !1, r.length = 0);
		},
		return: (l$1) => {
			t && (e.push(l$1), s(l$1, "return"), t = !1, n$1 = !0, r.length = 0);
		}
	};
}, vt = Rr.toString(), Pr = (e) => (r) => () => {
	let t = 0, n$1 = {
		[e]: () => n$1,
		next: () => {
			if (t > r.d) return {
				done: !0,
				value: void 0
			};
			let a = t++, s = r.v[a];
			if (a === r.t) throw s;
			return {
				done: a === r.d,
				value: s
			};
		}
	};
	return n$1;
}, Ct = Pr.toString(), xr = (e, r) => (t) => () => {
	let n$1 = 0, a = -1, s = !1, i$1 = [], u$1 = [], l$1 = (S = 0, d$1 = u$1.length) => {
		for (; S < d$1; S++) u$1[S].s({
			done: !0,
			value: void 0
		});
	};
	t.on({
		next: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.s({
				done: !1,
				value: S
			}), i$1.push(S);
		},
		throw: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.f(S), l$1(), a = i$1.length, s = !0, i$1.push(S);
		},
		return: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.s({
				done: !0,
				value: S
			}), l$1(), a = i$1.length, i$1.push(S);
		}
	});
	let g$1 = {
		[e]: () => g$1,
		next: () => {
			if (a === -1) {
				let K$1 = n$1++;
				if (K$1 >= i$1.length) {
					let et = r();
					return u$1.push(et), et.p;
				}
				return {
					done: !1,
					value: i$1[K$1]
				};
			}
			if (n$1 > a) return {
				done: !0,
				value: void 0
			};
			let S = n$1++, d$1 = i$1[S];
			if (S !== a) return {
				done: !1,
				value: d$1
			};
			if (s) throw d$1;
			return {
				done: !0,
				value: d$1
			};
		}
	};
	return g$1;
}, At = xr.toString(), Or = (e) => {
	let r = atob(e), t = r.length, n$1 = new Uint8Array(t);
	for (let a = 0; a < t; a++) n$1[a] = r.charCodeAt(a);
	return n$1.buffer;
}, Et = Or.toString();
var An = Pr(C);
function te$1() {
	return Rr();
}
var En = xr(v$1, re);
var ae = ((t) => (t[t.Vanilla = 1] = "Vanilla", t[t.Cross = 2] = "Cross", t))(ae || {});
function ni(e) {
	return e;
}
var Eo = () => T, Io = Eo.toString(), qt = /=>/.test(Io);
var Ht = "hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_", Gt = Ht.length, Jt = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_", Kt = Jt.length;

//#endregion
//#region node_modules/seroval-plugins/dist/esm/production/web.mjs
var u = (e) => {
	let r = new AbortController(), a = r.abort.bind(r);
	return e.then(a, a), r;
};
function E(e) {
	e(this.reason);
}
function D(e) {
	this.addEventListener("abort", E.bind(this, e), { once: !0 });
}
function c(e) {
	return new Promise(D.bind(e));
}
var i = {}, O = ni({
	tag: "seroval-plugins/web/AbortSignal",
	extends: [ni({
		tag: "seroval-plugins/web/AbortControllerFactoryPlugin",
		test(e) {
			return e === i;
		},
		parse: {
			sync() {
				return i;
			},
			async async() {
				return await Promise.resolve(i);
			},
			stream() {
				return i;
			}
		},
		serialize() {
			return u.toString();
		},
		deserialize() {
			return u;
		}
	})],
	test(e) {
		return typeof AbortSignal == "undefined" ? !1 : e instanceof AbortSignal;
	},
	parse: {
		sync(e, r) {
			return e.aborted ? { reason: r.parse(e.reason) } : {};
		},
		async async(e, r) {
			if (e.aborted) return { reason: await r.parse(e.reason) };
			let a = await c(e);
			return { reason: await r.parse(a) };
		},
		stream(e, r) {
			if (e.aborted) return { reason: r.parse(e.reason) };
			let a = c(e);
			return {
				factory: r.parse(i),
				controller: r.parse(a)
			};
		}
	},
	serialize(e, r) {
		return e.reason ? "AbortSignal.abort(" + r.serialize(e.reason) + ")" : e.controller && e.factory ? "(" + r.serialize(e.factory) + ")(" + r.serialize(e.controller) + ").signal" : "(new AbortController).signal";
	},
	deserialize(e, r) {
		return e.reason ? AbortSignal.abort(r.deserialize(e.reason)) : e.controller ? u(r.deserialize(e.controller)).signal : new AbortController().signal;
	}
});
var B = ni({
	tag: "seroval-plugins/web/Blob",
	test(e) {
		return typeof Blob == "undefined" ? !1 : e instanceof Blob;
	},
	parse: { async async(e, r) {
		return {
			type: await r.parse(e.type),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new Blob([" + r.serialize(e.buffer) + "],{type:" + r.serialize(e.type) + "})";
	},
	deserialize(e, r) {
		return new Blob([r.deserialize(e.buffer)], { type: r.deserialize(e.type) });
	}
});
function d(e) {
	return {
		detail: e.detail,
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var L = ni({
	tag: "seroval-plugins/web/CustomEvent",
	test(e) {
		return typeof CustomEvent == "undefined" ? !1 : e instanceof CustomEvent;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(d(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(d(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(d(e))
			};
		}
	},
	serialize(e, r) {
		return "new CustomEvent(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new CustomEvent(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var q = ni({
	tag: "seroval-plugins/web/DOMException",
	test(e) {
		return typeof DOMException == "undefined" ? !1 : e instanceof DOMException;
	},
	parse: {
		sync(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		},
		async async(e, r) {
			return {
				name: await r.parse(e.name),
				message: await r.parse(e.message)
			};
		},
		stream(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		}
	},
	serialize(e, r) {
		return "new DOMException(" + r.serialize(e.message) + "," + r.serialize(e.name) + ")";
	},
	deserialize(e, r) {
		return new DOMException(r.deserialize(e.message), r.deserialize(e.name));
	}
});
function f(e) {
	return {
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var Y = ni({
	tag: "seroval-plugins/web/Event",
	test(e) {
		return typeof Event == "undefined" ? !1 : e instanceof Event;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(f(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		}
	},
	serialize(e, r) {
		return "new Event(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Event(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var m = ni({
	tag: "seroval-plugins/web/File",
	test(e) {
		return typeof File == "undefined" ? !1 : e instanceof File;
	},
	parse: { async async(e, r) {
		return {
			name: await r.parse(e.name),
			options: await r.parse({
				type: e.type,
				lastModified: e.lastModified
			}),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new File([" + r.serialize(e.buffer) + "]," + r.serialize(e.name) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new File([r.deserialize(e.buffer)], r.deserialize(e.name), r.deserialize(e.options));
	}
});
function y(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var o = {}, v = (e, r = new FormData(), a = 0, t = e.length, s) => {
	for (; a < t; a++) s = e[a], r.append(s[0], s[1]);
	return r;
}, K = ni({
	tag: "seroval-plugins/web/FormData",
	extends: [m, ni({
		tag: "seroval-plugins/web/FormDataFactory",
		test(e) {
			return e === o;
		},
		parse: {
			sync() {
				return o;
			},
			async async() {
				return await Promise.resolve(o);
			},
			stream() {
				return o;
			}
		},
		serialize() {
			return v.toString();
		},
		deserialize() {
			return o;
		}
	})],
	test(e) {
		return typeof FormData == "undefined" ? !1 : e instanceof FormData;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(o),
				entries: r.parse(y(e))
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(o),
				entries: await r.parse(y(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(o),
				entries: r.parse(y(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.entries) + ")";
	},
	deserialize(e, r) {
		return v(r.deserialize(e.entries));
	}
});
function g(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var l = ni({
	tag: "seroval-plugins/web/Headers",
	test(e) {
		return typeof Headers == "undefined" ? !1 : e instanceof Headers;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(g(e)) };
		},
		async async(e, r) {
			return { value: await r.parse(g(e)) };
		},
		stream(e, r) {
			return { value: r.parse(g(e)) };
		}
	},
	serialize(e, r) {
		return "new Headers(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new Headers(r.deserialize(e.value));
	}
});
var $ = ni({
	tag: "seroval-plugins/web/ImageData",
	test(e) {
		return typeof ImageData == "undefined" ? !1 : e instanceof ImageData;
	},
	parse: {
		sync(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		},
		async async(e, r) {
			return {
				data: await r.parse(e.data),
				width: await r.parse(e.width),
				height: await r.parse(e.height),
				options: await r.parse({ colorSpace: e.colorSpace })
			};
		},
		stream(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		}
	},
	serialize(e, r) {
		return "new ImageData(" + r.serialize(e.data) + "," + r.serialize(e.width) + "," + r.serialize(e.height) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new ImageData(r.deserialize(e.data), r.deserialize(e.width), r.deserialize(e.height), r.deserialize(e.options));
	}
});
var n = {}, P = (e) => new ReadableStream({ start: (r) => {
	e.on({
		next: (a) => {
			try {
				r.enqueue(a);
			} catch (t) {}
		},
		throw: (a) => {
			r.error(a);
		},
		return: () => {
			try {
				r.close();
			} catch (a) {}
		}
	});
} }), x = ni({
	tag: "seroval-plugins/web/ReadableStreamFactory",
	test(e) {
		return e === n;
	},
	parse: {
		sync() {
			return n;
		},
		async async() {
			return await Promise.resolve(n);
		},
		stream() {
			return n;
		}
	},
	serialize() {
		return P.toString();
	},
	deserialize() {
		return n;
	}
});
function w(e) {
	let r = te$1(), a = e.getReader();
	async function t() {
		try {
			let s = await a.read();
			s.done ? r.return(s.value) : (r.next(s.value), await t());
		} catch (s) {
			r.throw(s);
		}
	}
	return t().catch(() => {}), r;
}
var p = ni({
	tag: "seroval/plugins/web/ReadableStream",
	extends: [x],
	test(e) {
		return typeof ReadableStream == "undefined" ? !1 : e instanceof ReadableStream;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(n),
				stream: r.parse(te$1())
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(n),
				stream: await r.parse(w(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(n),
				stream: r.parse(w(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.stream) + ")";
	},
	deserialize(e, r) {
		return P(r.deserialize(e.stream));
	}
});
function N(e, r) {
	return {
		body: r,
		cache: e.cache,
		credentials: e.credentials,
		headers: e.headers,
		integrity: e.integrity,
		keepalive: e.keepalive,
		method: e.method,
		mode: e.mode,
		redirect: e.redirect,
		referrer: e.referrer,
		referrerPolicy: e.referrerPolicy
	};
}
var te = ni({
	tag: "seroval-plugins/web/Request",
	extends: [p, l],
	test(e) {
		return typeof Request == "undefined" ? !1 : e instanceof Request;
	},
	parse: {
		async async(e, r) {
			return {
				url: await r.parse(e.url),
				options: await r.parse(N(e, e.body && !e.bodyUsed ? await e.clone().arrayBuffer() : null))
			};
		},
		stream(e, r) {
			return {
				url: r.parse(e.url),
				options: r.parse(N(e, e.body && !e.bodyUsed ? e.clone().body : null))
			};
		}
	},
	serialize(e, r) {
		return "new Request(" + r.serialize(e.url) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Request(r.deserialize(e.url), r.deserialize(e.options));
	}
});
function h(e) {
	return {
		headers: e.headers,
		status: e.status,
		statusText: e.statusText
	};
}
var ne = ni({
	tag: "seroval-plugins/web/Response",
	extends: [p, l],
	test(e) {
		return typeof Response == "undefined" ? !1 : e instanceof Response;
	},
	parse: {
		async async(e, r) {
			return {
				body: await r.parse(e.body && !e.bodyUsed ? await e.clone().arrayBuffer() : null),
				options: await r.parse(h(e))
			};
		},
		stream(e, r) {
			return {
				body: r.parse(e.body && !e.bodyUsed ? e.clone().body : null),
				options: r.parse(h(e))
			};
		}
	},
	serialize(e, r) {
		return "new Response(" + r.serialize(e.body) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Response(r.deserialize(e.body), r.deserialize(e.options));
	}
});
var pe = ni({
	tag: "seroval-plugins/web/URL",
	test(e) {
		return typeof URL == "undefined" ? !1 : e instanceof URL;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(e.href) };
		},
		async async(e, r) {
			return { value: await r.parse(e.href) };
		},
		stream(e, r) {
			return { value: r.parse(e.href) };
		}
	},
	serialize(e, r) {
		return "new URL(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new URL(r.deserialize(e.value));
	}
});
var fe = ni({
	tag: "seroval-plugins/web/URLSearchParams",
	test(e) {
		return typeof URLSearchParams == "undefined" ? !1 : e instanceof URLSearchParams;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(e.toString()) };
		},
		async async(e, r) {
			return { value: await r.parse(e.toString()) };
		},
		stream(e, r) {
			return { value: r.parse(e.toString()) };
		}
	},
	serialize(e, r) {
		return "new URLSearchParams(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new URLSearchParams(r.deserialize(e.value));
	}
});

//#endregion
//#region node_modules/solid-js/web/dist/server.js
const booleans = [
	"allowfullscreen",
	"async",
	"alpha",
	"autofocus",
	"autoplay",
	"checked",
	"controls",
	"default",
	"disabled",
	"formnovalidate",
	"hidden",
	"indeterminate",
	"inert",
	"ismap",
	"loop",
	"multiple",
	"muted",
	"nomodule",
	"novalidate",
	"open",
	"playsinline",
	"readonly",
	"required",
	"reversed",
	"seamless",
	"selected",
	"adauctionheaders",
	"browsingtopics",
	"credentialless",
	"defaultchecked",
	"defaultmuted",
	"defaultselected",
	"defer",
	"disablepictureinpicture",
	"disableremoteplayback",
	"preservespitch",
	"shadowrootclonable",
	"shadowrootcustomelementregistry",
	"shadowrootdelegatesfocus",
	"shadowrootserializable",
	"sharedstoragewritable"
];
const BooleanAttributes = /* @__PURE__ */ new Set(booleans);
const Properties = /* @__PURE__ */ new Set([
	"className",
	"value",
	"readOnly",
	"noValidate",
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"adAuctionHeaders",
	"allowFullscreen",
	"browsingTopics",
	"defaultChecked",
	"defaultMuted",
	"defaultSelected",
	"disablePictureInPicture",
	"disableRemotePlayback",
	"preservesPitch",
	"shadowRootClonable",
	"shadowRootCustomElementRegistry",
	"shadowRootDelegatesFocus",
	"shadowRootSerializable",
	"sharedStorageWritable",
	...booleans
]);
const ChildProperties = /* @__PURE__ */ new Set([
	"innerHTML",
	"textContent",
	"innerText",
	"children"
]);
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
const ES2017FLAG = L$1.AggregateError | L$1.BigIntTypedArray;
const VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
function ssr(t, ...nodes) {
	if (nodes.length) {
		let result = "";
		for (let i$1 = 0; i$1 < nodes.length; i$1++) {
			result += t[i$1];
			const node = nodes[i$1];
			if (node !== void 0) result += resolveSSRNode(node);
		}
		t = result + t[nodes.length];
	}
	return { t };
}
function ssrClassList(value) {
	if (!value) return "";
	let classKeys = Object.keys(value), result = "";
	for (let i$1 = 0, len = classKeys.length; i$1 < len; i$1++) {
		const key = classKeys[i$1], classValue = !!value[key];
		if (!key || key === "undefined" || !classValue) continue;
		i$1 && (result += " ");
		result += escape(key);
	}
	return result;
}
function ssrStyle(value) {
	if (!value) return "";
	if (typeof value === "string") return escape(value, true);
	let result = "";
	const k = Object.keys(value);
	for (let i$1 = 0; i$1 < k.length; i$1++) {
		const s = k[i$1];
		const v$2 = value[s];
		if (v$2 != void 0) {
			if (i$1) result += ";";
			const r = escape(v$2, true);
			if (r != void 0 && r !== "undefined") result += \`\${s}:\${r}\`;
		}
	}
	return result;
}
function ssrStyleProperty(name, value) {
	return value != null ? name + value : "";
}
function ssrElement(tag, props, children$1, needsId) {
	if (props == null) props = {};
	else if (typeof props === "function") props = props();
	const skipChildren = VOID_ELEMENTS.test(tag);
	const keys = Object.keys(props);
	let result = \`<\${tag}\${needsId ? ssrHydrationKey() : ""} \`;
	let classResolved;
	for (let i$1 = 0; i$1 < keys.length; i$1++) {
		const prop = keys[i$1];
		if (ChildProperties.has(prop)) {
			if (children$1 === void 0 && !skipChildren) children$1 = tag === "script" || tag === "style" || prop === "innerHTML" ? props[prop] : escape(props[prop]);
			continue;
		}
		const value = props[prop];
		if (prop === "style") result += \`style="\${ssrStyle(value)}"\`;
		else if (prop === "class" || prop === "className" || prop === "classList") {
			if (classResolved) continue;
			let n$1;
			result += \`class="\${escape(((n$1 = props.class) ? n$1 + " " : "") + ((n$1 = props.className) ? n$1 + " " : ""), true) + ssrClassList(props.classList)}"\`;
			classResolved = true;
		} else if (BooleanAttributes.has(prop)) if (value) result += prop;
		else continue;
		else if (value == void 0 || prop === "ref" || prop.slice(0, 2) === "on" || prop.slice(0, 5) === "prop:") continue;
		else if (prop.slice(0, 5) === "bool:") {
			if (!value) continue;
			result += escape(prop.slice(5));
		} else if (prop.slice(0, 5) === "attr:") result += \`\${escape(prop.slice(5))}="\${escape(value, true)}"\`;
		else result += \`\${Aliases[prop] || escape(prop)}="\${escape(value, true)}"\`;
		if (i$1 !== keys.length - 1) result += " ";
	}
	if (skipChildren) return { t: result + "/>" };
	if (typeof children$1 === "function") children$1 = children$1();
	return { t: result + \`>\${resolveSSRNode(children$1, true)}</\${tag}>\` };
}
function ssrHydrationKey() {
	const hk = getHydrationKey();
	return hk ? \` data-hk="\${hk}"\` : "";
}
function escape(s, attr) {
	const t = typeof s;
	if (t !== "string") {
		if (!attr && t === "function") return escape(s());
		if (!attr && Array.isArray(s)) {
			s = s.slice();
			for (let i$1 = 0; i$1 < s.length; i$1++) s[i$1] = escape(s[i$1]);
			return s;
		}
		if (attr && t === "boolean") return String(s);
		return s;
	}
	const delim = attr ? "\\"" : "<";
	const escDelim = attr ? "&quot;" : "&lt;";
	let iDelim = s.indexOf(delim);
	let iAmp = s.indexOf("&");
	if (iDelim < 0 && iAmp < 0) return s;
	let left = 0, out = "";
	while (iDelim >= 0 && iAmp >= 0) if (iDelim < iAmp) {
		if (left < iDelim) out += s.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s.indexOf(delim, left);
	} else {
		if (left < iAmp) out += s.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s.indexOf("&", left);
	}
	if (iDelim >= 0) do {
		if (left < iDelim) out += s.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s.indexOf(delim, left);
	} while (iDelim >= 0);
	else while (iAmp >= 0) {
		if (left < iAmp) out += s.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s.indexOf("&", left);
	}
	return left < s.length ? out + s.substring(left) : out;
}
function resolveSSRNode(node, top) {
	const t = typeof node;
	if (t === "string") return node;
	if (node == null || t === "boolean") return "";
	if (Array.isArray(node)) {
		let prev = {};
		let mapped = "";
		for (let i$1 = 0, len = node.length; i$1 < len; i$1++) {
			if (!top && typeof prev !== "object" && typeof node[i$1] !== "object") mapped += \`<!--!$-->\`;
			mapped += resolveSSRNode(prev = node[i$1]);
		}
		return mapped;
	}
	if (t === "object") return node.t;
	if (t === "function") return resolveSSRNode(node());
	return String(node);
}
function getHydrationKey() {
	const hydrate = sharedConfig.context;
	return hydrate && !hydrate.noHydrate && sharedConfig.getNextContextId();
}

//#endregion
//#region tests/fixtures/templates.tsx
var _tmpl$ = "<svg width=\\"100\\" height=\\"100\\"><circle cx=\\"50\\" cy=\\"50\\" r=\\"40\\" fill=\\"red\\"></circle><foreignObject x=\\"10\\" y=\\"10\\" width=\\"80\\" height=\\"80\\"><div><p>HTML content inside SVG</p></div></foreignObject></svg>", _tmpl$2 = "<div><svg><g><rect x=\\"0\\" y=\\"0\\" width=\\"100\\" height=\\"100\\"></rect></g></svg></div>", _tmpl$3 = "<div><button>Click me</button><div>Hover me</div><input><form><select><option value=\\"1\\">Option 1</option><option value=\\"2\\">Option 2</option></select></form></div>", _tmpl$4 = [
	"<div class=\\"container\\"><h1>Title</h1>",
	"<ul>",
	"</ul><div style=\\"",
	"\\">Styled content</div></div>"
], _tmpl$5 = "<p>Conditional content</p>", _tmpl$6 = ["<li>", "</li>"], _tmpl$7 = "<div id=\\"test\\" class=\\"my-class\\" data-testid=\\"element\\" aria-label=\\"Accessible element\\" role=\\"button\\" tabindex=\\"0\\"><img src=\\"test.jpg\\" alt=\\"test image\\" width=\\"100\\" height=\\"100\\"><input type=\\"text\\" placeholder=\\"Enter text\\" required></div>", _tmpl$8 = "<svg width=\\"100\\" height=\\"100\\"><circle cx=\\"50\\" cy=\\"50\\" r=\\"40\\" fill=\\"red\\"></circle><rect x=\\"10\\" y=\\"10\\" width=\\"30\\" height=\\"30\\" fill=\\"blue\\"></rect><text x=\\"50\\" y=\\"50\\" text-anchor=\\"middle\\">SVG Text</text></svg>", _tmpl$9 = "<head><title>SSR Test</title><meta charset=\\"utf-8\\"><meta name=\\"viewport\\" content=\\"width=device-width\\"></head>", _tmpl$0 = "<div><script>console.log('test');<\\/script><style>body { margin: 0; }</style></div>", _tmpl$1 = [
	"<div><p>Static content</p><div>",
	"</div><ul>",
	"</ul></div>"
], _tmpl$10 = ["<li>Item ", "</li>"], _tmpl$11 = "<table><thead><tr><th>Header 1</th><th>Header 2</th></tr></thead><tbody><tr><td>Cell 1</td><td>Cell 2</td></tr></tbody></table>", _tmpl$12 = "<div><section><article><header><h1>Title</h1></header><main><p>Content</p></main><footer><small>Footer</small></footer></article></section><table><tr><td>Cell 1</td><td>Cell 2</td></tr></table><img src=\\"test.jpg\\" alt=\\"test\\"><br><hr></div>";
function TestSvgWrap() {
	return ssr(_tmpl$);
}
function TestNestedSvg() {
	return ssr(_tmpl$2);
}
function TestEventDelegation() {
	return ssr(_tmpl$3);
}
function TestComplexTemplates() {
	return ssr(_tmpl$4, _tmpl$5, escape([
		"a",
		"b",
		"c"
	].map((item) => ssr(_tmpl$6, escape(item)))), ssrStyleProperty("color:", "red") + ssrStyleProperty(";font-size:", "16px"));
}
function TestAttributeTemplates() {
	return ssr(_tmpl$7);
}
function TestSVGTemplates() {
	return ssr(_tmpl$8);
}
function TestSSRHeadElement() {
	return ssr(_tmpl$9);
}
function TestSSRScriptStyle() {
	return ssr(_tmpl$0);
}
function TestSSRHydration() {
	return ssr(_tmpl$1, \`Dynamic content: \${escape(Date.now())}\`, escape([
		1,
		2,
		3
	].map((item) => ssr(_tmpl$10, escape(item)))));
}
function TestSSRSpreadAttributes() {
	return ssrElement("div", {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	}, "Spread attributes", false);
}
function TestSSRSpecialElements() {
	return ssr(_tmpl$11);
}
function TestValidationScenarios() {
	return ssr(_tmpl$12);
}

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid src should transform templates with universal 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
	sharedConfig.context = context;
}
function nextHydrateContext() {
	return {
		...sharedConfig.context,
		id: sharedConfig.getNextContextId(),
		count: 0
	};
}
const equalFn = (a, b) => a === b;
const $PROXY = Symbol("solid-proxy");
const SUPPORTS_PROXY = typeof Proxy === "function";
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
	const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
		owned: null,
		cleanups: null,
		context: current ? current.context : null,
		owner: current
	}, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
	Owner = root;
	Listener = null;
	try {
		return runUpdates(updateFn, true);
	} finally {
		Listener = listener;
		Owner = owner;
	}
}
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function createMemo(fn, value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const c = createComputation(fn, value, true, 0);
	c.observers = null;
	c.observerSlots = null;
	c.comparator = options.equals || void 0;
	if (Scheduler && Transition && Transition.running) {
		c.tState = STALE;
		Updates.push(c);
	} else updateComputation(c);
	return readSignal.bind(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}
let hydrationEnabled = false;
function createComponent$1(Comp, props) {
	if (hydrationEnabled) {
		if (sharedConfig.context) {
			const c = sharedConfig.context;
			setHydrateContext(nextHydrateContext());
			const r = untrack(() => Comp(props || {}));
			setHydrateContext(c);
			return r;
		}
	}
	return untrack(() => Comp(props || {}));
}
function trueFn() {
	return true;
}
const propTraps = {
	get(_, property, receiver) {
		if (property === $PROXY) return receiver;
		return _.get(property);
	},
	has(_, property) {
		if (property === $PROXY) return true;
		return _.has(property);
	},
	set: trueFn,
	deleteProperty: trueFn,
	getOwnPropertyDescriptor(_, property) {
		return {
			configurable: true,
			enumerable: true,
			get() {
				return _.get(property);
			},
			set: trueFn,
			deleteProperty: trueFn
		};
	},
	ownKeys(_) {
		return _.keys();
	}
};
function resolveSource(s) {
	return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
	for (let i = 0, length = this.length; i < length; ++i) {
		const v = this[i]();
		if (v !== void 0) return v;
	}
}
function mergeProps$1(...sources) {
	let proxy = false;
	for (let i = 0; i < sources.length; i++) {
		const s = sources[i];
		proxy = proxy || !!s && $PROXY in s;
		sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
	}
	if (SUPPORTS_PROXY && proxy) return new Proxy({
		get(property) {
			for (let i = sources.length - 1; i >= 0; i--) {
				const v = resolveSource(sources[i])[property];
				if (v !== void 0) return v;
			}
		},
		has(property) {
			for (let i = sources.length - 1; i >= 0; i--) if (property in resolveSource(sources[i])) return true;
			return false;
		},
		keys() {
			const keys = [];
			for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));
			return [...new Set(keys)];
		}
	}, propTraps);
	const sourcesMap = {};
	const defined = Object.create(null);
	for (let i = sources.length - 1; i >= 0; i--) {
		const source = sources[i];
		if (!source) continue;
		const sourceKeys = Object.getOwnPropertyNames(source);
		for (let i$1 = sourceKeys.length - 1; i$1 >= 0; i$1--) {
			const key = sourceKeys[i$1];
			if (key === "__proto__" || key === "constructor") continue;
			const desc = Object.getOwnPropertyDescriptor(source, key);
			if (!defined[key]) defined[key] = desc.get ? {
				enumerable: true,
				configurable: true,
				get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
			} : desc.value !== void 0 ? desc : void 0;
			else {
				const sources$1 = sourcesMap[key];
				if (sources$1) {
					if (desc.get) sources$1.push(desc.get.bind(source));
					else if (desc.value !== void 0) sources$1.push(() => desc.value);
				}
			}
		}
	}
	const target = {};
	const definedKeys = Object.keys(defined);
	for (let i = definedKeys.length - 1; i >= 0; i--) {
		const key = definedKeys[i], desc = defined[key];
		if (desc && desc.get) Object.defineProperty(target, key, desc);
		else target[key] = desc ? desc.value : void 0;
	}
	return target;
}

//#endregion
//#region node_modules/solid-js/universal/dist/universal.js
const memo$1 = (fn) => createMemo(() => fn());
function createRenderer$1({ createElement: createElement$1, createTextNode: createTextNode$1, isTextNode, replaceText, insertNode: insertNode$1, removeNode, setProperty, getParentNode, getFirstChild, getNextSibling }) {
	function insert$1(parent, accessor, marker, initial) {
		if (marker !== void 0 && !initial) initial = [];
		if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
		createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
	}
	function insertExpression(parent, value, current, marker, unwrapArray) {
		while (typeof current === "function") current = current();
		if (value === current) return current;
		const t = typeof value, multi = marker !== void 0;
		if (t === "string" || t === "number") {
			if (t === "number") value = value.toString();
			if (multi) {
				let node = current[0];
				if (node && isTextNode(node)) replaceText(node, value);
				else node = createTextNode$1(value);
				current = cleanChildren(parent, current, marker, node);
			} else if (current !== "" && typeof current === "string") replaceText(getFirstChild(parent), current = value);
			else {
				cleanChildren(parent, current, marker, createTextNode$1(value));
				current = value;
			}
		} else if (value == null || t === "boolean") current = cleanChildren(parent, current, marker);
		else if (t === "function") {
			createRenderEffect(() => {
				let v = value();
				while (typeof v === "function") v = v();
				current = insertExpression(parent, v, current, marker);
			});
			return () => current;
		} else if (Array.isArray(value)) {
			const array = [];
			if (normalizeIncomingArray(array, value, unwrapArray)) {
				createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
				return () => current;
			}
			if (array.length === 0) {
				const replacement = cleanChildren(parent, current, marker);
				if (multi) return current = replacement;
			} else if (Array.isArray(current)) if (current.length === 0) appendNodes(parent, array, marker);
			else reconcileArrays(parent, current, array);
			else if (current == null || current === "") appendNodes(parent, array);
			else reconcileArrays(parent, multi && current || [getFirstChild(parent)], array);
			current = array;
		} else {
			if (Array.isArray(current)) {
				if (multi) return current = cleanChildren(parent, current, marker, value);
				cleanChildren(parent, current, null, value);
			} else if (current == null || current === "" || !getFirstChild(parent)) insertNode$1(parent, value);
			else replaceNode(parent, value, getFirstChild(parent));
			current = value;
		}
		return current;
	}
	function normalizeIncomingArray(normalized, array, unwrap) {
		let dynamic = false;
		for (let i = 0, len = array.length; i < len; i++) {
			let item = array[i], t;
			if (item == null || item === true || item === false);
			else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item) || dynamic;
			else if ((t = typeof item) === "string" || t === "number") normalized.push(createTextNode$1(item));
			else if (t === "function") if (unwrap) {
				while (typeof item === "function") item = item();
				dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;
			} else {
				normalized.push(item);
				dynamic = true;
			}
			else normalized.push(item);
		}
		return dynamic;
	}
	function reconcileArrays(parentNode, a, b) {
		let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = getNextSibling(a[aEnd - 1]), map = null;
		while (aStart < aEnd || bStart < bEnd) {
			if (a[aStart] === b[bStart]) {
				aStart++;
				bStart++;
				continue;
			}
			while (a[aEnd - 1] === b[bEnd - 1]) {
				aEnd--;
				bEnd--;
			}
			if (aEnd === aStart) {
				const node = bEnd < bLength ? bStart ? getNextSibling(b[bStart - 1]) : b[bEnd - bStart] : after;
				while (bStart < bEnd) insertNode$1(parentNode, b[bStart++], node);
			} else if (bEnd === bStart) while (aStart < aEnd) {
				if (!map || !map.has(a[aStart])) removeNode(parentNode, a[aStart]);
				aStart++;
			}
			else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
				const node = getNextSibling(a[--aEnd]);
				insertNode$1(parentNode, b[bStart++], getNextSibling(a[aStart++]));
				insertNode$1(parentNode, b[--bEnd], node);
				a[aEnd] = b[bEnd];
			} else {
				if (!map) {
					map = /* @__PURE__ */ new Map();
					let i = bStart;
					while (i < bEnd) map.set(b[i], i++);
				}
				const index = map.get(a[aStart]);
				if (index != null) if (bStart < index && index < bEnd) {
					let i = aStart, sequence = 1, t;
					while (++i < aEnd && i < bEnd) {
						if ((t = map.get(a[i])) == null || t !== index + sequence) break;
						sequence++;
					}
					if (sequence > index - bStart) {
						const node = a[aStart];
						while (bStart < index) insertNode$1(parentNode, b[bStart++], node);
					} else replaceNode(parentNode, b[bStart++], a[aStart++]);
				} else aStart++;
				else removeNode(parentNode, a[aStart++]);
			}
		}
	}
	function cleanChildren(parent, current, marker, replacement) {
		if (marker === void 0) {
			let removed;
			while (removed = getFirstChild(parent)) removeNode(parent, removed);
			replacement && insertNode$1(parent, replacement);
			return "";
		}
		const node = replacement || createTextNode$1("");
		if (current.length) {
			let inserted = false;
			for (let i = current.length - 1; i >= 0; i--) {
				const el = current[i];
				if (node !== el) {
					const isParent = getParentNode(el) === parent;
					if (!inserted && !i) isParent ? replaceNode(parent, node, el) : insertNode$1(parent, node, marker);
					else isParent && removeNode(parent, el);
				} else inserted = true;
			}
		} else insertNode$1(parent, node, marker);
		return [node];
	}
	function appendNodes(parent, array, marker) {
		for (let i = 0, len = array.length; i < len; i++) insertNode$1(parent, array[i], marker);
	}
	function replaceNode(parent, newNode, oldNode) {
		insertNode$1(parent, newNode, oldNode);
		removeNode(parent, oldNode);
	}
	function spreadExpression(node, props, prevProps = {}, skipChildren) {
		props || (props = {});
		if (!skipChildren) createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
		createRenderEffect(() => props.ref && props.ref(node));
		createRenderEffect(() => {
			for (const prop in props) {
				if (prop === "children" || prop === "ref") continue;
				const value = props[prop];
				if (value === prevProps[prop]) continue;
				setProperty(node, prop, value, prevProps[prop]);
				prevProps[prop] = value;
			}
		});
		return prevProps;
	}
	return {
		render(code, element) {
			let disposer;
			createRoot((dispose) => {
				disposer = dispose;
				insert$1(element, code());
			});
			return disposer;
		},
		insert: insert$1,
		spread(node, accessor, skipChildren) {
			if (typeof accessor === "function") createRenderEffect((current) => spreadExpression(node, accessor(), current, skipChildren));
			else spreadExpression(node, accessor, void 0, skipChildren);
		},
		createElement: createElement$1,
		createTextNode: createTextNode$1,
		insertNode: insertNode$1,
		setProp(node, name, value, prev) {
			setProperty(node, name, value, prev);
			return value;
		},
		mergeProps: mergeProps$1,
		effect: createRenderEffect,
		memo: memo$1,
		createComponent: createComponent$1,
		use(fn, element, arg) {
			return untrack(() => fn(element, arg));
		}
	};
}
function createRenderer(options) {
	const renderer = createRenderer$1(options);
	renderer.mergeProps = mergeProps$1;
	return renderer;
}

//#endregion
//#region tests/helpers/universal-mode-renderer.ts
const { createComponent, createElement, createTextNode, effect, insert, insertNode, memo, mergeProps, render, setProp, spread, use } = createRenderer({
	createElement() {},
	createTextNode() {},
	getFirstChild() {},
	getNextSibling() {},
	getParentNode() {},
	insertNode() {},
	isTextNode() {
		return true;
	},
	removeNode() {},
	replaceText() {},
	setProperty() {}
});

//#endregion
//#region tests/fixtures/templates.tsx
function TestSvgWrap() {
	return (() => {
		var _el$ = createElement("svg"), _el$2 = createElement("circle"), _el$3 = createElement("foreignObject"), _el$4 = createElement("div"), _el$5 = createElement("p");
		insertNode(_el$, _el$2);
		insertNode(_el$, _el$3);
		setProp(_el$, "width", "100");
		setProp(_el$, "height", "100");
		setProp(_el$2, "cx", "50");
		setProp(_el$2, "cy", "50");
		setProp(_el$2, "r", "40");
		setProp(_el$2, "fill", "red");
		insertNode(_el$3, _el$4);
		setProp(_el$3, "x", "10");
		setProp(_el$3, "y", "10");
		setProp(_el$3, "width", "80");
		setProp(_el$3, "height", "80");
		insertNode(_el$4, _el$5);
		insertNode(_el$5, createTextNode(\`HTML content inside SVG\`));
		return _el$;
	})();
}
function TestNestedSvg() {
	return (() => {
		var _el$7 = createElement("div"), _el$8 = createElement("svg"), _el$9 = createElement("g"), _el$0 = createElement("rect");
		insertNode(_el$7, _el$8);
		insertNode(_el$8, _el$9);
		insertNode(_el$9, _el$0);
		setProp(_el$0, "x", "0");
		setProp(_el$0, "y", "0");
		setProp(_el$0, "width", "100");
		setProp(_el$0, "height", "100");
		return _el$7;
	})();
}
function TestEventDelegation() {
	return (() => {
		var _el$1 = createElement("div"), _el$10 = createElement("button"), _el$12 = createElement("div"), _el$14 = createElement("input"), _el$15 = createElement("form"), _el$16 = createElement("select"), _el$17 = createElement("option"), _el$19 = createElement("option");
		insertNode(_el$1, _el$10);
		insertNode(_el$1, _el$12);
		insertNode(_el$1, _el$14);
		insertNode(_el$1, _el$15);
		insertNode(_el$10, createTextNode(\`Click me\`));
		setProp(_el$10, "onClick", () => console.log("click"));
		insertNode(_el$12, createTextNode(\`Hover me\`));
		setProp(_el$12, "onMouseOver", () => console.log("hover"));
		setProp(_el$14, "onInput", (e) => console.log(e.target.value));
		insertNode(_el$15, _el$16);
		setProp(_el$15, "onSubmit", (e) => e.preventDefault());
		insertNode(_el$16, _el$17);
		insertNode(_el$16, _el$19);
		setProp(_el$16, "onChange", (e) => console.log(e.target.value));
		insertNode(_el$17, createTextNode(\`Option 1\`));
		setProp(_el$17, "value", "1");
		insertNode(_el$19, createTextNode(\`Option 2\`));
		setProp(_el$19, "value", "2");
		return _el$1;
	})();
}
function TestComplexTemplates() {
	const items = [
		"a",
		"b",
		"c"
	];
	return (() => {
		var _el$21 = createElement("div"), _el$22 = createElement("h1"), _el$24 = createElement("ul"), _el$25 = createElement("div");
		insertNode(_el$21, _el$22);
		insertNode(_el$21, _el$24);
		insertNode(_el$21, _el$25);
		setProp(_el$21, "class", "container");
		insertNode(_el$22, createTextNode(\`Title\`));
		insert(_el$21, (() => {
			var _el$27 = createElement("p");
			insertNode(_el$27, createTextNode(\`Conditional content\`));
			return _el$27;
		})(), _el$24);
		insert(_el$24, () => items.map((item) => (() => {
			var _el$29 = createElement("li");
			insert(_el$29, item);
			return _el$29;
		})()));
		insertNode(_el$25, createTextNode(\`Styled content\`));
		setProp(_el$25, "style", {
			color: "red",
			"font-size": "16px"
		});
		return _el$21;
	})();
}
function TestAttributeTemplates() {
	return (() => {
		var _el$30 = createElement("div"), _el$31 = createElement("img"), _el$32 = createElement("input");
		insertNode(_el$30, _el$31);
		insertNode(_el$30, _el$32);
		setProp(_el$30, "id", "test");
		setProp(_el$30, "class", "my-class");
		setProp(_el$30, "data-testid", "element");
		setProp(_el$30, "aria-label", "Accessible element");
		setProp(_el$30, "role", "button");
		setProp(_el$30, "tabIndex", 0);
		setProp(_el$31, "src", "test.jpg");
		setProp(_el$31, "alt", "test image");
		setProp(_el$31, "width", "100");
		setProp(_el$31, "height", "100");
		setProp(_el$32, "type", "text");
		setProp(_el$32, "placeholder", "Enter text");
		setProp(_el$32, "required", true);
		setProp(_el$32, "disabled", false);
		return _el$30;
	})();
}
function TestSVGTemplates() {
	return (() => {
		var _el$33 = createElement("svg"), _el$34 = createElement("circle"), _el$35 = createElement("rect"), _el$36 = createElement("text");
		insertNode(_el$33, _el$34);
		insertNode(_el$33, _el$35);
		insertNode(_el$33, _el$36);
		setProp(_el$33, "width", "100");
		setProp(_el$33, "height", "100");
		setProp(_el$34, "cx", "50");
		setProp(_el$34, "cy", "50");
		setProp(_el$34, "r", "40");
		setProp(_el$34, "fill", "red");
		setProp(_el$35, "x", "10");
		setProp(_el$35, "y", "10");
		setProp(_el$35, "width", "30");
		setProp(_el$35, "height", "30");
		setProp(_el$35, "fill", "blue");
		insertNode(_el$36, createTextNode(\`SVG Text\`));
		setProp(_el$36, "x", "50");
		setProp(_el$36, "y", "50");
		setProp(_el$36, "text-anchor", "middle");
		return _el$33;
	})();
}
function TestSSRHeadElement() {
	return (() => {
		var _el$38 = createElement("head"), _el$39 = createElement("title"), _el$41 = createElement("meta"), _el$42 = createElement("meta");
		insertNode(_el$38, _el$39);
		insertNode(_el$38, _el$41);
		insertNode(_el$38, _el$42);
		insertNode(_el$39, createTextNode(\`SSR Test\`));
		setProp(_el$41, "charset", "utf-8");
		setProp(_el$42, "name", "viewport");
		setProp(_el$42, "content", "width=device-width");
		return _el$38;
	})();
}
function TestSSRScriptStyle() {
	return (() => {
		var _el$43 = createElement("div"), _el$44 = createElement("script"), _el$46 = createElement("style");
		insertNode(_el$43, _el$44);
		insertNode(_el$43, _el$46);
		insertNode(_el$44, createTextNode(\`console.log('test');\`));
		insertNode(_el$46, createTextNode(\`body \\{ margin: 0; }\`));
		return _el$43;
	})();
}
function TestSSRHydration() {
	return (() => {
		var _el$48 = createElement("div"), _el$49 = createElement("p"), _el$51 = createElement("div"), _el$52 = createElement("ul");
		insertNode(_el$48, _el$49);
		insertNode(_el$48, _el$51);
		insertNode(_el$48, _el$52);
		insertNode(_el$49, createTextNode(\`Static content\`));
		insert(_el$51, () => \`Dynamic content: \${Date.now()}\`);
		insert(_el$52, () => [
			1,
			2,
			3
		].map((item) => (() => {
			var _el$53 = createElement("li");
			insertNode(_el$53, createTextNode(\`Item \`));
			insert(_el$53, item, null);
			return _el$53;
		})()));
		return _el$48;
	})();
}
function TestSSRSpreadAttributes() {
	const props = {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	};
	return (() => {
		var _el$55 = createElement("div");
		insertNode(_el$55, createTextNode(\`Spread attributes\`));
		spread(_el$55, props, true);
		return _el$55;
	})();
}
function TestSSRSpecialElements() {
	return (() => {
		var _el$57 = createElement("table"), _el$58 = createElement("thead"), _el$59 = createElement("tr"), _el$60 = createElement("th"), _el$62 = createElement("th"), _el$64 = createElement("tbody"), _el$65 = createElement("tr"), _el$66 = createElement("td"), _el$68 = createElement("td");
		insertNode(_el$57, _el$58);
		insertNode(_el$57, _el$64);
		insertNode(_el$58, _el$59);
		insertNode(_el$59, _el$60);
		insertNode(_el$59, _el$62);
		insertNode(_el$60, createTextNode(\`Header 1\`));
		insertNode(_el$62, createTextNode(\`Header 2\`));
		insertNode(_el$64, _el$65);
		insertNode(_el$65, _el$66);
		insertNode(_el$65, _el$68);
		insertNode(_el$66, createTextNode(\`Cell 1\`));
		insertNode(_el$68, createTextNode(\`Cell 2\`));
		return _el$57;
	})();
}
function TestValidationScenarios() {
	return (() => {
		var _el$70 = createElement("div"), _el$71 = createElement("section"), _el$72 = createElement("article"), _el$73 = createElement("header"), _el$74 = createElement("h1"), _el$76 = createElement("main"), _el$77 = createElement("p"), _el$79 = createElement("footer"), _el$80 = createElement("small"), _el$82 = createElement("table"), _el$83 = createElement("tr"), _el$84 = createElement("td"), _el$86 = createElement("td"), _el$88 = createElement("img"), _el$89 = createElement("br"), _el$90 = createElement("hr");
		insertNode(_el$70, _el$71);
		insertNode(_el$70, _el$82);
		insertNode(_el$70, _el$88);
		insertNode(_el$70, _el$89);
		insertNode(_el$70, _el$90);
		insertNode(_el$71, _el$72);
		insertNode(_el$72, _el$73);
		insertNode(_el$72, _el$76);
		insertNode(_el$72, _el$79);
		insertNode(_el$73, _el$74);
		insertNode(_el$74, createTextNode(\`Title\`));
		insertNode(_el$76, _el$77);
		insertNode(_el$77, createTextNode(\`Content\`));
		insertNode(_el$79, _el$80);
		insertNode(_el$80, createTextNode(\`Footer\`));
		insertNode(_el$82, _el$83);
		insertNode(_el$83, _el$84);
		insertNode(_el$83, _el$86);
		insertNode(_el$84, createTextNode(\`Cell 1\`));
		insertNode(_el$86, createTextNode(\`Cell 2\`));
		setProp(_el$88, "src", "test.jpg");
		setProp(_el$88, "alt", "test");
		return _el$70;
	})();
}

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid dist should transform templates with universal 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
	sharedConfig.context = context;
}
function nextHydrateContext() {
	return {
		...sharedConfig.context,
		id: sharedConfig.getNextContextId(),
		count: 0
	};
}
const equalFn = (a, b) => a === b;
const $PROXY = Symbol("solid-proxy");
const SUPPORTS_PROXY = typeof Proxy === "function";
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
	const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
		owned: null,
		cleanups: null,
		context: current ? current.context : null,
		owner: current
	}, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
	Owner = root;
	Listener = null;
	try {
		return runUpdates(updateFn, true);
	} finally {
		Listener = listener;
		Owner = owner;
	}
}
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function createMemo(fn, value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const c = createComputation(fn, value, true, 0);
	c.observers = null;
	c.observerSlots = null;
	c.comparator = options.equals || void 0;
	if (Scheduler && Transition && Transition.running) {
		c.tState = STALE;
		Updates.push(c);
	} else updateComputation(c);
	return readSignal.bind(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}
let hydrationEnabled = false;
function createComponent$1(Comp, props) {
	if (hydrationEnabled) {
		if (sharedConfig.context) {
			const c = sharedConfig.context;
			setHydrateContext(nextHydrateContext());
			const r = untrack(() => Comp(props || {}));
			setHydrateContext(c);
			return r;
		}
	}
	return untrack(() => Comp(props || {}));
}
function trueFn() {
	return true;
}
const propTraps = {
	get(_, property, receiver) {
		if (property === $PROXY) return receiver;
		return _.get(property);
	},
	has(_, property) {
		if (property === $PROXY) return true;
		return _.has(property);
	},
	set: trueFn,
	deleteProperty: trueFn,
	getOwnPropertyDescriptor(_, property) {
		return {
			configurable: true,
			enumerable: true,
			get() {
				return _.get(property);
			},
			set: trueFn,
			deleteProperty: trueFn
		};
	},
	ownKeys(_) {
		return _.keys();
	}
};
function resolveSource(s) {
	return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
	for (let i = 0, length = this.length; i < length; ++i) {
		const v = this[i]();
		if (v !== void 0) return v;
	}
}
function mergeProps$1(...sources) {
	let proxy = false;
	for (let i = 0; i < sources.length; i++) {
		const s = sources[i];
		proxy = proxy || !!s && $PROXY in s;
		sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
	}
	if (SUPPORTS_PROXY && proxy) return new Proxy({
		get(property) {
			for (let i = sources.length - 1; i >= 0; i--) {
				const v = resolveSource(sources[i])[property];
				if (v !== void 0) return v;
			}
		},
		has(property) {
			for (let i = sources.length - 1; i >= 0; i--) if (property in resolveSource(sources[i])) return true;
			return false;
		},
		keys() {
			const keys = [];
			for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));
			return [...new Set(keys)];
		}
	}, propTraps);
	const sourcesMap = {};
	const defined = Object.create(null);
	for (let i = sources.length - 1; i >= 0; i--) {
		const source = sources[i];
		if (!source) continue;
		const sourceKeys = Object.getOwnPropertyNames(source);
		for (let i$1 = sourceKeys.length - 1; i$1 >= 0; i$1--) {
			const key = sourceKeys[i$1];
			if (key === "__proto__" || key === "constructor") continue;
			const desc = Object.getOwnPropertyDescriptor(source, key);
			if (!defined[key]) defined[key] = desc.get ? {
				enumerable: true,
				configurable: true,
				get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
			} : desc.value !== void 0 ? desc : void 0;
			else {
				const sources$1 = sourcesMap[key];
				if (sources$1) {
					if (desc.get) sources$1.push(desc.get.bind(source));
					else if (desc.value !== void 0) sources$1.push(() => desc.value);
				}
			}
		}
	}
	const target = {};
	const definedKeys = Object.keys(defined);
	for (let i = definedKeys.length - 1; i >= 0; i--) {
		const key = definedKeys[i], desc = defined[key];
		if (desc && desc.get) Object.defineProperty(target, key, desc);
		else target[key] = desc ? desc.value : void 0;
	}
	return target;
}

//#endregion
//#region node_modules/solid-js/universal/dist/universal.js
const memo$1 = (fn) => createMemo(() => fn());
function createRenderer$1({ createElement: createElement$1, createTextNode: createTextNode$1, isTextNode, replaceText, insertNode: insertNode$1, removeNode, setProperty, getParentNode, getFirstChild, getNextSibling }) {
	function insert$1(parent, accessor, marker, initial) {
		if (marker !== void 0 && !initial) initial = [];
		if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
		createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
	}
	function insertExpression(parent, value, current, marker, unwrapArray) {
		while (typeof current === "function") current = current();
		if (value === current) return current;
		const t = typeof value, multi = marker !== void 0;
		if (t === "string" || t === "number") {
			if (t === "number") value = value.toString();
			if (multi) {
				let node = current[0];
				if (node && isTextNode(node)) replaceText(node, value);
				else node = createTextNode$1(value);
				current = cleanChildren(parent, current, marker, node);
			} else if (current !== "" && typeof current === "string") replaceText(getFirstChild(parent), current = value);
			else {
				cleanChildren(parent, current, marker, createTextNode$1(value));
				current = value;
			}
		} else if (value == null || t === "boolean") current = cleanChildren(parent, current, marker);
		else if (t === "function") {
			createRenderEffect(() => {
				let v = value();
				while (typeof v === "function") v = v();
				current = insertExpression(parent, v, current, marker);
			});
			return () => current;
		} else if (Array.isArray(value)) {
			const array = [];
			if (normalizeIncomingArray(array, value, unwrapArray)) {
				createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
				return () => current;
			}
			if (array.length === 0) {
				const replacement = cleanChildren(parent, current, marker);
				if (multi) return current = replacement;
			} else if (Array.isArray(current)) if (current.length === 0) appendNodes(parent, array, marker);
			else reconcileArrays(parent, current, array);
			else if (current == null || current === "") appendNodes(parent, array);
			else reconcileArrays(parent, multi && current || [getFirstChild(parent)], array);
			current = array;
		} else {
			if (Array.isArray(current)) {
				if (multi) return current = cleanChildren(parent, current, marker, value);
				cleanChildren(parent, current, null, value);
			} else if (current == null || current === "" || !getFirstChild(parent)) insertNode$1(parent, value);
			else replaceNode(parent, value, getFirstChild(parent));
			current = value;
		}
		return current;
	}
	function normalizeIncomingArray(normalized, array, unwrap) {
		let dynamic = false;
		for (let i = 0, len = array.length; i < len; i++) {
			let item = array[i], t;
			if (item == null || item === true || item === false);
			else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item) || dynamic;
			else if ((t = typeof item) === "string" || t === "number") normalized.push(createTextNode$1(item));
			else if (t === "function") if (unwrap) {
				while (typeof item === "function") item = item();
				dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;
			} else {
				normalized.push(item);
				dynamic = true;
			}
			else normalized.push(item);
		}
		return dynamic;
	}
	function reconcileArrays(parentNode, a, b) {
		let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = getNextSibling(a[aEnd - 1]), map = null;
		while (aStart < aEnd || bStart < bEnd) {
			if (a[aStart] === b[bStart]) {
				aStart++;
				bStart++;
				continue;
			}
			while (a[aEnd - 1] === b[bEnd - 1]) {
				aEnd--;
				bEnd--;
			}
			if (aEnd === aStart) {
				const node = bEnd < bLength ? bStart ? getNextSibling(b[bStart - 1]) : b[bEnd - bStart] : after;
				while (bStart < bEnd) insertNode$1(parentNode, b[bStart++], node);
			} else if (bEnd === bStart) while (aStart < aEnd) {
				if (!map || !map.has(a[aStart])) removeNode(parentNode, a[aStart]);
				aStart++;
			}
			else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
				const node = getNextSibling(a[--aEnd]);
				insertNode$1(parentNode, b[bStart++], getNextSibling(a[aStart++]));
				insertNode$1(parentNode, b[--bEnd], node);
				a[aEnd] = b[bEnd];
			} else {
				if (!map) {
					map = /* @__PURE__ */ new Map();
					let i = bStart;
					while (i < bEnd) map.set(b[i], i++);
				}
				const index = map.get(a[aStart]);
				if (index != null) if (bStart < index && index < bEnd) {
					let i = aStart, sequence = 1, t;
					while (++i < aEnd && i < bEnd) {
						if ((t = map.get(a[i])) == null || t !== index + sequence) break;
						sequence++;
					}
					if (sequence > index - bStart) {
						const node = a[aStart];
						while (bStart < index) insertNode$1(parentNode, b[bStart++], node);
					} else replaceNode(parentNode, b[bStart++], a[aStart++]);
				} else aStart++;
				else removeNode(parentNode, a[aStart++]);
			}
		}
	}
	function cleanChildren(parent, current, marker, replacement) {
		if (marker === void 0) {
			let removed;
			while (removed = getFirstChild(parent)) removeNode(parent, removed);
			replacement && insertNode$1(parent, replacement);
			return "";
		}
		const node = replacement || createTextNode$1("");
		if (current.length) {
			let inserted = false;
			for (let i = current.length - 1; i >= 0; i--) {
				const el = current[i];
				if (node !== el) {
					const isParent = getParentNode(el) === parent;
					if (!inserted && !i) isParent ? replaceNode(parent, node, el) : insertNode$1(parent, node, marker);
					else isParent && removeNode(parent, el);
				} else inserted = true;
			}
		} else insertNode$1(parent, node, marker);
		return [node];
	}
	function appendNodes(parent, array, marker) {
		for (let i = 0, len = array.length; i < len; i++) insertNode$1(parent, array[i], marker);
	}
	function replaceNode(parent, newNode, oldNode) {
		insertNode$1(parent, newNode, oldNode);
		removeNode(parent, oldNode);
	}
	function spreadExpression(node, props, prevProps = {}, skipChildren) {
		props || (props = {});
		if (!skipChildren) createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
		createRenderEffect(() => props.ref && props.ref(node));
		createRenderEffect(() => {
			for (const prop in props) {
				if (prop === "children" || prop === "ref") continue;
				const value = props[prop];
				if (value === prevProps[prop]) continue;
				setProperty(node, prop, value, prevProps[prop]);
				prevProps[prop] = value;
			}
		});
		return prevProps;
	}
	return {
		render(code, element) {
			let disposer;
			createRoot((dispose) => {
				disposer = dispose;
				insert$1(element, code());
			});
			return disposer;
		},
		insert: insert$1,
		spread(node, accessor, skipChildren) {
			if (typeof accessor === "function") createRenderEffect((current) => spreadExpression(node, accessor(), current, skipChildren));
			else spreadExpression(node, accessor, void 0, skipChildren);
		},
		createElement: createElement$1,
		createTextNode: createTextNode$1,
		insertNode: insertNode$1,
		setProp(node, name, value, prev) {
			setProperty(node, name, value, prev);
			return value;
		},
		mergeProps: mergeProps$1,
		effect: createRenderEffect,
		memo: memo$1,
		createComponent: createComponent$1,
		use(fn, element, arg) {
			return untrack(() => fn(element, arg));
		}
	};
}
function createRenderer(options) {
	const renderer = createRenderer$1(options);
	renderer.mergeProps = mergeProps$1;
	return renderer;
}

//#endregion
//#region tests/helpers/universal-mode-renderer.ts
const { createComponent, createElement, createTextNode, effect, insert, insertNode, memo, mergeProps, render, setProp, spread, use } = createRenderer({
	createElement() {},
	createTextNode() {},
	getFirstChild() {},
	getNextSibling() {},
	getParentNode() {},
	insertNode() {},
	isTextNode() {
		return true;
	},
	removeNode() {},
	replaceText() {},
	setProperty() {}
});

//#endregion
//#region tests/fixtures/templates.tsx
function TestSvgWrap() {
	return (() => {
		var _el$ = createElement("svg"), _el$2 = createElement("circle"), _el$3 = createElement("foreignObject"), _el$4 = createElement("div"), _el$5 = createElement("p");
		insertNode(_el$, _el$2);
		insertNode(_el$, _el$3);
		setProp(_el$, "width", "100");
		setProp(_el$, "height", "100");
		setProp(_el$2, "cx", "50");
		setProp(_el$2, "cy", "50");
		setProp(_el$2, "r", "40");
		setProp(_el$2, "fill", "red");
		insertNode(_el$3, _el$4);
		setProp(_el$3, "x", "10");
		setProp(_el$3, "y", "10");
		setProp(_el$3, "width", "80");
		setProp(_el$3, "height", "80");
		insertNode(_el$4, _el$5);
		insertNode(_el$5, createTextNode(\`HTML content inside SVG\`));
		return _el$;
	})();
}
function TestNestedSvg() {
	return (() => {
		var _el$7 = createElement("div"), _el$8 = createElement("svg"), _el$9 = createElement("g"), _el$0 = createElement("rect");
		insertNode(_el$7, _el$8);
		insertNode(_el$8, _el$9);
		insertNode(_el$9, _el$0);
		setProp(_el$0, "x", "0");
		setProp(_el$0, "y", "0");
		setProp(_el$0, "width", "100");
		setProp(_el$0, "height", "100");
		return _el$7;
	})();
}
function TestEventDelegation() {
	return (() => {
		var _el$1 = createElement("div"), _el$10 = createElement("button"), _el$12 = createElement("div"), _el$14 = createElement("input"), _el$15 = createElement("form"), _el$16 = createElement("select"), _el$17 = createElement("option"), _el$19 = createElement("option");
		insertNode(_el$1, _el$10);
		insertNode(_el$1, _el$12);
		insertNode(_el$1, _el$14);
		insertNode(_el$1, _el$15);
		insertNode(_el$10, createTextNode(\`Click me\`));
		setProp(_el$10, "onClick", () => console.log("click"));
		insertNode(_el$12, createTextNode(\`Hover me\`));
		setProp(_el$12, "onMouseOver", () => console.log("hover"));
		setProp(_el$14, "onInput", (e) => console.log(e.target.value));
		insertNode(_el$15, _el$16);
		setProp(_el$15, "onSubmit", (e) => e.preventDefault());
		insertNode(_el$16, _el$17);
		insertNode(_el$16, _el$19);
		setProp(_el$16, "onChange", (e) => console.log(e.target.value));
		insertNode(_el$17, createTextNode(\`Option 1\`));
		setProp(_el$17, "value", "1");
		insertNode(_el$19, createTextNode(\`Option 2\`));
		setProp(_el$19, "value", "2");
		return _el$1;
	})();
}
function TestComplexTemplates() {
	const items = [
		"a",
		"b",
		"c"
	];
	return (() => {
		var _el$21 = createElement("div"), _el$22 = createElement("h1"), _el$24 = createElement("ul"), _el$25 = createElement("div");
		insertNode(_el$21, _el$22);
		insertNode(_el$21, _el$24);
		insertNode(_el$21, _el$25);
		setProp(_el$21, "class", "container");
		insertNode(_el$22, createTextNode(\`Title\`));
		insert(_el$21, (() => {
			var _el$27 = createElement("p");
			insertNode(_el$27, createTextNode(\`Conditional content\`));
			return _el$27;
		})(), _el$24);
		insert(_el$24, () => items.map((item) => (() => {
			var _el$29 = createElement("li");
			insert(_el$29, item);
			return _el$29;
		})()));
		insertNode(_el$25, createTextNode(\`Styled content\`));
		setProp(_el$25, "style", {
			color: "red",
			"font-size": "16px"
		});
		return _el$21;
	})();
}
function TestAttributeTemplates() {
	return (() => {
		var _el$30 = createElement("div"), _el$31 = createElement("img"), _el$32 = createElement("input");
		insertNode(_el$30, _el$31);
		insertNode(_el$30, _el$32);
		setProp(_el$30, "id", "test");
		setProp(_el$30, "class", "my-class");
		setProp(_el$30, "data-testid", "element");
		setProp(_el$30, "aria-label", "Accessible element");
		setProp(_el$30, "role", "button");
		setProp(_el$30, "tabIndex", 0);
		setProp(_el$31, "src", "test.jpg");
		setProp(_el$31, "alt", "test image");
		setProp(_el$31, "width", "100");
		setProp(_el$31, "height", "100");
		setProp(_el$32, "type", "text");
		setProp(_el$32, "placeholder", "Enter text");
		setProp(_el$32, "required", true);
		setProp(_el$32, "disabled", false);
		return _el$30;
	})();
}
function TestSVGTemplates() {
	return (() => {
		var _el$33 = createElement("svg"), _el$34 = createElement("circle"), _el$35 = createElement("rect"), _el$36 = createElement("text");
		insertNode(_el$33, _el$34);
		insertNode(_el$33, _el$35);
		insertNode(_el$33, _el$36);
		setProp(_el$33, "width", "100");
		setProp(_el$33, "height", "100");
		setProp(_el$34, "cx", "50");
		setProp(_el$34, "cy", "50");
		setProp(_el$34, "r", "40");
		setProp(_el$34, "fill", "red");
		setProp(_el$35, "x", "10");
		setProp(_el$35, "y", "10");
		setProp(_el$35, "width", "30");
		setProp(_el$35, "height", "30");
		setProp(_el$35, "fill", "blue");
		insertNode(_el$36, createTextNode(\`SVG Text\`));
		setProp(_el$36, "x", "50");
		setProp(_el$36, "y", "50");
		setProp(_el$36, "text-anchor", "middle");
		return _el$33;
	})();
}
function TestSSRHeadElement() {
	return (() => {
		var _el$38 = createElement("head"), _el$39 = createElement("title"), _el$41 = createElement("meta"), _el$42 = createElement("meta");
		insertNode(_el$38, _el$39);
		insertNode(_el$38, _el$41);
		insertNode(_el$38, _el$42);
		insertNode(_el$39, createTextNode(\`SSR Test\`));
		setProp(_el$41, "charset", "utf-8");
		setProp(_el$42, "name", "viewport");
		setProp(_el$42, "content", "width=device-width");
		return _el$38;
	})();
}
function TestSSRScriptStyle() {
	return (() => {
		var _el$43 = createElement("div"), _el$44 = createElement("script"), _el$46 = createElement("style");
		insertNode(_el$43, _el$44);
		insertNode(_el$43, _el$46);
		insertNode(_el$44, createTextNode(\`console.log('test');\`));
		insertNode(_el$46, createTextNode(\`body \\{ margin: 0; }\`));
		return _el$43;
	})();
}
function TestSSRHydration() {
	return (() => {
		var _el$48 = createElement("div"), _el$49 = createElement("p"), _el$51 = createElement("div"), _el$52 = createElement("ul");
		insertNode(_el$48, _el$49);
		insertNode(_el$48, _el$51);
		insertNode(_el$48, _el$52);
		insertNode(_el$49, createTextNode(\`Static content\`));
		insert(_el$51, () => \`Dynamic content: \${Date.now()}\`);
		insert(_el$52, () => [
			1,
			2,
			3
		].map((item) => (() => {
			var _el$53 = createElement("li");
			insertNode(_el$53, createTextNode(\`Item \`));
			insert(_el$53, item, null);
			return _el$53;
		})()));
		return _el$48;
	})();
}
function TestSSRSpreadAttributes() {
	const props = {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	};
	return (() => {
		var _el$55 = createElement("div");
		insertNode(_el$55, createTextNode(\`Spread attributes\`));
		spread(_el$55, props, true);
		return _el$55;
	})();
}
function TestSSRSpecialElements() {
	return (() => {
		var _el$57 = createElement("table"), _el$58 = createElement("thead"), _el$59 = createElement("tr"), _el$60 = createElement("th"), _el$62 = createElement("th"), _el$64 = createElement("tbody"), _el$65 = createElement("tr"), _el$66 = createElement("td"), _el$68 = createElement("td");
		insertNode(_el$57, _el$58);
		insertNode(_el$57, _el$64);
		insertNode(_el$58, _el$59);
		insertNode(_el$59, _el$60);
		insertNode(_el$59, _el$62);
		insertNode(_el$60, createTextNode(\`Header 1\`));
		insertNode(_el$62, createTextNode(\`Header 2\`));
		insertNode(_el$64, _el$65);
		insertNode(_el$65, _el$66);
		insertNode(_el$65, _el$68);
		insertNode(_el$66, createTextNode(\`Cell 1\`));
		insertNode(_el$68, createTextNode(\`Cell 2\`));
		return _el$57;
	})();
}
function TestValidationScenarios() {
	return (() => {
		var _el$70 = createElement("div"), _el$71 = createElement("section"), _el$72 = createElement("article"), _el$73 = createElement("header"), _el$74 = createElement("h1"), _el$76 = createElement("main"), _el$77 = createElement("p"), _el$79 = createElement("footer"), _el$80 = createElement("small"), _el$82 = createElement("table"), _el$83 = createElement("tr"), _el$84 = createElement("td"), _el$86 = createElement("td"), _el$88 = createElement("img"), _el$89 = createElement("br"), _el$90 = createElement("hr");
		insertNode(_el$70, _el$71);
		insertNode(_el$70, _el$82);
		insertNode(_el$70, _el$88);
		insertNode(_el$70, _el$89);
		insertNode(_el$70, _el$90);
		insertNode(_el$71, _el$72);
		insertNode(_el$72, _el$73);
		insertNode(_el$72, _el$76);
		insertNode(_el$72, _el$79);
		insertNode(_el$73, _el$74);
		insertNode(_el$74, createTextNode(\`Title\`));
		insertNode(_el$76, _el$77);
		insertNode(_el$77, createTextNode(\`Content\`));
		insertNode(_el$79, _el$80);
		insertNode(_el$80, createTextNode(\`Footer\`));
		insertNode(_el$82, _el$83);
		insertNode(_el$83, _el$84);
		insertNode(_el$83, _el$86);
		insertNode(_el$84, createTextNode(\`Cell 1\`));
		insertNode(_el$86, createTextNode(\`Cell 2\`));
		setProp(_el$88, "src", "test.jpg");
		setProp(_el$88, "alt", "test");
		return _el$70;
	})();
}

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid src should transform templates with disabled delegation 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
const equalFn = (a, b) => a === b;
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}

//#endregion
//#region node_modules/solid-js/web/dist/web.js
const Properties = /* @__PURE__ */ new Set([
	"className",
	"value",
	"readOnly",
	"noValidate",
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"adAuctionHeaders",
	"allowFullscreen",
	"browsingTopics",
	"defaultChecked",
	"defaultMuted",
	"defaultSelected",
	"disablePictureInPicture",
	"disableRemotePlayback",
	"preservesPitch",
	"shadowRootClonable",
	"shadowRootCustomElementRegistry",
	"shadowRootDelegatesFocus",
	"shadowRootSerializable",
	"sharedStorageWritable",
	...[
		"allowfullscreen",
		"async",
		"alpha",
		"autofocus",
		"autoplay",
		"checked",
		"controls",
		"default",
		"disabled",
		"formnovalidate",
		"hidden",
		"indeterminate",
		"inert",
		"ismap",
		"loop",
		"multiple",
		"muted",
		"nomodule",
		"novalidate",
		"open",
		"playsinline",
		"readonly",
		"required",
		"reversed",
		"seamless",
		"selected",
		"adauctionheaders",
		"browsingtopics",
		"credentialless",
		"defaultchecked",
		"defaultmuted",
		"defaultselected",
		"defer",
		"disablepictureinpicture",
		"disableremoteplayback",
		"preservespitch",
		"shadowrootclonable",
		"shadowrootcustomelementregistry",
		"shadowrootdelegatesfocus",
		"shadowrootserializable",
		"sharedstoragewritable"
	]
]);
const ChildProperties = /* @__PURE__ */ new Set([
	"innerHTML",
	"textContent",
	"innerText",
	"children"
]);
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
function getPropAlias(prop, tagName) {
	const a = PropAliases[prop];
	return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
}
const DelegatedEvents = /* @__PURE__ */ new Set([
	"beforeinput",
	"click",
	"dblclick",
	"contextmenu",
	"focusin",
	"focusout",
	"input",
	"keydown",
	"keyup",
	"mousedown",
	"mousemove",
	"mouseout",
	"mouseover",
	"mouseup",
	"pointerdown",
	"pointermove",
	"pointerout",
	"pointerover",
	"pointerup",
	"touchend",
	"touchmove",
	"touchstart"
]);
const SVGNamespace = {
	xlink: "http://www.w3.org/1999/xlink",
	xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(parentNode, a, b) {
	let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
	while (aStart < aEnd || bStart < bEnd) {
		if (a[aStart] === b[bStart]) {
			aStart++;
			bStart++;
			continue;
		}
		while (a[aEnd - 1] === b[bEnd - 1]) {
			aEnd--;
			bEnd--;
		}
		if (aEnd === aStart) {
			const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
			while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
		} else if (bEnd === bStart) while (aStart < aEnd) {
			if (!map || !map.has(a[aStart])) a[aStart].remove();
			aStart++;
		}
		else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
			const node = a[--aEnd].nextSibling;
			parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
			parentNode.insertBefore(b[--bEnd], node);
			a[aEnd] = b[bEnd];
		} else {
			if (!map) {
				map = /* @__PURE__ */ new Map();
				let i = bStart;
				while (i < bEnd) map.set(b[i], i++);
			}
			const index = map.get(a[aStart]);
			if (index != null) if (bStart < index && index < bEnd) {
				let i = aStart, sequence = 1, t;
				while (++i < aEnd && i < bEnd) {
					if ((t = map.get(a[i])) == null || t !== index + sequence) break;
					sequence++;
				}
				if (sequence > index - bStart) {
					const node = a[aStart];
					while (bStart < index) parentNode.insertBefore(b[bStart++], node);
				} else parentNode.replaceChild(b[bStart++], a[aStart++]);
			} else aStart++;
			else a[aStart++].remove();
		}
	}
}
const $$EVENTS = "_$DX_DELEGATE";
function template(html, isImportNode, isSVG, isMathML) {
	let node;
	const create = () => {
		const t = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
		t.innerHTML = html;
		return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;
	};
	const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
	fn.cloneNode = fn;
	return fn;
}
function delegateEvents(eventNames, document$1 = window.document) {
	const e = document$1[$$EVENTS] || (document$1[$$EVENTS] = /* @__PURE__ */ new Set());
	for (let i = 0, l = eventNames.length; i < l; i++) {
		const name = eventNames[i];
		if (!e.has(name)) {
			e.add(name);
			document$1.addEventListener(name, eventHandler);
		}
	}
}
function setAttribute(node, name, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttribute(name);
	else node.setAttribute(name, value);
}
function setAttributeNS(node, namespace, name, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttributeNS(namespace, name);
	else node.setAttributeNS(namespace, name, value);
}
function setBoolAttribute(node, name, value) {
	if (isHydrating(node)) return;
	value ? node.setAttribute(name, "") : node.removeAttribute(name);
}
function className(node, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttribute("class");
	else node.className = value;
}
function addEventListener(node, name, handler, delegate) {
	if (delegate) if (Array.isArray(handler)) {
		node[\`$$\${name}\`] = handler[0];
		node[\`$$\${name}Data\`] = handler[1];
	} else node[\`$$\${name}\`] = handler;
	else if (Array.isArray(handler)) {
		const handlerFn = handler[0];
		node.addEventListener(name, handler[0] = (e) => handlerFn.call(node, handler[1], e));
	} else node.addEventListener(name, handler, typeof handler !== "function" && handler);
}
function classList(node, value, prev = {}) {
	const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
	let i, len;
	for (i = 0, len = prevKeys.length; i < len; i++) {
		const key = prevKeys[i];
		if (!key || key === "undefined" || value[key]) continue;
		toggleClassKey(node, key, false);
		delete prev[key];
	}
	for (i = 0, len = classKeys.length; i < len; i++) {
		const key = classKeys[i], classValue = !!value[key];
		if (!key || key === "undefined" || prev[key] === classValue || !classValue) continue;
		toggleClassKey(node, key, true);
		prev[key] = classValue;
	}
	return prev;
}
function style(node, value, prev) {
	if (!value) return prev ? setAttribute(node, "style") : value;
	const nodeStyle = node.style;
	if (typeof value === "string") return nodeStyle.cssText = value;
	typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
	prev || (prev = {});
	value || (value = {});
	let v, s;
	for (s in prev) {
		value[s] ?? nodeStyle.removeProperty(s);
		delete prev[s];
	}
	for (s in value) {
		v = value[s];
		if (v !== prev[s]) {
			nodeStyle.setProperty(s, v);
			prev[s] = v;
		}
	}
	return prev;
}
function spread(node, props = {}, isSVG, skipChildren) {
	const prevProps = {};
	if (!skipChildren) createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
	createRenderEffect(() => typeof props.ref === "function" && use(props.ref, node));
	createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
	return prevProps;
}
function use(fn, element, arg) {
	return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
	if (marker !== void 0 && !initial) initial = [];
	if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
	createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
	props || (props = {});
	for (const prop in prevProps) if (!(prop in props)) {
		if (prop === "children") continue;
		prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);
	}
	for (const prop in props) {
		if (prop === "children") {
			if (!skipChildren) insertExpression(node, props.children);
			continue;
		}
		const value = props[prop];
		prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);
	}
}
function isHydrating(node) {
	return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function toPropertyName(name) {
	return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
}
function toggleClassKey(node, key, value) {
	const classNames = key.trim().split(/\\s+/);
	for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);
}
function assignProp(node, prop, value, prev, isSVG, skipRef, props) {
	let isCE, isProp, isChildProp, propAlias, forceProp;
	if (prop === "style") return style(node, value, prev);
	if (prop === "classList") return classList(node, value, prev);
	if (value === prev) return prev;
	if (prop === "ref") {
		if (!skipRef) value(node);
	} else if (prop.slice(0, 3) === "on:") {
		const e = prop.slice(3);
		prev && node.removeEventListener(e, prev, typeof prev !== "function" && prev);
		value && node.addEventListener(e, value, typeof value !== "function" && value);
	} else if (prop.slice(0, 10) === "oncapture:") {
		const e = prop.slice(10);
		prev && node.removeEventListener(e, prev, true);
		value && node.addEventListener(e, value, true);
	} else if (prop.slice(0, 2) === "on") {
		const name = prop.slice(2).toLowerCase();
		const delegate = DelegatedEvents.has(name);
		if (!delegate && prev) {
			const h = Array.isArray(prev) ? prev[0] : prev;
			node.removeEventListener(name, h);
		}
		if (delegate || value) {
			addEventListener(node, name, value, delegate);
			delegate && delegateEvents([name]);
		}
	} else if (prop.slice(0, 5) === "attr:") setAttribute(node, prop.slice(5), value);
	else if (prop.slice(0, 5) === "bool:") setBoolAttribute(node, prop.slice(5), value);
	else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-") || "is" in props)) {
		if (forceProp) {
			prop = prop.slice(5);
			isProp = true;
		} else if (isHydrating(node)) return value;
		if (prop === "class" || prop === "className") className(node, value);
		else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;
		else node[propAlias || prop] = value;
	} else {
		const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
		if (ns) setAttributeNS(node, ns, prop, value);
		else setAttribute(node, Aliases[prop] || prop, value);
	}
	return value;
}
function eventHandler(e) {
	if (sharedConfig.registry && sharedConfig.events) {
		if (sharedConfig.events.find(([el, ev]) => ev === e)) return;
	}
	let node = e.target;
	const key = \`$$\${e.type}\`;
	const oriTarget = e.target;
	const oriCurrentTarget = e.currentTarget;
	const retarget = (value) => Object.defineProperty(e, "target", {
		configurable: true,
		value
	});
	const handleNode = () => {
		const handler = node[key];
		if (handler && !node.disabled) {
			const data = node[\`\${key}Data\`];
			data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
			if (e.cancelBubble) return;
		}
		node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
		return true;
	};
	const walkUpTree = () => {
		while (handleNode() && (node = node._$host || node.parentNode || node.host));
	};
	Object.defineProperty(e, "currentTarget", {
		configurable: true,
		get() {
			return node || document;
		}
	});
	if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
	if (e.composedPath) {
		const path = e.composedPath();
		retarget(path[0]);
		for (let i = 0; i < path.length - 2; i++) {
			node = path[i];
			if (!handleNode()) break;
			if (node._$host) {
				node = node._$host;
				walkUpTree();
				break;
			}
			if (node.parentNode === oriCurrentTarget) break;
		}
	} else walkUpTree();
	retarget(oriTarget);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
	const hydrating = isHydrating(parent);
	if (hydrating) {
		!current && (current = [...parent.childNodes]);
		let cleaned = [];
		for (let i = 0; i < current.length; i++) {
			const node = current[i];
			if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
			else cleaned.push(node);
		}
		current = cleaned;
	}
	while (typeof current === "function") current = current();
	if (value === current) return current;
	const t = typeof value, multi = marker !== void 0;
	parent = multi && current[0] && current[0].parentNode || parent;
	if (t === "string" || t === "number") {
		if (hydrating) return current;
		if (t === "number") {
			value = value.toString();
			if (value === current) return current;
		}
		if (multi) {
			let node = current[0];
			if (node && node.nodeType === 3) node.data !== value && (node.data = value);
			else node = document.createTextNode(value);
			current = cleanChildren(parent, current, marker, node);
		} else if (current !== "" && typeof current === "string") current = parent.firstChild.data = value;
		else current = parent.textContent = value;
	} else if (value == null || t === "boolean") {
		if (hydrating) return current;
		current = cleanChildren(parent, current, marker);
	} else if (t === "function") {
		createRenderEffect(() => {
			let v = value();
			while (typeof v === "function") v = v();
			current = insertExpression(parent, v, current, marker);
		});
		return () => current;
	} else if (Array.isArray(value)) {
		const array = [];
		const currentArray = current && Array.isArray(current);
		if (normalizeIncomingArray(array, value, current, unwrapArray)) {
			createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
			return () => current;
		}
		if (hydrating) {
			if (!array.length) return current;
			if (marker === void 0) return current = [...parent.childNodes];
			let node = array[0];
			if (node.parentNode !== parent) return current;
			const nodes = [node];
			while ((node = node.nextSibling) !== marker) nodes.push(node);
			return current = nodes;
		}
		if (array.length === 0) {
			current = cleanChildren(parent, current, marker);
			if (multi) return current;
		} else if (currentArray) if (current.length === 0) appendNodes(parent, array, marker);
		else reconcileArrays(parent, current, array);
		else {
			current && cleanChildren(parent);
			appendNodes(parent, array);
		}
		current = array;
	} else if (value.nodeType) {
		if (hydrating && value.parentNode) return current = multi ? [value] : value;
		if (Array.isArray(current)) {
			if (multi) return current = cleanChildren(parent, current, marker, value);
			cleanChildren(parent, current, null, value);
		} else if (current == null || current === "" || !parent.firstChild) parent.appendChild(value);
		else parent.replaceChild(value, parent.firstChild);
		current = value;
	}
	return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
	let dynamic = false;
	for (let i = 0, len = array.length; i < len; i++) {
		let item = array[i], prev = current && current[normalized.length], t;
		if (item == null || item === true || item === false);
		else if ((t = typeof item) === "object" && item.nodeType) normalized.push(item);
		else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
		else if (t === "function") if (unwrap) {
			while (typeof item === "function") item = item();
			dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
		} else {
			normalized.push(item);
			dynamic = true;
		}
		else {
			const value = String(item);
			if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
			else normalized.push(document.createTextNode(value));
		}
	}
	return dynamic;
}
function appendNodes(parent, array, marker = null) {
	for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
	if (marker === void 0) return parent.textContent = "";
	const node = replacement || document.createTextNode("");
	if (current.length) {
		let inserted = false;
		for (let i = current.length - 1; i >= 0; i--) {
			const el = current[i];
			if (node !== el) {
				const isParent = el.parentNode === parent;
				if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
				else isParent && el.remove();
			} else inserted = true;
		}
	} else parent.insertBefore(node, marker);
	return [node];
}

//#endregion
//#region tests/fixtures/templates.tsx
var _tmpl$ = /* @__PURE__ */ template(\`<svg width=100 height=100><circle cx=50 cy=50 r=40 fill=red></circle><foreignObject x=10 y=10 width=80 height=80><div><p>HTML content inside SVG\`), _tmpl$2 = /* @__PURE__ */ template(\`<div><svg><g><rect x=0 y=0 width=100 height=100>\`), _tmpl$3 = /* @__PURE__ */ template(\`<div><button>Click me</button><div>Hover me</div><input><form><select><option value=1>Option 1</option><option value=2>Option 2\`), _tmpl$4 = /* @__PURE__ */ template(\`<div class=container><h1>Title</h1><ul></ul><div style=color:red;font-size:16px>Styled content\`), _tmpl$5 = /* @__PURE__ */ template(\`<p>Conditional content\`), _tmpl$6 = /* @__PURE__ */ template(\`<li>\`), _tmpl$7 = /* @__PURE__ */ template(\`<div id=test class=my-class data-testid=element aria-label="Accessible element"role=button tabindex=0><img src=test.jpg alt="test image"width=100 height=100><input type=text placeholder="Enter text"required>\`), _tmpl$8 = /* @__PURE__ */ template(\`<svg width=100 height=100><circle cx=50 cy=50 r=40 fill=red></circle><rect x=10 y=10 width=30 height=30 fill=blue></rect><text x=50 y=50 text-anchor=middle>SVG Text\`), _tmpl$9 = /* @__PURE__ */ template(\`<head><title>SSR Test</title><meta charset=utf-8><meta name=viewport content="width=device-width">\`), _tmpl$0 = /* @__PURE__ */ template(\`<div><script>console.log('test');<\\/script><style>body \\{ margin: 0; }\`), _tmpl$1 = /* @__PURE__ */ template(\`<div><p>Static content</p><div></div><ul>\`), _tmpl$10 = /* @__PURE__ */ template(\`<li>Item \`), _tmpl$11 = /* @__PURE__ */ template(\`<div>Spread attributes\`), _tmpl$12 = /* @__PURE__ */ template(\`<table><thead><tr><th>Header 1</th><th>Header 2</th></tr></thead><tbody><tr><td>Cell 1</td><td>Cell 2\`), _tmpl$13 = /* @__PURE__ */ template(\`<div><section><article><header><h1>Title</h1></header><main><p>Content</p></main><footer><small>Footer</small></footer></article></section><table><tr><td>Cell 1</td><td>Cell 2</td></tr></table><img src=test.jpg alt=test><br><hr>\`);
function TestSvgWrap() {
	return _tmpl$();
}
function TestNestedSvg() {
	return _tmpl$2();
}
function TestEventDelegation() {
	return (() => {
		var _el$3 = _tmpl$3(), _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$5.nextSibling, _el$7 = _el$6.nextSibling, _el$8 = _el$7.firstChild;
		_el$4.addEventListener("click", () => console.log("click"));
		_el$5.addEventListener("mouseover", () => console.log("hover"));
		_el$6.addEventListener("input", (e) => console.log(e.target.value));
		_el$7.addEventListener("submit", (e) => e.preventDefault());
		_el$8.addEventListener("change", (e) => console.log(e.target.value));
		return _el$3;
	})();
}
function TestComplexTemplates() {
	const items = [
		"a",
		"b",
		"c"
	];
	return (() => {
		var _el$9 = _tmpl$4(), _el$1 = _el$9.firstChild.nextSibling;
		_el$1.nextSibling;
		insert(_el$9, _tmpl$5(), _el$1);
		insert(_el$1, () => items.map((item) => (() => {
			var _el$12 = _tmpl$6();
			insert(_el$12, item);
			return _el$12;
		})()));
		return _el$9;
	})();
}
function TestAttributeTemplates() {
	return (() => {
		var _el$13 = _tmpl$7(), _el$15 = _el$13.firstChild.nextSibling;
		_el$15.disabled = false;
		return _el$13;
	})();
}
function TestSVGTemplates() {
	return _tmpl$8();
}
function TestSSRHeadElement() {
	return _tmpl$9();
}
function TestSSRScriptStyle() {
	return _tmpl$0();
}
function TestSSRHydration() {
	return (() => {
		var _el$19 = _tmpl$1(), _el$21 = _el$19.firstChild.nextSibling, _el$22 = _el$21.nextSibling;
		insert(_el$21, () => \`Dynamic content: \${Date.now()}\`);
		insert(_el$22, () => [
			1,
			2,
			3
		].map((item) => (() => {
			var _el$23 = _tmpl$10();
			_el$23.firstChild;
			insert(_el$23, item, null);
			return _el$23;
		})()));
		return _el$19;
	})();
}
function TestSSRSpreadAttributes() {
	const props = {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	};
	return (() => {
		var _el$25 = _tmpl$11();
		spread(_el$25, props, false, true);
		return _el$25;
	})();
}
function TestSSRSpecialElements() {
	return _tmpl$12();
}
function TestValidationScenarios() {
	return _tmpl$13();
}

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid dist should transform templates with disabled delegation 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
const equalFn = (a, b) => a === b;
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}

//#endregion
//#region node_modules/solid-js/web/dist/web.js
const Properties = /* @__PURE__ */ new Set([
	"className",
	"value",
	"readOnly",
	"noValidate",
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"adAuctionHeaders",
	"allowFullscreen",
	"browsingTopics",
	"defaultChecked",
	"defaultMuted",
	"defaultSelected",
	"disablePictureInPicture",
	"disableRemotePlayback",
	"preservesPitch",
	"shadowRootClonable",
	"shadowRootCustomElementRegistry",
	"shadowRootDelegatesFocus",
	"shadowRootSerializable",
	"sharedStorageWritable",
	...[
		"allowfullscreen",
		"async",
		"alpha",
		"autofocus",
		"autoplay",
		"checked",
		"controls",
		"default",
		"disabled",
		"formnovalidate",
		"hidden",
		"indeterminate",
		"inert",
		"ismap",
		"loop",
		"multiple",
		"muted",
		"nomodule",
		"novalidate",
		"open",
		"playsinline",
		"readonly",
		"required",
		"reversed",
		"seamless",
		"selected",
		"adauctionheaders",
		"browsingtopics",
		"credentialless",
		"defaultchecked",
		"defaultmuted",
		"defaultselected",
		"defer",
		"disablepictureinpicture",
		"disableremoteplayback",
		"preservespitch",
		"shadowrootclonable",
		"shadowrootcustomelementregistry",
		"shadowrootdelegatesfocus",
		"shadowrootserializable",
		"sharedstoragewritable"
	]
]);
const ChildProperties = /* @__PURE__ */ new Set([
	"innerHTML",
	"textContent",
	"innerText",
	"children"
]);
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
function getPropAlias(prop, tagName) {
	const a = PropAliases[prop];
	return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
}
const DelegatedEvents = /* @__PURE__ */ new Set([
	"beforeinput",
	"click",
	"dblclick",
	"contextmenu",
	"focusin",
	"focusout",
	"input",
	"keydown",
	"keyup",
	"mousedown",
	"mousemove",
	"mouseout",
	"mouseover",
	"mouseup",
	"pointerdown",
	"pointermove",
	"pointerout",
	"pointerover",
	"pointerup",
	"touchend",
	"touchmove",
	"touchstart"
]);
const SVGNamespace = {
	xlink: "http://www.w3.org/1999/xlink",
	xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(parentNode, a, b) {
	let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
	while (aStart < aEnd || bStart < bEnd) {
		if (a[aStart] === b[bStart]) {
			aStart++;
			bStart++;
			continue;
		}
		while (a[aEnd - 1] === b[bEnd - 1]) {
			aEnd--;
			bEnd--;
		}
		if (aEnd === aStart) {
			const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
			while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
		} else if (bEnd === bStart) while (aStart < aEnd) {
			if (!map || !map.has(a[aStart])) a[aStart].remove();
			aStart++;
		}
		else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
			const node = a[--aEnd].nextSibling;
			parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
			parentNode.insertBefore(b[--bEnd], node);
			a[aEnd] = b[bEnd];
		} else {
			if (!map) {
				map = /* @__PURE__ */ new Map();
				let i = bStart;
				while (i < bEnd) map.set(b[i], i++);
			}
			const index = map.get(a[aStart]);
			if (index != null) if (bStart < index && index < bEnd) {
				let i = aStart, sequence = 1, t;
				while (++i < aEnd && i < bEnd) {
					if ((t = map.get(a[i])) == null || t !== index + sequence) break;
					sequence++;
				}
				if (sequence > index - bStart) {
					const node = a[aStart];
					while (bStart < index) parentNode.insertBefore(b[bStart++], node);
				} else parentNode.replaceChild(b[bStart++], a[aStart++]);
			} else aStart++;
			else a[aStart++].remove();
		}
	}
}
const $$EVENTS = "_$DX_DELEGATE";
function template(html, isImportNode, isSVG, isMathML) {
	let node;
	const create = () => {
		const t = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
		t.innerHTML = html;
		return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;
	};
	const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
	fn.cloneNode = fn;
	return fn;
}
function delegateEvents(eventNames, document$1 = window.document) {
	const e = document$1[$$EVENTS] || (document$1[$$EVENTS] = /* @__PURE__ */ new Set());
	for (let i = 0, l = eventNames.length; i < l; i++) {
		const name = eventNames[i];
		if (!e.has(name)) {
			e.add(name);
			document$1.addEventListener(name, eventHandler);
		}
	}
}
function setAttribute(node, name, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttribute(name);
	else node.setAttribute(name, value);
}
function setAttributeNS(node, namespace, name, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttributeNS(namespace, name);
	else node.setAttributeNS(namespace, name, value);
}
function setBoolAttribute(node, name, value) {
	if (isHydrating(node)) return;
	value ? node.setAttribute(name, "") : node.removeAttribute(name);
}
function className(node, value) {
	if (isHydrating(node)) return;
	if (value == null) node.removeAttribute("class");
	else node.className = value;
}
function addEventListener(node, name, handler, delegate) {
	if (delegate) if (Array.isArray(handler)) {
		node[\`$$\${name}\`] = handler[0];
		node[\`$$\${name}Data\`] = handler[1];
	} else node[\`$$\${name}\`] = handler;
	else if (Array.isArray(handler)) {
		const handlerFn = handler[0];
		node.addEventListener(name, handler[0] = (e) => handlerFn.call(node, handler[1], e));
	} else node.addEventListener(name, handler, typeof handler !== "function" && handler);
}
function classList(node, value, prev = {}) {
	const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
	let i, len;
	for (i = 0, len = prevKeys.length; i < len; i++) {
		const key = prevKeys[i];
		if (!key || key === "undefined" || value[key]) continue;
		toggleClassKey(node, key, false);
		delete prev[key];
	}
	for (i = 0, len = classKeys.length; i < len; i++) {
		const key = classKeys[i], classValue = !!value[key];
		if (!key || key === "undefined" || prev[key] === classValue || !classValue) continue;
		toggleClassKey(node, key, true);
		prev[key] = classValue;
	}
	return prev;
}
function style(node, value, prev) {
	if (!value) return prev ? setAttribute(node, "style") : value;
	const nodeStyle = node.style;
	if (typeof value === "string") return nodeStyle.cssText = value;
	typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
	prev || (prev = {});
	value || (value = {});
	let v, s;
	for (s in prev) {
		value[s] ?? nodeStyle.removeProperty(s);
		delete prev[s];
	}
	for (s in value) {
		v = value[s];
		if (v !== prev[s]) {
			nodeStyle.setProperty(s, v);
			prev[s] = v;
		}
	}
	return prev;
}
function spread(node, props = {}, isSVG, skipChildren) {
	const prevProps = {};
	if (!skipChildren) createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
	createRenderEffect(() => typeof props.ref === "function" && use(props.ref, node));
	createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
	return prevProps;
}
function use(fn, element, arg) {
	return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
	if (marker !== void 0 && !initial) initial = [];
	if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
	createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
	props || (props = {});
	for (const prop in prevProps) if (!(prop in props)) {
		if (prop === "children") continue;
		prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);
	}
	for (const prop in props) {
		if (prop === "children") {
			if (!skipChildren) insertExpression(node, props.children);
			continue;
		}
		const value = props[prop];
		prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);
	}
}
function isHydrating(node) {
	return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function toPropertyName(name) {
	return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
}
function toggleClassKey(node, key, value) {
	const classNames = key.trim().split(/\\s+/);
	for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);
}
function assignProp(node, prop, value, prev, isSVG, skipRef, props) {
	let isCE, isProp, isChildProp, propAlias, forceProp;
	if (prop === "style") return style(node, value, prev);
	if (prop === "classList") return classList(node, value, prev);
	if (value === prev) return prev;
	if (prop === "ref") {
		if (!skipRef) value(node);
	} else if (prop.slice(0, 3) === "on:") {
		const e = prop.slice(3);
		prev && node.removeEventListener(e, prev, typeof prev !== "function" && prev);
		value && node.addEventListener(e, value, typeof value !== "function" && value);
	} else if (prop.slice(0, 10) === "oncapture:") {
		const e = prop.slice(10);
		prev && node.removeEventListener(e, prev, true);
		value && node.addEventListener(e, value, true);
	} else if (prop.slice(0, 2) === "on") {
		const name = prop.slice(2).toLowerCase();
		const delegate = DelegatedEvents.has(name);
		if (!delegate && prev) {
			const h = Array.isArray(prev) ? prev[0] : prev;
			node.removeEventListener(name, h);
		}
		if (delegate || value) {
			addEventListener(node, name, value, delegate);
			delegate && delegateEvents([name]);
		}
	} else if (prop.slice(0, 5) === "attr:") setAttribute(node, prop.slice(5), value);
	else if (prop.slice(0, 5) === "bool:") setBoolAttribute(node, prop.slice(5), value);
	else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-") || "is" in props)) {
		if (forceProp) {
			prop = prop.slice(5);
			isProp = true;
		} else if (isHydrating(node)) return value;
		if (prop === "class" || prop === "className") className(node, value);
		else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;
		else node[propAlias || prop] = value;
	} else {
		const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
		if (ns) setAttributeNS(node, ns, prop, value);
		else setAttribute(node, Aliases[prop] || prop, value);
	}
	return value;
}
function eventHandler(e) {
	if (sharedConfig.registry && sharedConfig.events) {
		if (sharedConfig.events.find(([el, ev]) => ev === e)) return;
	}
	let node = e.target;
	const key = \`$$\${e.type}\`;
	const oriTarget = e.target;
	const oriCurrentTarget = e.currentTarget;
	const retarget = (value) => Object.defineProperty(e, "target", {
		configurable: true,
		value
	});
	const handleNode = () => {
		const handler = node[key];
		if (handler && !node.disabled) {
			const data = node[\`\${key}Data\`];
			data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
			if (e.cancelBubble) return;
		}
		node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
		return true;
	};
	const walkUpTree = () => {
		while (handleNode() && (node = node._$host || node.parentNode || node.host));
	};
	Object.defineProperty(e, "currentTarget", {
		configurable: true,
		get() {
			return node || document;
		}
	});
	if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
	if (e.composedPath) {
		const path = e.composedPath();
		retarget(path[0]);
		for (let i = 0; i < path.length - 2; i++) {
			node = path[i];
			if (!handleNode()) break;
			if (node._$host) {
				node = node._$host;
				walkUpTree();
				break;
			}
			if (node.parentNode === oriCurrentTarget) break;
		}
	} else walkUpTree();
	retarget(oriTarget);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
	const hydrating = isHydrating(parent);
	if (hydrating) {
		!current && (current = [...parent.childNodes]);
		let cleaned = [];
		for (let i = 0; i < current.length; i++) {
			const node = current[i];
			if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
			else cleaned.push(node);
		}
		current = cleaned;
	}
	while (typeof current === "function") current = current();
	if (value === current) return current;
	const t = typeof value, multi = marker !== void 0;
	parent = multi && current[0] && current[0].parentNode || parent;
	if (t === "string" || t === "number") {
		if (hydrating) return current;
		if (t === "number") {
			value = value.toString();
			if (value === current) return current;
		}
		if (multi) {
			let node = current[0];
			if (node && node.nodeType === 3) node.data !== value && (node.data = value);
			else node = document.createTextNode(value);
			current = cleanChildren(parent, current, marker, node);
		} else if (current !== "" && typeof current === "string") current = parent.firstChild.data = value;
		else current = parent.textContent = value;
	} else if (value == null || t === "boolean") {
		if (hydrating) return current;
		current = cleanChildren(parent, current, marker);
	} else if (t === "function") {
		createRenderEffect(() => {
			let v = value();
			while (typeof v === "function") v = v();
			current = insertExpression(parent, v, current, marker);
		});
		return () => current;
	} else if (Array.isArray(value)) {
		const array = [];
		const currentArray = current && Array.isArray(current);
		if (normalizeIncomingArray(array, value, current, unwrapArray)) {
			createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
			return () => current;
		}
		if (hydrating) {
			if (!array.length) return current;
			if (marker === void 0) return current = [...parent.childNodes];
			let node = array[0];
			if (node.parentNode !== parent) return current;
			const nodes = [node];
			while ((node = node.nextSibling) !== marker) nodes.push(node);
			return current = nodes;
		}
		if (array.length === 0) {
			current = cleanChildren(parent, current, marker);
			if (multi) return current;
		} else if (currentArray) if (current.length === 0) appendNodes(parent, array, marker);
		else reconcileArrays(parent, current, array);
		else {
			current && cleanChildren(parent);
			appendNodes(parent, array);
		}
		current = array;
	} else if (value.nodeType) {
		if (hydrating && value.parentNode) return current = multi ? [value] : value;
		if (Array.isArray(current)) {
			if (multi) return current = cleanChildren(parent, current, marker, value);
			cleanChildren(parent, current, null, value);
		} else if (current == null || current === "" || !parent.firstChild) parent.appendChild(value);
		else parent.replaceChild(value, parent.firstChild);
		current = value;
	}
	return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
	let dynamic = false;
	for (let i = 0, len = array.length; i < len; i++) {
		let item = array[i], prev = current && current[normalized.length], t;
		if (item == null || item === true || item === false);
		else if ((t = typeof item) === "object" && item.nodeType) normalized.push(item);
		else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
		else if (t === "function") if (unwrap) {
			while (typeof item === "function") item = item();
			dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
		} else {
			normalized.push(item);
			dynamic = true;
		}
		else {
			const value = String(item);
			if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
			else normalized.push(document.createTextNode(value));
		}
	}
	return dynamic;
}
function appendNodes(parent, array, marker = null) {
	for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
	if (marker === void 0) return parent.textContent = "";
	const node = replacement || document.createTextNode("");
	if (current.length) {
		let inserted = false;
		for (let i = current.length - 1; i >= 0; i--) {
			const el = current[i];
			if (node !== el) {
				const isParent = el.parentNode === parent;
				if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
				else isParent && el.remove();
			} else inserted = true;
		}
	} else parent.insertBefore(node, marker);
	return [node];
}

//#endregion
//#region tests/fixtures/templates.tsx
var _tmpl$ = /* @__PURE__ */ template(\`<svg width=100 height=100><circle cx=50 cy=50 r=40 fill=red></circle><foreignObject x=10 y=10 width=80 height=80><div><p>HTML content inside SVG\`), _tmpl$2 = /* @__PURE__ */ template(\`<div><svg><g><rect x=0 y=0 width=100 height=100>\`), _tmpl$3 = /* @__PURE__ */ template(\`<div><button>Click me</button><div>Hover me</div><input><form><select><option value=1>Option 1</option><option value=2>Option 2\`), _tmpl$4 = /* @__PURE__ */ template(\`<div class=container><h1>Title</h1><ul></ul><div style=color:red;font-size:16px>Styled content\`), _tmpl$5 = /* @__PURE__ */ template(\`<p>Conditional content\`), _tmpl$6 = /* @__PURE__ */ template(\`<li>\`), _tmpl$7 = /* @__PURE__ */ template(\`<div id=test class=my-class data-testid=element aria-label="Accessible element"role=button tabindex=0><img src=test.jpg alt="test image"width=100 height=100><input type=text placeholder="Enter text"required>\`), _tmpl$8 = /* @__PURE__ */ template(\`<svg width=100 height=100><circle cx=50 cy=50 r=40 fill=red></circle><rect x=10 y=10 width=30 height=30 fill=blue></rect><text x=50 y=50 text-anchor=middle>SVG Text\`), _tmpl$9 = /* @__PURE__ */ template(\`<head><title>SSR Test</title><meta charset=utf-8><meta name=viewport content="width=device-width">\`), _tmpl$0 = /* @__PURE__ */ template(\`<div><script>console.log('test');<\\/script><style>body \\{ margin: 0; }\`), _tmpl$1 = /* @__PURE__ */ template(\`<div><p>Static content</p><div></div><ul>\`), _tmpl$10 = /* @__PURE__ */ template(\`<li>Item \`), _tmpl$11 = /* @__PURE__ */ template(\`<div>Spread attributes\`), _tmpl$12 = /* @__PURE__ */ template(\`<table><thead><tr><th>Header 1</th><th>Header 2</th></tr></thead><tbody><tr><td>Cell 1</td><td>Cell 2\`), _tmpl$13 = /* @__PURE__ */ template(\`<div><section><article><header><h1>Title</h1></header><main><p>Content</p></main><footer><small>Footer</small></footer></article></section><table><tr><td>Cell 1</td><td>Cell 2</td></tr></table><img src=test.jpg alt=test><br><hr>\`);
function TestSvgWrap() {
	return _tmpl$();
}
function TestNestedSvg() {
	return _tmpl$2();
}
function TestEventDelegation() {
	return (() => {
		var _el$3 = _tmpl$3(), _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$5.nextSibling, _el$7 = _el$6.nextSibling, _el$8 = _el$7.firstChild;
		_el$4.addEventListener("click", () => console.log("click"));
		_el$5.addEventListener("mouseover", () => console.log("hover"));
		_el$6.addEventListener("input", (e) => console.log(e.target.value));
		_el$7.addEventListener("submit", (e) => e.preventDefault());
		_el$8.addEventListener("change", (e) => console.log(e.target.value));
		return _el$3;
	})();
}
function TestComplexTemplates() {
	const items = [
		"a",
		"b",
		"c"
	];
	return (() => {
		var _el$9 = _tmpl$4(), _el$1 = _el$9.firstChild.nextSibling;
		_el$1.nextSibling;
		insert(_el$9, _tmpl$5(), _el$1);
		insert(_el$1, () => items.map((item) => (() => {
			var _el$12 = _tmpl$6();
			insert(_el$12, item);
			return _el$12;
		})()));
		return _el$9;
	})();
}
function TestAttributeTemplates() {
	return (() => {
		var _el$13 = _tmpl$7(), _el$15 = _el$13.firstChild.nextSibling;
		_el$15.disabled = false;
		return _el$13;
	})();
}
function TestSVGTemplates() {
	return _tmpl$8();
}
function TestSSRHeadElement() {
	return _tmpl$9();
}
function TestSSRScriptStyle() {
	return _tmpl$0();
}
function TestSSRHydration() {
	return (() => {
		var _el$19 = _tmpl$1(), _el$21 = _el$19.firstChild.nextSibling, _el$22 = _el$21.nextSibling;
		insert(_el$21, () => \`Dynamic content: \${Date.now()}\`);
		insert(_el$22, () => [
			1,
			2,
			3
		].map((item) => (() => {
			var _el$23 = _tmpl$10();
			_el$23.firstChild;
			insert(_el$23, item, null);
			return _el$23;
		})()));
		return _el$19;
	})();
}
function TestSSRSpreadAttributes() {
	const props = {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	};
	return (() => {
		var _el$25 = _tmpl$11();
		spread(_el$25, props, false, true);
		return _el$25;
	})();
}
function TestSSRSpecialElements() {
	return _tmpl$12();
}
function TestValidationScenarios() {
	return _tmpl$13();
}

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid src should transform templates with hydratable SSR 1`] = `
"//#region node_modules/solid-js/dist/server.js
const ERROR = Symbol("error");
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function handleError(err, owner = Owner) {
	const fns = owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	try {
		for (const f$1 of fns) f$1(error);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
let Owner = null;
function createOwner() {
	const o$2 = {
		owner: Owner,
		context: Owner ? Owner.context : null,
		owned: null,
		cleanups: null
	};
	if (Owner) if (!Owner.owned) Owner.owned = [o$2];
	else Owner.owned.push(o$2);
	return o$2;
}
function createMemo(fn, value) {
	Owner = createOwner();
	let v$2;
	try {
		v$2 = fn(value);
	} catch (err) {
		handleError(err);
	} finally {
		Owner = Owner.owner;
	}
	return () => v$2;
}
function createContext(defaultValue) {
	const id = Symbol("context");
	return {
		id,
		Provider: createProvider(id),
		defaultValue
	};
}
function children(fn) {
	const memo = createMemo(() => resolveChildren(fn()));
	memo.toArray = () => {
		const c$2 = memo();
		return Array.isArray(c$2) ? c$2 : c$2 != null ? [c$2] : [];
	};
	return memo;
}
function resolveChildren(children$1) {
	if (typeof children$1 === "function" && !children$1.length) return resolveChildren(children$1());
	if (Array.isArray(children$1)) {
		const results = [];
		for (let i$1 = 0; i$1 < children$1.length; i$1++) {
			const result = resolveChildren(children$1[i$1]);
			Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
		}
		return results;
	}
	return children$1;
}
function createProvider(id) {
	return function provider(props) {
		return createMemo(() => {
			Owner.context = {
				...Owner.context,
				[id]: props.value
			};
			return children(() => props.children);
		});
	};
}
const sharedConfig = {
	context: void 0,
	getContextId() {
		if (!this.context) throw new Error(\`getContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count);
	},
	getNextContextId() {
		if (!this.context) throw new Error(\`getNextContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
	sharedConfig.context = context;
}
function nextHydrateContext() {
	return sharedConfig.context ? {
		...sharedConfig.context,
		id: sharedConfig.getNextContextId(),
		count: 0
	} : void 0;
}
function createComponent(Comp, props) {
	if (sharedConfig.context && !sharedConfig.context.noHydrate) {
		const c$2 = sharedConfig.context;
		setHydrateContext(nextHydrateContext());
		const r = Comp(props || {});
		setHydrateContext(c$2);
		return r;
	}
	return Comp(props || {});
}
const SuspenseContext = createContext();

//#endregion
//#region node_modules/seroval/dist/esm/production/index.mjs
var L$1 = ((i$1) => (i$1[i$1.AggregateError = 1] = "AggregateError", i$1[i$1.ArrowFunction = 2] = "ArrowFunction", i$1[i$1.ErrorPrototypeStack = 4] = "ErrorPrototypeStack", i$1[i$1.ObjectAssign = 8] = "ObjectAssign", i$1[i$1.BigIntTypedArray = 16] = "BigIntTypedArray", i$1[i$1.RegExp = 32] = "RegExp", i$1))(L$1 || {});
var v$1 = Symbol.asyncIterator, mr = Symbol.hasInstance, R = Symbol.isConcatSpreadable, C = Symbol.iterator, pr = Symbol.match, dr = Symbol.matchAll, gr = Symbol.replace, yr = Symbol.search, Nr = Symbol.species, br = Symbol.split, vr = Symbol.toPrimitive, P$1 = Symbol.toStringTag, Cr = Symbol.unscopables;
var rt = {
	0: "Symbol.asyncIterator",
	1: "Symbol.hasInstance",
	2: "Symbol.isConcatSpreadable",
	3: "Symbol.iterator",
	4: "Symbol.match",
	5: "Symbol.matchAll",
	6: "Symbol.replace",
	7: "Symbol.search",
	8: "Symbol.species",
	9: "Symbol.split",
	10: "Symbol.toPrimitive",
	11: "Symbol.toStringTag",
	12: "Symbol.unscopables"
}, ve = {
	[v$1]: 0,
	[mr]: 1,
	[R]: 2,
	[C]: 3,
	[pr]: 4,
	[dr]: 5,
	[gr]: 6,
	[yr]: 7,
	[Nr]: 8,
	[br]: 9,
	[vr]: 10,
	[P$1]: 11,
	[Cr]: 12
}, tt = {
	0: v$1,
	1: mr,
	2: R,
	3: C,
	4: pr,
	5: dr,
	6: gr,
	7: yr,
	8: Nr,
	9: br,
	10: vr,
	11: P$1,
	12: Cr
}, nt = {
	2: "!0",
	3: "!1",
	1: "void 0",
	0: "null",
	4: "-0",
	5: "1/0",
	6: "-1/0",
	7: "0/0"
}, o$1 = void 0, ot = {
	2: !0,
	3: !1,
	1: o$1,
	0: null,
	4: -0,
	5: Number.POSITIVE_INFINITY,
	6: Number.NEGATIVE_INFINITY,
	7: NaN
};
function c$1(e, r, t, n$1, a, s, i$1, u$1, l$1, g$1, S, d$1) {
	return {
		t: e,
		i: r,
		s: t,
		c: n$1,
		m: a,
		p: s,
		e: i$1,
		a: u$1,
		f: l$1,
		b: g$1,
		o: S,
		l: d$1
	};
}
function F(e) {
	return c$1(2, o$1, e, o$1, o$1, o$1, o$1, o$1, o$1, o$1, o$1, o$1);
}
var J = F(2), Z = F(3), Ae = F(1), Ee = F(0), st = F(4), it = F(5), ut = F(6), lt = F(7);
var U = "__SEROVAL_REFS__", ce = "$R", Ie = \`self.\${ce}\`;
var Ar = /* @__PURE__ */ new Map(), j = /* @__PURE__ */ new Map();
typeof globalThis != "undefined" ? Object.defineProperty(globalThis, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof window != "undefined" ? Object.defineProperty(window, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof self != "undefined" ? Object.defineProperty(self, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof global != "undefined" && Object.defineProperty(global, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
});
var { toString: ys } = Object.prototype;
var re = () => {
	let e = {
		p: 0,
		s: 0,
		f: 0
	};
	return e.p = new Promise((r, t) => {
		e.s = r, e.f = t;
	}), e;
}, vn = (e, r) => {
	e.s(r), e.p.s = 1, e.p.v = r;
}, Cn = (e, r) => {
	e.f(r), e.p.s = 2, e.p.v = r;
}, yt = re.toString(), Nt = vn.toString(), bt = Cn.toString(), Rr = () => {
	let e = [], r = [], t = !0, n$1 = !1, a = 0, s = (l$1, g$1, S) => {
		for (S = 0; S < a; S++) r[S] && r[S][g$1](l$1);
	}, i$1 = (l$1, g$1, S, d$1) => {
		for (g$1 = 0, S = e.length; g$1 < S; g$1++) d$1 = e[g$1], !t && g$1 === S - 1 ? l$1[n$1 ? "return" : "throw"](d$1) : l$1.next(d$1);
	}, u$1 = (l$1, g$1) => (t && (g$1 = a++, r[g$1] = l$1), i$1(l$1), () => {
		t && (r[g$1] = r[a], r[a--] = void 0);
	});
	return {
		__SEROVAL_STREAM__: !0,
		on: (l$1) => u$1(l$1),
		next: (l$1) => {
			t && (e.push(l$1), s(l$1, "next"));
		},
		throw: (l$1) => {
			t && (e.push(l$1), s(l$1, "throw"), t = !1, n$1 = !1, r.length = 0);
		},
		return: (l$1) => {
			t && (e.push(l$1), s(l$1, "return"), t = !1, n$1 = !0, r.length = 0);
		}
	};
}, vt = Rr.toString(), Pr = (e) => (r) => () => {
	let t = 0, n$1 = {
		[e]: () => n$1,
		next: () => {
			if (t > r.d) return {
				done: !0,
				value: void 0
			};
			let a = t++, s = r.v[a];
			if (a === r.t) throw s;
			return {
				done: a === r.d,
				value: s
			};
		}
	};
	return n$1;
}, Ct = Pr.toString(), xr = (e, r) => (t) => () => {
	let n$1 = 0, a = -1, s = !1, i$1 = [], u$1 = [], l$1 = (S = 0, d$1 = u$1.length) => {
		for (; S < d$1; S++) u$1[S].s({
			done: !0,
			value: void 0
		});
	};
	t.on({
		next: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.s({
				done: !1,
				value: S
			}), i$1.push(S);
		},
		throw: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.f(S), l$1(), a = i$1.length, s = !0, i$1.push(S);
		},
		return: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.s({
				done: !0,
				value: S
			}), l$1(), a = i$1.length, i$1.push(S);
		}
	});
	let g$1 = {
		[e]: () => g$1,
		next: () => {
			if (a === -1) {
				let K$1 = n$1++;
				if (K$1 >= i$1.length) {
					let et = r();
					return u$1.push(et), et.p;
				}
				return {
					done: !1,
					value: i$1[K$1]
				};
			}
			if (n$1 > a) return {
				done: !0,
				value: void 0
			};
			let S = n$1++, d$1 = i$1[S];
			if (S !== a) return {
				done: !1,
				value: d$1
			};
			if (s) throw d$1;
			return {
				done: !0,
				value: d$1
			};
		}
	};
	return g$1;
}, At = xr.toString(), Or = (e) => {
	let r = atob(e), t = r.length, n$1 = new Uint8Array(t);
	for (let a = 0; a < t; a++) n$1[a] = r.charCodeAt(a);
	return n$1.buffer;
}, Et = Or.toString();
var An = Pr(C);
function te$1() {
	return Rr();
}
var En = xr(v$1, re);
var ae = ((t) => (t[t.Vanilla = 1] = "Vanilla", t[t.Cross = 2] = "Cross", t))(ae || {});
function ni(e) {
	return e;
}
var Eo = () => T, Io = Eo.toString(), qt = /=>/.test(Io);
var Ht = "hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_", Gt = Ht.length, Jt = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_", Kt = Jt.length;

//#endregion
//#region node_modules/seroval-plugins/dist/esm/production/web.mjs
var u = (e) => {
	let r = new AbortController(), a = r.abort.bind(r);
	return e.then(a, a), r;
};
function E(e) {
	e(this.reason);
}
function D(e) {
	this.addEventListener("abort", E.bind(this, e), { once: !0 });
}
function c(e) {
	return new Promise(D.bind(e));
}
var i = {}, O = ni({
	tag: "seroval-plugins/web/AbortSignal",
	extends: [ni({
		tag: "seroval-plugins/web/AbortControllerFactoryPlugin",
		test(e) {
			return e === i;
		},
		parse: {
			sync() {
				return i;
			},
			async async() {
				return await Promise.resolve(i);
			},
			stream() {
				return i;
			}
		},
		serialize() {
			return u.toString();
		},
		deserialize() {
			return u;
		}
	})],
	test(e) {
		return typeof AbortSignal == "undefined" ? !1 : e instanceof AbortSignal;
	},
	parse: {
		sync(e, r) {
			return e.aborted ? { reason: r.parse(e.reason) } : {};
		},
		async async(e, r) {
			if (e.aborted) return { reason: await r.parse(e.reason) };
			let a = await c(e);
			return { reason: await r.parse(a) };
		},
		stream(e, r) {
			if (e.aborted) return { reason: r.parse(e.reason) };
			let a = c(e);
			return {
				factory: r.parse(i),
				controller: r.parse(a)
			};
		}
	},
	serialize(e, r) {
		return e.reason ? "AbortSignal.abort(" + r.serialize(e.reason) + ")" : e.controller && e.factory ? "(" + r.serialize(e.factory) + ")(" + r.serialize(e.controller) + ").signal" : "(new AbortController).signal";
	},
	deserialize(e, r) {
		return e.reason ? AbortSignal.abort(r.deserialize(e.reason)) : e.controller ? u(r.deserialize(e.controller)).signal : new AbortController().signal;
	}
});
var B = ni({
	tag: "seroval-plugins/web/Blob",
	test(e) {
		return typeof Blob == "undefined" ? !1 : e instanceof Blob;
	},
	parse: { async async(e, r) {
		return {
			type: await r.parse(e.type),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new Blob([" + r.serialize(e.buffer) + "],{type:" + r.serialize(e.type) + "})";
	},
	deserialize(e, r) {
		return new Blob([r.deserialize(e.buffer)], { type: r.deserialize(e.type) });
	}
});
function d(e) {
	return {
		detail: e.detail,
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var L = ni({
	tag: "seroval-plugins/web/CustomEvent",
	test(e) {
		return typeof CustomEvent == "undefined" ? !1 : e instanceof CustomEvent;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(d(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(d(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(d(e))
			};
		}
	},
	serialize(e, r) {
		return "new CustomEvent(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new CustomEvent(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var q = ni({
	tag: "seroval-plugins/web/DOMException",
	test(e) {
		return typeof DOMException == "undefined" ? !1 : e instanceof DOMException;
	},
	parse: {
		sync(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		},
		async async(e, r) {
			return {
				name: await r.parse(e.name),
				message: await r.parse(e.message)
			};
		},
		stream(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		}
	},
	serialize(e, r) {
		return "new DOMException(" + r.serialize(e.message) + "," + r.serialize(e.name) + ")";
	},
	deserialize(e, r) {
		return new DOMException(r.deserialize(e.message), r.deserialize(e.name));
	}
});
function f(e) {
	return {
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var Y = ni({
	tag: "seroval-plugins/web/Event",
	test(e) {
		return typeof Event == "undefined" ? !1 : e instanceof Event;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(f(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		}
	},
	serialize(e, r) {
		return "new Event(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Event(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var m = ni({
	tag: "seroval-plugins/web/File",
	test(e) {
		return typeof File == "undefined" ? !1 : e instanceof File;
	},
	parse: { async async(e, r) {
		return {
			name: await r.parse(e.name),
			options: await r.parse({
				type: e.type,
				lastModified: e.lastModified
			}),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new File([" + r.serialize(e.buffer) + "]," + r.serialize(e.name) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new File([r.deserialize(e.buffer)], r.deserialize(e.name), r.deserialize(e.options));
	}
});
function y(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var o = {}, v = (e, r = new FormData(), a = 0, t = e.length, s) => {
	for (; a < t; a++) s = e[a], r.append(s[0], s[1]);
	return r;
}, K = ni({
	tag: "seroval-plugins/web/FormData",
	extends: [m, ni({
		tag: "seroval-plugins/web/FormDataFactory",
		test(e) {
			return e === o;
		},
		parse: {
			sync() {
				return o;
			},
			async async() {
				return await Promise.resolve(o);
			},
			stream() {
				return o;
			}
		},
		serialize() {
			return v.toString();
		},
		deserialize() {
			return o;
		}
	})],
	test(e) {
		return typeof FormData == "undefined" ? !1 : e instanceof FormData;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(o),
				entries: r.parse(y(e))
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(o),
				entries: await r.parse(y(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(o),
				entries: r.parse(y(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.entries) + ")";
	},
	deserialize(e, r) {
		return v(r.deserialize(e.entries));
	}
});
function g(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var l = ni({
	tag: "seroval-plugins/web/Headers",
	test(e) {
		return typeof Headers == "undefined" ? !1 : e instanceof Headers;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(g(e)) };
		},
		async async(e, r) {
			return { value: await r.parse(g(e)) };
		},
		stream(e, r) {
			return { value: r.parse(g(e)) };
		}
	},
	serialize(e, r) {
		return "new Headers(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new Headers(r.deserialize(e.value));
	}
});
var $ = ni({
	tag: "seroval-plugins/web/ImageData",
	test(e) {
		return typeof ImageData == "undefined" ? !1 : e instanceof ImageData;
	},
	parse: {
		sync(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		},
		async async(e, r) {
			return {
				data: await r.parse(e.data),
				width: await r.parse(e.width),
				height: await r.parse(e.height),
				options: await r.parse({ colorSpace: e.colorSpace })
			};
		},
		stream(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		}
	},
	serialize(e, r) {
		return "new ImageData(" + r.serialize(e.data) + "," + r.serialize(e.width) + "," + r.serialize(e.height) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new ImageData(r.deserialize(e.data), r.deserialize(e.width), r.deserialize(e.height), r.deserialize(e.options));
	}
});
var n = {}, P = (e) => new ReadableStream({ start: (r) => {
	e.on({
		next: (a) => {
			try {
				r.enqueue(a);
			} catch (t) {}
		},
		throw: (a) => {
			r.error(a);
		},
		return: () => {
			try {
				r.close();
			} catch (a) {}
		}
	});
} }), x = ni({
	tag: "seroval-plugins/web/ReadableStreamFactory",
	test(e) {
		return e === n;
	},
	parse: {
		sync() {
			return n;
		},
		async async() {
			return await Promise.resolve(n);
		},
		stream() {
			return n;
		}
	},
	serialize() {
		return P.toString();
	},
	deserialize() {
		return n;
	}
});
function w(e) {
	let r = te$1(), a = e.getReader();
	async function t() {
		try {
			let s = await a.read();
			s.done ? r.return(s.value) : (r.next(s.value), await t());
		} catch (s) {
			r.throw(s);
		}
	}
	return t().catch(() => {}), r;
}
var p = ni({
	tag: "seroval/plugins/web/ReadableStream",
	extends: [x],
	test(e) {
		return typeof ReadableStream == "undefined" ? !1 : e instanceof ReadableStream;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(n),
				stream: r.parse(te$1())
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(n),
				stream: await r.parse(w(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(n),
				stream: r.parse(w(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.stream) + ")";
	},
	deserialize(e, r) {
		return P(r.deserialize(e.stream));
	}
});
function N(e, r) {
	return {
		body: r,
		cache: e.cache,
		credentials: e.credentials,
		headers: e.headers,
		integrity: e.integrity,
		keepalive: e.keepalive,
		method: e.method,
		mode: e.mode,
		redirect: e.redirect,
		referrer: e.referrer,
		referrerPolicy: e.referrerPolicy
	};
}
var te = ni({
	tag: "seroval-plugins/web/Request",
	extends: [p, l],
	test(e) {
		return typeof Request == "undefined" ? !1 : e instanceof Request;
	},
	parse: {
		async async(e, r) {
			return {
				url: await r.parse(e.url),
				options: await r.parse(N(e, e.body && !e.bodyUsed ? await e.clone().arrayBuffer() : null))
			};
		},
		stream(e, r) {
			return {
				url: r.parse(e.url),
				options: r.parse(N(e, e.body && !e.bodyUsed ? e.clone().body : null))
			};
		}
	},
	serialize(e, r) {
		return "new Request(" + r.serialize(e.url) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Request(r.deserialize(e.url), r.deserialize(e.options));
	}
});
function h(e) {
	return {
		headers: e.headers,
		status: e.status,
		statusText: e.statusText
	};
}
var ne = ni({
	tag: "seroval-plugins/web/Response",
	extends: [p, l],
	test(e) {
		return typeof Response == "undefined" ? !1 : e instanceof Response;
	},
	parse: {
		async async(e, r) {
			return {
				body: await r.parse(e.body && !e.bodyUsed ? await e.clone().arrayBuffer() : null),
				options: await r.parse(h(e))
			};
		},
		stream(e, r) {
			return {
				body: r.parse(e.body && !e.bodyUsed ? e.clone().body : null),
				options: r.parse(h(e))
			};
		}
	},
	serialize(e, r) {
		return "new Response(" + r.serialize(e.body) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Response(r.deserialize(e.body), r.deserialize(e.options));
	}
});
var pe = ni({
	tag: "seroval-plugins/web/URL",
	test(e) {
		return typeof URL == "undefined" ? !1 : e instanceof URL;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(e.href) };
		},
		async async(e, r) {
			return { value: await r.parse(e.href) };
		},
		stream(e, r) {
			return { value: r.parse(e.href) };
		}
	},
	serialize(e, r) {
		return "new URL(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new URL(r.deserialize(e.value));
	}
});
var fe = ni({
	tag: "seroval-plugins/web/URLSearchParams",
	test(e) {
		return typeof URLSearchParams == "undefined" ? !1 : e instanceof URLSearchParams;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(e.toString()) };
		},
		async async(e, r) {
			return { value: await r.parse(e.toString()) };
		},
		stream(e, r) {
			return { value: r.parse(e.toString()) };
		}
	},
	serialize(e, r) {
		return "new URLSearchParams(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new URLSearchParams(r.deserialize(e.value));
	}
});

//#endregion
//#region node_modules/solid-js/web/dist/server.js
const booleans = [
	"allowfullscreen",
	"async",
	"alpha",
	"autofocus",
	"autoplay",
	"checked",
	"controls",
	"default",
	"disabled",
	"formnovalidate",
	"hidden",
	"indeterminate",
	"inert",
	"ismap",
	"loop",
	"multiple",
	"muted",
	"nomodule",
	"novalidate",
	"open",
	"playsinline",
	"readonly",
	"required",
	"reversed",
	"seamless",
	"selected",
	"adauctionheaders",
	"browsingtopics",
	"credentialless",
	"defaultchecked",
	"defaultmuted",
	"defaultselected",
	"defer",
	"disablepictureinpicture",
	"disableremoteplayback",
	"preservespitch",
	"shadowrootclonable",
	"shadowrootcustomelementregistry",
	"shadowrootdelegatesfocus",
	"shadowrootserializable",
	"sharedstoragewritable"
];
const BooleanAttributes = /* @__PURE__ */ new Set(booleans);
const Properties = /* @__PURE__ */ new Set([
	"className",
	"value",
	"readOnly",
	"noValidate",
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"adAuctionHeaders",
	"allowFullscreen",
	"browsingTopics",
	"defaultChecked",
	"defaultMuted",
	"defaultSelected",
	"disablePictureInPicture",
	"disableRemotePlayback",
	"preservesPitch",
	"shadowRootClonable",
	"shadowRootCustomElementRegistry",
	"shadowRootDelegatesFocus",
	"shadowRootSerializable",
	"sharedStorageWritable",
	...booleans
]);
const ChildProperties = /* @__PURE__ */ new Set([
	"innerHTML",
	"textContent",
	"innerText",
	"children"
]);
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
const ES2017FLAG = L$1.AggregateError | L$1.BigIntTypedArray;
const VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
function ssr(t, ...nodes) {
	if (nodes.length) {
		let result = "";
		for (let i$1 = 0; i$1 < nodes.length; i$1++) {
			result += t[i$1];
			const node = nodes[i$1];
			if (node !== void 0) result += resolveSSRNode(node);
		}
		t = result + t[nodes.length];
	}
	return { t };
}
function ssrClassList(value) {
	if (!value) return "";
	let classKeys = Object.keys(value), result = "";
	for (let i$1 = 0, len = classKeys.length; i$1 < len; i$1++) {
		const key = classKeys[i$1], classValue = !!value[key];
		if (!key || key === "undefined" || !classValue) continue;
		i$1 && (result += " ");
		result += escape(key);
	}
	return result;
}
function ssrStyle(value) {
	if (!value) return "";
	if (typeof value === "string") return escape(value, true);
	let result = "";
	const k = Object.keys(value);
	for (let i$1 = 0; i$1 < k.length; i$1++) {
		const s = k[i$1];
		const v$2 = value[s];
		if (v$2 != void 0) {
			if (i$1) result += ";";
			const r = escape(v$2, true);
			if (r != void 0 && r !== "undefined") result += \`\${s}:\${r}\`;
		}
	}
	return result;
}
function ssrStyleProperty(name, value) {
	return value != null ? name + value : "";
}
function ssrElement(tag, props, children$1, needsId) {
	if (props == null) props = {};
	else if (typeof props === "function") props = props();
	const skipChildren = VOID_ELEMENTS.test(tag);
	const keys = Object.keys(props);
	let result = \`<\${tag}\${needsId ? ssrHydrationKey() : ""} \`;
	let classResolved;
	for (let i$1 = 0; i$1 < keys.length; i$1++) {
		const prop = keys[i$1];
		if (ChildProperties.has(prop)) {
			if (children$1 === void 0 && !skipChildren) children$1 = tag === "script" || tag === "style" || prop === "innerHTML" ? props[prop] : escape(props[prop]);
			continue;
		}
		const value = props[prop];
		if (prop === "style") result += \`style="\${ssrStyle(value)}"\`;
		else if (prop === "class" || prop === "className" || prop === "classList") {
			if (classResolved) continue;
			let n$1;
			result += \`class="\${escape(((n$1 = props.class) ? n$1 + " " : "") + ((n$1 = props.className) ? n$1 + " " : ""), true) + ssrClassList(props.classList)}"\`;
			classResolved = true;
		} else if (BooleanAttributes.has(prop)) if (value) result += prop;
		else continue;
		else if (value == void 0 || prop === "ref" || prop.slice(0, 2) === "on" || prop.slice(0, 5) === "prop:") continue;
		else if (prop.slice(0, 5) === "bool:") {
			if (!value) continue;
			result += escape(prop.slice(5));
		} else if (prop.slice(0, 5) === "attr:") result += \`\${escape(prop.slice(5))}="\${escape(value, true)}"\`;
		else result += \`\${Aliases[prop] || escape(prop)}="\${escape(value, true)}"\`;
		if (i$1 !== keys.length - 1) result += " ";
	}
	if (skipChildren) return { t: result + "/>" };
	if (typeof children$1 === "function") children$1 = children$1();
	return { t: result + \`>\${resolveSSRNode(children$1, true)}</\${tag}>\` };
}
function ssrHydrationKey() {
	const hk = getHydrationKey();
	return hk ? \` data-hk="\${hk}"\` : "";
}
function escape(s, attr) {
	const t = typeof s;
	if (t !== "string") {
		if (!attr && t === "function") return escape(s());
		if (!attr && Array.isArray(s)) {
			s = s.slice();
			for (let i$1 = 0; i$1 < s.length; i$1++) s[i$1] = escape(s[i$1]);
			return s;
		}
		if (attr && t === "boolean") return String(s);
		return s;
	}
	const delim = attr ? "\\"" : "<";
	const escDelim = attr ? "&quot;" : "&lt;";
	let iDelim = s.indexOf(delim);
	let iAmp = s.indexOf("&");
	if (iDelim < 0 && iAmp < 0) return s;
	let left = 0, out = "";
	while (iDelim >= 0 && iAmp >= 0) if (iDelim < iAmp) {
		if (left < iDelim) out += s.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s.indexOf(delim, left);
	} else {
		if (left < iAmp) out += s.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s.indexOf("&", left);
	}
	if (iDelim >= 0) do {
		if (left < iDelim) out += s.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s.indexOf(delim, left);
	} while (iDelim >= 0);
	else while (iAmp >= 0) {
		if (left < iAmp) out += s.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s.indexOf("&", left);
	}
	return left < s.length ? out + s.substring(left) : out;
}
function resolveSSRNode(node, top) {
	const t = typeof node;
	if (t === "string") return node;
	if (node == null || t === "boolean") return "";
	if (Array.isArray(node)) {
		let prev = {};
		let mapped = "";
		for (let i$1 = 0, len = node.length; i$1 < len; i$1++) {
			if (!top && typeof prev !== "object" && typeof node[i$1] !== "object") mapped += \`<!--!$-->\`;
			mapped += resolveSSRNode(prev = node[i$1]);
		}
		return mapped;
	}
	if (t === "object") return node.t;
	if (t === "function") return resolveSSRNode(node());
	return String(node);
}
function getHydrationKey() {
	const hydrate = sharedConfig.context;
	return hydrate && !hydrate.noHydrate && sharedConfig.getNextContextId();
}
function NoHydration(props) {
	if (sharedConfig.context) sharedConfig.context.noHydrate = true;
	return props.children;
}

//#endregion
//#region tests/fixtures/templates.tsx
var _tmpl$ = ["<svg", " width=\\"100\\" height=\\"100\\"><circle cx=\\"50\\" cy=\\"50\\" r=\\"40\\" fill=\\"red\\"></circle><foreignObject x=\\"10\\" y=\\"10\\" width=\\"80\\" height=\\"80\\"><div><p>HTML content inside SVG</p></div></foreignObject></svg>"], _tmpl$2 = ["<div", "><svg><g><rect x=\\"0\\" y=\\"0\\" width=\\"100\\" height=\\"100\\"></rect></g></svg></div>"], _tmpl$3 = ["<div", "><button>Click me</button><div>Hover me</div><input><form><select><option value=\\"1\\">Option 1</option><option value=\\"2\\">Option 2</option></select></form></div>"], _tmpl$4 = [
	"<div",
	" class=\\"container\\"><h1>Title</h1><!--$-->",
	"<!--/--><ul>",
	"</ul><div style=\\"",
	"\\">Styled content</div></div>"
], _tmpl$5 = ["<p", ">Conditional content</p>"], _tmpl$6 = [
	"<li",
	">",
	"</li>"
], _tmpl$7 = ["<div", " id=\\"test\\" class=\\"my-class\\" data-testid=\\"element\\" aria-label=\\"Accessible element\\" role=\\"button\\" tabindex=\\"0\\"><img src=\\"test.jpg\\" alt=\\"test image\\" width=\\"100\\" height=\\"100\\"><input type=\\"text\\" placeholder=\\"Enter text\\" required></div>"], _tmpl$8 = ["<svg", " width=\\"100\\" height=\\"100\\"><circle cx=\\"50\\" cy=\\"50\\" r=\\"40\\" fill=\\"red\\"></circle><rect x=\\"10\\" y=\\"10\\" width=\\"30\\" height=\\"30\\" fill=\\"blue\\"></rect><text x=\\"50\\" y=\\"50\\" text-anchor=\\"middle\\">SVG Text</text></svg>"], _tmpl$9 = "<head><title>SSR Test</title><meta charset=\\"utf-8\\"><meta name=\\"viewport\\" content=\\"width=device-width\\"></head>", _tmpl$0 = ["<div", "><script>console.log('test');<\\/script><style>body { margin: 0; }</style></div>"], _tmpl$1 = [
	"<div",
	"><p>Static content</p><div>",
	"</div><ul>",
	"</ul></div>"
], _tmpl$10 = [
	"<li",
	">Item <!--$-->",
	"<!--/--></li>"
], _tmpl$11 = ["<table", "><thead><tr><th>Header 1</th><th>Header 2</th></tr></thead><tbody><tr><td>Cell 1</td><td>Cell 2</td></tr></tbody></table>"], _tmpl$12 = ["<div", "><section><article><header><h1>Title</h1></header><main><p>Content</p></main><footer><small>Footer</small></footer></article></section><table><tr><td>Cell 1</td><td>Cell 2</td></tr></table><img src=\\"test.jpg\\" alt=\\"test\\"><br><hr></div>"];
function TestSvgWrap() {
	return ssr(_tmpl$, ssrHydrationKey());
}
function TestNestedSvg() {
	return ssr(_tmpl$2, ssrHydrationKey());
}
function TestEventDelegation() {
	return ssr(_tmpl$3, ssrHydrationKey());
}
function TestComplexTemplates() {
	return ssr(_tmpl$4, ssrHydrationKey(), _tmpl$5[0] + ssrHydrationKey() + _tmpl$5[1], escape([
		"a",
		"b",
		"c"
	].map((item) => ssr(_tmpl$6, ssrHydrationKey(), escape(item)))), ssrStyleProperty("color:", "red") + ssrStyleProperty(";font-size:", "16px"));
}
function TestAttributeTemplates() {
	return ssr(_tmpl$7, ssrHydrationKey());
}
function TestSVGTemplates() {
	return ssr(_tmpl$8, ssrHydrationKey());
}
function TestSSRHeadElement() {
	return createComponent(NoHydration, { get children() {
		return ssr(_tmpl$9);
	} });
}
function TestSSRScriptStyle() {
	return ssr(_tmpl$0, ssrHydrationKey());
}
function TestSSRHydration() {
	return ssr(_tmpl$1, ssrHydrationKey(), \`Dynamic content: \${escape(Date.now())}\`, escape([
		1,
		2,
		3
	].map((item) => ssr(_tmpl$10, ssrHydrationKey(), escape(item)))));
}
function TestSSRSpreadAttributes() {
	return ssrElement("div", {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	}, () => "Spread attributes", true);
}
function TestSSRSpecialElements() {
	return ssr(_tmpl$11, ssrHydrationKey());
}
function TestValidationScenarios() {
	return ssr(_tmpl$12, ssrHydrationKey());
}

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid dist should transform templates with hydratable SSR 1`] = `
"//#region node_modules/solid-js/dist/server.js
const ERROR = Symbol("error");
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function handleError(err, owner = Owner) {
	const fns = owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	try {
		for (const f$1 of fns) f$1(error);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
let Owner = null;
function createOwner() {
	const o$2 = {
		owner: Owner,
		context: Owner ? Owner.context : null,
		owned: null,
		cleanups: null
	};
	if (Owner) if (!Owner.owned) Owner.owned = [o$2];
	else Owner.owned.push(o$2);
	return o$2;
}
function createMemo(fn, value) {
	Owner = createOwner();
	let v$2;
	try {
		v$2 = fn(value);
	} catch (err) {
		handleError(err);
	} finally {
		Owner = Owner.owner;
	}
	return () => v$2;
}
function createContext(defaultValue) {
	const id = Symbol("context");
	return {
		id,
		Provider: createProvider(id),
		defaultValue
	};
}
function children(fn) {
	const memo = createMemo(() => resolveChildren(fn()));
	memo.toArray = () => {
		const c$2 = memo();
		return Array.isArray(c$2) ? c$2 : c$2 != null ? [c$2] : [];
	};
	return memo;
}
function resolveChildren(children$1) {
	if (typeof children$1 === "function" && !children$1.length) return resolveChildren(children$1());
	if (Array.isArray(children$1)) {
		const results = [];
		for (let i$1 = 0; i$1 < children$1.length; i$1++) {
			const result = resolveChildren(children$1[i$1]);
			Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
		}
		return results;
	}
	return children$1;
}
function createProvider(id) {
	return function provider(props) {
		return createMemo(() => {
			Owner.context = {
				...Owner.context,
				[id]: props.value
			};
			return children(() => props.children);
		});
	};
}
const sharedConfig = {
	context: void 0,
	getContextId() {
		if (!this.context) throw new Error(\`getContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count);
	},
	getNextContextId() {
		if (!this.context) throw new Error(\`getNextContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
	sharedConfig.context = context;
}
function nextHydrateContext() {
	return sharedConfig.context ? {
		...sharedConfig.context,
		id: sharedConfig.getNextContextId(),
		count: 0
	} : void 0;
}
function createComponent(Comp, props) {
	if (sharedConfig.context && !sharedConfig.context.noHydrate) {
		const c$2 = sharedConfig.context;
		setHydrateContext(nextHydrateContext());
		const r = Comp(props || {});
		setHydrateContext(c$2);
		return r;
	}
	return Comp(props || {});
}
const SuspenseContext = createContext();

//#endregion
//#region node_modules/seroval/dist/esm/production/index.mjs
var L$1 = ((i$1) => (i$1[i$1.AggregateError = 1] = "AggregateError", i$1[i$1.ArrowFunction = 2] = "ArrowFunction", i$1[i$1.ErrorPrototypeStack = 4] = "ErrorPrototypeStack", i$1[i$1.ObjectAssign = 8] = "ObjectAssign", i$1[i$1.BigIntTypedArray = 16] = "BigIntTypedArray", i$1[i$1.RegExp = 32] = "RegExp", i$1))(L$1 || {});
var v$1 = Symbol.asyncIterator, mr = Symbol.hasInstance, R = Symbol.isConcatSpreadable, C = Symbol.iterator, pr = Symbol.match, dr = Symbol.matchAll, gr = Symbol.replace, yr = Symbol.search, Nr = Symbol.species, br = Symbol.split, vr = Symbol.toPrimitive, P$1 = Symbol.toStringTag, Cr = Symbol.unscopables;
var rt = {
	0: "Symbol.asyncIterator",
	1: "Symbol.hasInstance",
	2: "Symbol.isConcatSpreadable",
	3: "Symbol.iterator",
	4: "Symbol.match",
	5: "Symbol.matchAll",
	6: "Symbol.replace",
	7: "Symbol.search",
	8: "Symbol.species",
	9: "Symbol.split",
	10: "Symbol.toPrimitive",
	11: "Symbol.toStringTag",
	12: "Symbol.unscopables"
}, ve = {
	[v$1]: 0,
	[mr]: 1,
	[R]: 2,
	[C]: 3,
	[pr]: 4,
	[dr]: 5,
	[gr]: 6,
	[yr]: 7,
	[Nr]: 8,
	[br]: 9,
	[vr]: 10,
	[P$1]: 11,
	[Cr]: 12
}, tt = {
	0: v$1,
	1: mr,
	2: R,
	3: C,
	4: pr,
	5: dr,
	6: gr,
	7: yr,
	8: Nr,
	9: br,
	10: vr,
	11: P$1,
	12: Cr
}, nt = {
	2: "!0",
	3: "!1",
	1: "void 0",
	0: "null",
	4: "-0",
	5: "1/0",
	6: "-1/0",
	7: "0/0"
}, o$1 = void 0, ot = {
	2: !0,
	3: !1,
	1: o$1,
	0: null,
	4: -0,
	5: Number.POSITIVE_INFINITY,
	6: Number.NEGATIVE_INFINITY,
	7: NaN
};
function c$1(e, r, t, n$1, a, s, i$1, u$1, l$1, g$1, S, d$1) {
	return {
		t: e,
		i: r,
		s: t,
		c: n$1,
		m: a,
		p: s,
		e: i$1,
		a: u$1,
		f: l$1,
		b: g$1,
		o: S,
		l: d$1
	};
}
function F(e) {
	return c$1(2, o$1, e, o$1, o$1, o$1, o$1, o$1, o$1, o$1, o$1, o$1);
}
var J = F(2), Z = F(3), Ae = F(1), Ee = F(0), st = F(4), it = F(5), ut = F(6), lt = F(7);
var U = "__SEROVAL_REFS__", ce = "$R", Ie = \`self.\${ce}\`;
var Ar = /* @__PURE__ */ new Map(), j = /* @__PURE__ */ new Map();
typeof globalThis != "undefined" ? Object.defineProperty(globalThis, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof window != "undefined" ? Object.defineProperty(window, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof self != "undefined" ? Object.defineProperty(self, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof global != "undefined" && Object.defineProperty(global, U, {
	value: j,
	configurable: !0,
	writable: !1,
	enumerable: !1
});
var { toString: ys } = Object.prototype;
var re = () => {
	let e = {
		p: 0,
		s: 0,
		f: 0
	};
	return e.p = new Promise((r, t) => {
		e.s = r, e.f = t;
	}), e;
}, vn = (e, r) => {
	e.s(r), e.p.s = 1, e.p.v = r;
}, Cn = (e, r) => {
	e.f(r), e.p.s = 2, e.p.v = r;
}, yt = re.toString(), Nt = vn.toString(), bt = Cn.toString(), Rr = () => {
	let e = [], r = [], t = !0, n$1 = !1, a = 0, s = (l$1, g$1, S) => {
		for (S = 0; S < a; S++) r[S] && r[S][g$1](l$1);
	}, i$1 = (l$1, g$1, S, d$1) => {
		for (g$1 = 0, S = e.length; g$1 < S; g$1++) d$1 = e[g$1], !t && g$1 === S - 1 ? l$1[n$1 ? "return" : "throw"](d$1) : l$1.next(d$1);
	}, u$1 = (l$1, g$1) => (t && (g$1 = a++, r[g$1] = l$1), i$1(l$1), () => {
		t && (r[g$1] = r[a], r[a--] = void 0);
	});
	return {
		__SEROVAL_STREAM__: !0,
		on: (l$1) => u$1(l$1),
		next: (l$1) => {
			t && (e.push(l$1), s(l$1, "next"));
		},
		throw: (l$1) => {
			t && (e.push(l$1), s(l$1, "throw"), t = !1, n$1 = !1, r.length = 0);
		},
		return: (l$1) => {
			t && (e.push(l$1), s(l$1, "return"), t = !1, n$1 = !0, r.length = 0);
		}
	};
}, vt = Rr.toString(), Pr = (e) => (r) => () => {
	let t = 0, n$1 = {
		[e]: () => n$1,
		next: () => {
			if (t > r.d) return {
				done: !0,
				value: void 0
			};
			let a = t++, s = r.v[a];
			if (a === r.t) throw s;
			return {
				done: a === r.d,
				value: s
			};
		}
	};
	return n$1;
}, Ct = Pr.toString(), xr = (e, r) => (t) => () => {
	let n$1 = 0, a = -1, s = !1, i$1 = [], u$1 = [], l$1 = (S = 0, d$1 = u$1.length) => {
		for (; S < d$1; S++) u$1[S].s({
			done: !0,
			value: void 0
		});
	};
	t.on({
		next: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.s({
				done: !1,
				value: S
			}), i$1.push(S);
		},
		throw: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.f(S), l$1(), a = i$1.length, s = !0, i$1.push(S);
		},
		return: (S) => {
			let d$1 = u$1.shift();
			d$1 && d$1.s({
				done: !0,
				value: S
			}), l$1(), a = i$1.length, i$1.push(S);
		}
	});
	let g$1 = {
		[e]: () => g$1,
		next: () => {
			if (a === -1) {
				let K$1 = n$1++;
				if (K$1 >= i$1.length) {
					let et = r();
					return u$1.push(et), et.p;
				}
				return {
					done: !1,
					value: i$1[K$1]
				};
			}
			if (n$1 > a) return {
				done: !0,
				value: void 0
			};
			let S = n$1++, d$1 = i$1[S];
			if (S !== a) return {
				done: !1,
				value: d$1
			};
			if (s) throw d$1;
			return {
				done: !0,
				value: d$1
			};
		}
	};
	return g$1;
}, At = xr.toString(), Or = (e) => {
	let r = atob(e), t = r.length, n$1 = new Uint8Array(t);
	for (let a = 0; a < t; a++) n$1[a] = r.charCodeAt(a);
	return n$1.buffer;
}, Et = Or.toString();
var An = Pr(C);
function te$1() {
	return Rr();
}
var En = xr(v$1, re);
var ae = ((t) => (t[t.Vanilla = 1] = "Vanilla", t[t.Cross = 2] = "Cross", t))(ae || {});
function ni(e) {
	return e;
}
var Eo = () => T, Io = Eo.toString(), qt = /=>/.test(Io);
var Ht = "hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_", Gt = Ht.length, Jt = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_", Kt = Jt.length;

//#endregion
//#region node_modules/seroval-plugins/dist/esm/production/web.mjs
var u = (e) => {
	let r = new AbortController(), a = r.abort.bind(r);
	return e.then(a, a), r;
};
function E(e) {
	e(this.reason);
}
function D(e) {
	this.addEventListener("abort", E.bind(this, e), { once: !0 });
}
function c(e) {
	return new Promise(D.bind(e));
}
var i = {}, O = ni({
	tag: "seroval-plugins/web/AbortSignal",
	extends: [ni({
		tag: "seroval-plugins/web/AbortControllerFactoryPlugin",
		test(e) {
			return e === i;
		},
		parse: {
			sync() {
				return i;
			},
			async async() {
				return await Promise.resolve(i);
			},
			stream() {
				return i;
			}
		},
		serialize() {
			return u.toString();
		},
		deserialize() {
			return u;
		}
	})],
	test(e) {
		return typeof AbortSignal == "undefined" ? !1 : e instanceof AbortSignal;
	},
	parse: {
		sync(e, r) {
			return e.aborted ? { reason: r.parse(e.reason) } : {};
		},
		async async(e, r) {
			if (e.aborted) return { reason: await r.parse(e.reason) };
			let a = await c(e);
			return { reason: await r.parse(a) };
		},
		stream(e, r) {
			if (e.aborted) return { reason: r.parse(e.reason) };
			let a = c(e);
			return {
				factory: r.parse(i),
				controller: r.parse(a)
			};
		}
	},
	serialize(e, r) {
		return e.reason ? "AbortSignal.abort(" + r.serialize(e.reason) + ")" : e.controller && e.factory ? "(" + r.serialize(e.factory) + ")(" + r.serialize(e.controller) + ").signal" : "(new AbortController).signal";
	},
	deserialize(e, r) {
		return e.reason ? AbortSignal.abort(r.deserialize(e.reason)) : e.controller ? u(r.deserialize(e.controller)).signal : new AbortController().signal;
	}
});
var B = ni({
	tag: "seroval-plugins/web/Blob",
	test(e) {
		return typeof Blob == "undefined" ? !1 : e instanceof Blob;
	},
	parse: { async async(e, r) {
		return {
			type: await r.parse(e.type),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new Blob([" + r.serialize(e.buffer) + "],{type:" + r.serialize(e.type) + "})";
	},
	deserialize(e, r) {
		return new Blob([r.deserialize(e.buffer)], { type: r.deserialize(e.type) });
	}
});
function d(e) {
	return {
		detail: e.detail,
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var L = ni({
	tag: "seroval-plugins/web/CustomEvent",
	test(e) {
		return typeof CustomEvent == "undefined" ? !1 : e instanceof CustomEvent;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(d(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(d(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(d(e))
			};
		}
	},
	serialize(e, r) {
		return "new CustomEvent(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new CustomEvent(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var q = ni({
	tag: "seroval-plugins/web/DOMException",
	test(e) {
		return typeof DOMException == "undefined" ? !1 : e instanceof DOMException;
	},
	parse: {
		sync(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		},
		async async(e, r) {
			return {
				name: await r.parse(e.name),
				message: await r.parse(e.message)
			};
		},
		stream(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		}
	},
	serialize(e, r) {
		return "new DOMException(" + r.serialize(e.message) + "," + r.serialize(e.name) + ")";
	},
	deserialize(e, r) {
		return new DOMException(r.deserialize(e.message), r.deserialize(e.name));
	}
});
function f(e) {
	return {
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var Y = ni({
	tag: "seroval-plugins/web/Event",
	test(e) {
		return typeof Event == "undefined" ? !1 : e instanceof Event;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(f(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		}
	},
	serialize(e, r) {
		return "new Event(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Event(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var m = ni({
	tag: "seroval-plugins/web/File",
	test(e) {
		return typeof File == "undefined" ? !1 : e instanceof File;
	},
	parse: { async async(e, r) {
		return {
			name: await r.parse(e.name),
			options: await r.parse({
				type: e.type,
				lastModified: e.lastModified
			}),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new File([" + r.serialize(e.buffer) + "]," + r.serialize(e.name) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new File([r.deserialize(e.buffer)], r.deserialize(e.name), r.deserialize(e.options));
	}
});
function y(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var o = {}, v = (e, r = new FormData(), a = 0, t = e.length, s) => {
	for (; a < t; a++) s = e[a], r.append(s[0], s[1]);
	return r;
}, K = ni({
	tag: "seroval-plugins/web/FormData",
	extends: [m, ni({
		tag: "seroval-plugins/web/FormDataFactory",
		test(e) {
			return e === o;
		},
		parse: {
			sync() {
				return o;
			},
			async async() {
				return await Promise.resolve(o);
			},
			stream() {
				return o;
			}
		},
		serialize() {
			return v.toString();
		},
		deserialize() {
			return o;
		}
	})],
	test(e) {
		return typeof FormData == "undefined" ? !1 : e instanceof FormData;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(o),
				entries: r.parse(y(e))
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(o),
				entries: await r.parse(y(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(o),
				entries: r.parse(y(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.entries) + ")";
	},
	deserialize(e, r) {
		return v(r.deserialize(e.entries));
	}
});
function g(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var l = ni({
	tag: "seroval-plugins/web/Headers",
	test(e) {
		return typeof Headers == "undefined" ? !1 : e instanceof Headers;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(g(e)) };
		},
		async async(e, r) {
			return { value: await r.parse(g(e)) };
		},
		stream(e, r) {
			return { value: r.parse(g(e)) };
		}
	},
	serialize(e, r) {
		return "new Headers(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new Headers(r.deserialize(e.value));
	}
});
var $ = ni({
	tag: "seroval-plugins/web/ImageData",
	test(e) {
		return typeof ImageData == "undefined" ? !1 : e instanceof ImageData;
	},
	parse: {
		sync(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		},
		async async(e, r) {
			return {
				data: await r.parse(e.data),
				width: await r.parse(e.width),
				height: await r.parse(e.height),
				options: await r.parse({ colorSpace: e.colorSpace })
			};
		},
		stream(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		}
	},
	serialize(e, r) {
		return "new ImageData(" + r.serialize(e.data) + "," + r.serialize(e.width) + "," + r.serialize(e.height) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new ImageData(r.deserialize(e.data), r.deserialize(e.width), r.deserialize(e.height), r.deserialize(e.options));
	}
});
var n = {}, P = (e) => new ReadableStream({ start: (r) => {
	e.on({
		next: (a) => {
			try {
				r.enqueue(a);
			} catch (t) {}
		},
		throw: (a) => {
			r.error(a);
		},
		return: () => {
			try {
				r.close();
			} catch (a) {}
		}
	});
} }), x = ni({
	tag: "seroval-plugins/web/ReadableStreamFactory",
	test(e) {
		return e === n;
	},
	parse: {
		sync() {
			return n;
		},
		async async() {
			return await Promise.resolve(n);
		},
		stream() {
			return n;
		}
	},
	serialize() {
		return P.toString();
	},
	deserialize() {
		return n;
	}
});
function w(e) {
	let r = te$1(), a = e.getReader();
	async function t() {
		try {
			let s = await a.read();
			s.done ? r.return(s.value) : (r.next(s.value), await t());
		} catch (s) {
			r.throw(s);
		}
	}
	return t().catch(() => {}), r;
}
var p = ni({
	tag: "seroval/plugins/web/ReadableStream",
	extends: [x],
	test(e) {
		return typeof ReadableStream == "undefined" ? !1 : e instanceof ReadableStream;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(n),
				stream: r.parse(te$1())
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(n),
				stream: await r.parse(w(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(n),
				stream: r.parse(w(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.stream) + ")";
	},
	deserialize(e, r) {
		return P(r.deserialize(e.stream));
	}
});
function N(e, r) {
	return {
		body: r,
		cache: e.cache,
		credentials: e.credentials,
		headers: e.headers,
		integrity: e.integrity,
		keepalive: e.keepalive,
		method: e.method,
		mode: e.mode,
		redirect: e.redirect,
		referrer: e.referrer,
		referrerPolicy: e.referrerPolicy
	};
}
var te = ni({
	tag: "seroval-plugins/web/Request",
	extends: [p, l],
	test(e) {
		return typeof Request == "undefined" ? !1 : e instanceof Request;
	},
	parse: {
		async async(e, r) {
			return {
				url: await r.parse(e.url),
				options: await r.parse(N(e, e.body && !e.bodyUsed ? await e.clone().arrayBuffer() : null))
			};
		},
		stream(e, r) {
			return {
				url: r.parse(e.url),
				options: r.parse(N(e, e.body && !e.bodyUsed ? e.clone().body : null))
			};
		}
	},
	serialize(e, r) {
		return "new Request(" + r.serialize(e.url) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Request(r.deserialize(e.url), r.deserialize(e.options));
	}
});
function h(e) {
	return {
		headers: e.headers,
		status: e.status,
		statusText: e.statusText
	};
}
var ne = ni({
	tag: "seroval-plugins/web/Response",
	extends: [p, l],
	test(e) {
		return typeof Response == "undefined" ? !1 : e instanceof Response;
	},
	parse: {
		async async(e, r) {
			return {
				body: await r.parse(e.body && !e.bodyUsed ? await e.clone().arrayBuffer() : null),
				options: await r.parse(h(e))
			};
		},
		stream(e, r) {
			return {
				body: r.parse(e.body && !e.bodyUsed ? e.clone().body : null),
				options: r.parse(h(e))
			};
		}
	},
	serialize(e, r) {
		return "new Response(" + r.serialize(e.body) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Response(r.deserialize(e.body), r.deserialize(e.options));
	}
});
var pe = ni({
	tag: "seroval-plugins/web/URL",
	test(e) {
		return typeof URL == "undefined" ? !1 : e instanceof URL;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(e.href) };
		},
		async async(e, r) {
			return { value: await r.parse(e.href) };
		},
		stream(e, r) {
			return { value: r.parse(e.href) };
		}
	},
	serialize(e, r) {
		return "new URL(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new URL(r.deserialize(e.value));
	}
});
var fe = ni({
	tag: "seroval-plugins/web/URLSearchParams",
	test(e) {
		return typeof URLSearchParams == "undefined" ? !1 : e instanceof URLSearchParams;
	},
	parse: {
		sync(e, r) {
			return { value: r.parse(e.toString()) };
		},
		async async(e, r) {
			return { value: await r.parse(e.toString()) };
		},
		stream(e, r) {
			return { value: r.parse(e.toString()) };
		}
	},
	serialize(e, r) {
		return "new URLSearchParams(" + r.serialize(e.value) + ")";
	},
	deserialize(e, r) {
		return new URLSearchParams(r.deserialize(e.value));
	}
});

//#endregion
//#region node_modules/solid-js/web/dist/server.js
const booleans = [
	"allowfullscreen",
	"async",
	"alpha",
	"autofocus",
	"autoplay",
	"checked",
	"controls",
	"default",
	"disabled",
	"formnovalidate",
	"hidden",
	"indeterminate",
	"inert",
	"ismap",
	"loop",
	"multiple",
	"muted",
	"nomodule",
	"novalidate",
	"open",
	"playsinline",
	"readonly",
	"required",
	"reversed",
	"seamless",
	"selected",
	"adauctionheaders",
	"browsingtopics",
	"credentialless",
	"defaultchecked",
	"defaultmuted",
	"defaultselected",
	"defer",
	"disablepictureinpicture",
	"disableremoteplayback",
	"preservespitch",
	"shadowrootclonable",
	"shadowrootcustomelementregistry",
	"shadowrootdelegatesfocus",
	"shadowrootserializable",
	"sharedstoragewritable"
];
const BooleanAttributes = /* @__PURE__ */ new Set(booleans);
const Properties = /* @__PURE__ */ new Set([
	"className",
	"value",
	"readOnly",
	"noValidate",
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"adAuctionHeaders",
	"allowFullscreen",
	"browsingTopics",
	"defaultChecked",
	"defaultMuted",
	"defaultSelected",
	"disablePictureInPicture",
	"disableRemotePlayback",
	"preservesPitch",
	"shadowRootClonable",
	"shadowRootCustomElementRegistry",
	"shadowRootDelegatesFocus",
	"shadowRootSerializable",
	"sharedStorageWritable",
	...booleans
]);
const ChildProperties = /* @__PURE__ */ new Set([
	"innerHTML",
	"textContent",
	"innerText",
	"children"
]);
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
const ES2017FLAG = L$1.AggregateError | L$1.BigIntTypedArray;
const VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
function ssr(t, ...nodes) {
	if (nodes.length) {
		let result = "";
		for (let i$1 = 0; i$1 < nodes.length; i$1++) {
			result += t[i$1];
			const node = nodes[i$1];
			if (node !== void 0) result += resolveSSRNode(node);
		}
		t = result + t[nodes.length];
	}
	return { t };
}
function ssrClassList(value) {
	if (!value) return "";
	let classKeys = Object.keys(value), result = "";
	for (let i$1 = 0, len = classKeys.length; i$1 < len; i$1++) {
		const key = classKeys[i$1], classValue = !!value[key];
		if (!key || key === "undefined" || !classValue) continue;
		i$1 && (result += " ");
		result += escape(key);
	}
	return result;
}
function ssrStyle(value) {
	if (!value) return "";
	if (typeof value === "string") return escape(value, true);
	let result = "";
	const k = Object.keys(value);
	for (let i$1 = 0; i$1 < k.length; i$1++) {
		const s = k[i$1];
		const v$2 = value[s];
		if (v$2 != void 0) {
			if (i$1) result += ";";
			const r = escape(v$2, true);
			if (r != void 0 && r !== "undefined") result += \`\${s}:\${r}\`;
		}
	}
	return result;
}
function ssrStyleProperty(name, value) {
	return value != null ? name + value : "";
}
function ssrElement(tag, props, children$1, needsId) {
	if (props == null) props = {};
	else if (typeof props === "function") props = props();
	const skipChildren = VOID_ELEMENTS.test(tag);
	const keys = Object.keys(props);
	let result = \`<\${tag}\${needsId ? ssrHydrationKey() : ""} \`;
	let classResolved;
	for (let i$1 = 0; i$1 < keys.length; i$1++) {
		const prop = keys[i$1];
		if (ChildProperties.has(prop)) {
			if (children$1 === void 0 && !skipChildren) children$1 = tag === "script" || tag === "style" || prop === "innerHTML" ? props[prop] : escape(props[prop]);
			continue;
		}
		const value = props[prop];
		if (prop === "style") result += \`style="\${ssrStyle(value)}"\`;
		else if (prop === "class" || prop === "className" || prop === "classList") {
			if (classResolved) continue;
			let n$1;
			result += \`class="\${escape(((n$1 = props.class) ? n$1 + " " : "") + ((n$1 = props.className) ? n$1 + " " : ""), true) + ssrClassList(props.classList)}"\`;
			classResolved = true;
		} else if (BooleanAttributes.has(prop)) if (value) result += prop;
		else continue;
		else if (value == void 0 || prop === "ref" || prop.slice(0, 2) === "on" || prop.slice(0, 5) === "prop:") continue;
		else if (prop.slice(0, 5) === "bool:") {
			if (!value) continue;
			result += escape(prop.slice(5));
		} else if (prop.slice(0, 5) === "attr:") result += \`\${escape(prop.slice(5))}="\${escape(value, true)}"\`;
		else result += \`\${Aliases[prop] || escape(prop)}="\${escape(value, true)}"\`;
		if (i$1 !== keys.length - 1) result += " ";
	}
	if (skipChildren) return { t: result + "/>" };
	if (typeof children$1 === "function") children$1 = children$1();
	return { t: result + \`>\${resolveSSRNode(children$1, true)}</\${tag}>\` };
}
function ssrHydrationKey() {
	const hk = getHydrationKey();
	return hk ? \` data-hk="\${hk}"\` : "";
}
function escape(s, attr) {
	const t = typeof s;
	if (t !== "string") {
		if (!attr && t === "function") return escape(s());
		if (!attr && Array.isArray(s)) {
			s = s.slice();
			for (let i$1 = 0; i$1 < s.length; i$1++) s[i$1] = escape(s[i$1]);
			return s;
		}
		if (attr && t === "boolean") return String(s);
		return s;
	}
	const delim = attr ? "\\"" : "<";
	const escDelim = attr ? "&quot;" : "&lt;";
	let iDelim = s.indexOf(delim);
	let iAmp = s.indexOf("&");
	if (iDelim < 0 && iAmp < 0) return s;
	let left = 0, out = "";
	while (iDelim >= 0 && iAmp >= 0) if (iDelim < iAmp) {
		if (left < iDelim) out += s.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s.indexOf(delim, left);
	} else {
		if (left < iAmp) out += s.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s.indexOf("&", left);
	}
	if (iDelim >= 0) do {
		if (left < iDelim) out += s.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s.indexOf(delim, left);
	} while (iDelim >= 0);
	else while (iAmp >= 0) {
		if (left < iAmp) out += s.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s.indexOf("&", left);
	}
	return left < s.length ? out + s.substring(left) : out;
}
function resolveSSRNode(node, top) {
	const t = typeof node;
	if (t === "string") return node;
	if (node == null || t === "boolean") return "";
	if (Array.isArray(node)) {
		let prev = {};
		let mapped = "";
		for (let i$1 = 0, len = node.length; i$1 < len; i$1++) {
			if (!top && typeof prev !== "object" && typeof node[i$1] !== "object") mapped += \`<!--!$-->\`;
			mapped += resolveSSRNode(prev = node[i$1]);
		}
		return mapped;
	}
	if (t === "object") return node.t;
	if (t === "function") return resolveSSRNode(node());
	return String(node);
}
function getHydrationKey() {
	const hydrate = sharedConfig.context;
	return hydrate && !hydrate.noHydrate && sharedConfig.getNextContextId();
}
function NoHydration(props) {
	if (sharedConfig.context) sharedConfig.context.noHydrate = true;
	return props.children;
}

//#endregion
//#region tests/fixtures/templates.tsx
var _tmpl$ = ["<svg", " width=\\"100\\" height=\\"100\\"><circle cx=\\"50\\" cy=\\"50\\" r=\\"40\\" fill=\\"red\\"></circle><foreignObject x=\\"10\\" y=\\"10\\" width=\\"80\\" height=\\"80\\"><div><p>HTML content inside SVG</p></div></foreignObject></svg>"], _tmpl$2 = ["<div", "><svg><g><rect x=\\"0\\" y=\\"0\\" width=\\"100\\" height=\\"100\\"></rect></g></svg></div>"], _tmpl$3 = ["<div", "><button>Click me</button><div>Hover me</div><input><form><select><option value=\\"1\\">Option 1</option><option value=\\"2\\">Option 2</option></select></form></div>"], _tmpl$4 = [
	"<div",
	" class=\\"container\\"><h1>Title</h1><!--$-->",
	"<!--/--><ul>",
	"</ul><div style=\\"",
	"\\">Styled content</div></div>"
], _tmpl$5 = ["<p", ">Conditional content</p>"], _tmpl$6 = [
	"<li",
	">",
	"</li>"
], _tmpl$7 = ["<div", " id=\\"test\\" class=\\"my-class\\" data-testid=\\"element\\" aria-label=\\"Accessible element\\" role=\\"button\\" tabindex=\\"0\\"><img src=\\"test.jpg\\" alt=\\"test image\\" width=\\"100\\" height=\\"100\\"><input type=\\"text\\" placeholder=\\"Enter text\\" required></div>"], _tmpl$8 = ["<svg", " width=\\"100\\" height=\\"100\\"><circle cx=\\"50\\" cy=\\"50\\" r=\\"40\\" fill=\\"red\\"></circle><rect x=\\"10\\" y=\\"10\\" width=\\"30\\" height=\\"30\\" fill=\\"blue\\"></rect><text x=\\"50\\" y=\\"50\\" text-anchor=\\"middle\\">SVG Text</text></svg>"], _tmpl$9 = "<head><title>SSR Test</title><meta charset=\\"utf-8\\"><meta name=\\"viewport\\" content=\\"width=device-width\\"></head>", _tmpl$0 = ["<div", "><script>console.log('test');<\\/script><style>body { margin: 0; }</style></div>"], _tmpl$1 = [
	"<div",
	"><p>Static content</p><div>",
	"</div><ul>",
	"</ul></div>"
], _tmpl$10 = [
	"<li",
	">Item <!--$-->",
	"<!--/--></li>"
], _tmpl$11 = ["<table", "><thead><tr><th>Header 1</th><th>Header 2</th></tr></thead><tbody><tr><td>Cell 1</td><td>Cell 2</td></tr></tbody></table>"], _tmpl$12 = ["<div", "><section><article><header><h1>Title</h1></header><main><p>Content</p></main><footer><small>Footer</small></footer></article></section><table><tr><td>Cell 1</td><td>Cell 2</td></tr></table><img src=\\"test.jpg\\" alt=\\"test\\"><br><hr></div>"];
function TestSvgWrap() {
	return ssr(_tmpl$, ssrHydrationKey());
}
function TestNestedSvg() {
	return ssr(_tmpl$2, ssrHydrationKey());
}
function TestEventDelegation() {
	return ssr(_tmpl$3, ssrHydrationKey());
}
function TestComplexTemplates() {
	return ssr(_tmpl$4, ssrHydrationKey(), _tmpl$5[0] + ssrHydrationKey() + _tmpl$5[1], escape([
		"a",
		"b",
		"c"
	].map((item) => ssr(_tmpl$6, ssrHydrationKey(), escape(item)))), ssrStyleProperty("color:", "red") + ssrStyleProperty(";font-size:", "16px"));
}
function TestAttributeTemplates() {
	return ssr(_tmpl$7, ssrHydrationKey());
}
function TestSVGTemplates() {
	return ssr(_tmpl$8, ssrHydrationKey());
}
function TestSSRHeadElement() {
	return createComponent(NoHydration, { get children() {
		return ssr(_tmpl$9);
	} });
}
function TestSSRScriptStyle() {
	return ssr(_tmpl$0, ssrHydrationKey());
}
function TestSSRHydration() {
	return ssr(_tmpl$1, ssrHydrationKey(), \`Dynamic content: \${escape(Date.now())}\`, escape([
		1,
		2,
		3
	].map((item) => ssr(_tmpl$10, ssrHydrationKey(), escape(item)))));
}
function TestSSRSpreadAttributes() {
	return ssrElement("div", {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	}, () => "Spread attributes", true);
}
function TestSSRSpecialElements() {
	return ssr(_tmpl$11, ssrHydrationKey());
}
function TestValidationScenarios() {
	return ssr(_tmpl$12, ssrHydrationKey());
}

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid src should transform templates with universal and hydratable 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
	sharedConfig.context = context;
}
function nextHydrateContext() {
	return {
		...sharedConfig.context,
		id: sharedConfig.getNextContextId(),
		count: 0
	};
}
const equalFn = (a, b) => a === b;
const $PROXY = Symbol("solid-proxy");
const SUPPORTS_PROXY = typeof Proxy === "function";
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
	const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
		owned: null,
		cleanups: null,
		context: current ? current.context : null,
		owner: current
	}, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
	Owner = root;
	Listener = null;
	try {
		return runUpdates(updateFn, true);
	} finally {
		Listener = listener;
		Owner = owner;
	}
}
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function createMemo(fn, value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const c = createComputation(fn, value, true, 0);
	c.observers = null;
	c.observerSlots = null;
	c.comparator = options.equals || void 0;
	if (Scheduler && Transition && Transition.running) {
		c.tState = STALE;
		Updates.push(c);
	} else updateComputation(c);
	return readSignal.bind(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}
let hydrationEnabled = false;
function createComponent$1(Comp, props) {
	if (hydrationEnabled) {
		if (sharedConfig.context) {
			const c = sharedConfig.context;
			setHydrateContext(nextHydrateContext());
			const r = untrack(() => Comp(props || {}));
			setHydrateContext(c);
			return r;
		}
	}
	return untrack(() => Comp(props || {}));
}
function trueFn() {
	return true;
}
const propTraps = {
	get(_, property, receiver) {
		if (property === $PROXY) return receiver;
		return _.get(property);
	},
	has(_, property) {
		if (property === $PROXY) return true;
		return _.has(property);
	},
	set: trueFn,
	deleteProperty: trueFn,
	getOwnPropertyDescriptor(_, property) {
		return {
			configurable: true,
			enumerable: true,
			get() {
				return _.get(property);
			},
			set: trueFn,
			deleteProperty: trueFn
		};
	},
	ownKeys(_) {
		return _.keys();
	}
};
function resolveSource(s) {
	return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
	for (let i = 0, length = this.length; i < length; ++i) {
		const v = this[i]();
		if (v !== void 0) return v;
	}
}
function mergeProps$1(...sources) {
	let proxy = false;
	for (let i = 0; i < sources.length; i++) {
		const s = sources[i];
		proxy = proxy || !!s && $PROXY in s;
		sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
	}
	if (SUPPORTS_PROXY && proxy) return new Proxy({
		get(property) {
			for (let i = sources.length - 1; i >= 0; i--) {
				const v = resolveSource(sources[i])[property];
				if (v !== void 0) return v;
			}
		},
		has(property) {
			for (let i = sources.length - 1; i >= 0; i--) if (property in resolveSource(sources[i])) return true;
			return false;
		},
		keys() {
			const keys = [];
			for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));
			return [...new Set(keys)];
		}
	}, propTraps);
	const sourcesMap = {};
	const defined = Object.create(null);
	for (let i = sources.length - 1; i >= 0; i--) {
		const source = sources[i];
		if (!source) continue;
		const sourceKeys = Object.getOwnPropertyNames(source);
		for (let i$1 = sourceKeys.length - 1; i$1 >= 0; i$1--) {
			const key = sourceKeys[i$1];
			if (key === "__proto__" || key === "constructor") continue;
			const desc = Object.getOwnPropertyDescriptor(source, key);
			if (!defined[key]) defined[key] = desc.get ? {
				enumerable: true,
				configurable: true,
				get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
			} : desc.value !== void 0 ? desc : void 0;
			else {
				const sources$1 = sourcesMap[key];
				if (sources$1) {
					if (desc.get) sources$1.push(desc.get.bind(source));
					else if (desc.value !== void 0) sources$1.push(() => desc.value);
				}
			}
		}
	}
	const target = {};
	const definedKeys = Object.keys(defined);
	for (let i = definedKeys.length - 1; i >= 0; i--) {
		const key = definedKeys[i], desc = defined[key];
		if (desc && desc.get) Object.defineProperty(target, key, desc);
		else target[key] = desc ? desc.value : void 0;
	}
	return target;
}

//#endregion
//#region node_modules/solid-js/universal/dist/universal.js
const memo$1 = (fn) => createMemo(() => fn());
function createRenderer$1({ createElement: createElement$1, createTextNode: createTextNode$1, isTextNode, replaceText, insertNode: insertNode$1, removeNode, setProperty, getParentNode, getFirstChild, getNextSibling }) {
	function insert$1(parent, accessor, marker, initial) {
		if (marker !== void 0 && !initial) initial = [];
		if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
		createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
	}
	function insertExpression(parent, value, current, marker, unwrapArray) {
		while (typeof current === "function") current = current();
		if (value === current) return current;
		const t = typeof value, multi = marker !== void 0;
		if (t === "string" || t === "number") {
			if (t === "number") value = value.toString();
			if (multi) {
				let node = current[0];
				if (node && isTextNode(node)) replaceText(node, value);
				else node = createTextNode$1(value);
				current = cleanChildren(parent, current, marker, node);
			} else if (current !== "" && typeof current === "string") replaceText(getFirstChild(parent), current = value);
			else {
				cleanChildren(parent, current, marker, createTextNode$1(value));
				current = value;
			}
		} else if (value == null || t === "boolean") current = cleanChildren(parent, current, marker);
		else if (t === "function") {
			createRenderEffect(() => {
				let v = value();
				while (typeof v === "function") v = v();
				current = insertExpression(parent, v, current, marker);
			});
			return () => current;
		} else if (Array.isArray(value)) {
			const array = [];
			if (normalizeIncomingArray(array, value, unwrapArray)) {
				createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
				return () => current;
			}
			if (array.length === 0) {
				const replacement = cleanChildren(parent, current, marker);
				if (multi) return current = replacement;
			} else if (Array.isArray(current)) if (current.length === 0) appendNodes(parent, array, marker);
			else reconcileArrays(parent, current, array);
			else if (current == null || current === "") appendNodes(parent, array);
			else reconcileArrays(parent, multi && current || [getFirstChild(parent)], array);
			current = array;
		} else {
			if (Array.isArray(current)) {
				if (multi) return current = cleanChildren(parent, current, marker, value);
				cleanChildren(parent, current, null, value);
			} else if (current == null || current === "" || !getFirstChild(parent)) insertNode$1(parent, value);
			else replaceNode(parent, value, getFirstChild(parent));
			current = value;
		}
		return current;
	}
	function normalizeIncomingArray(normalized, array, unwrap) {
		let dynamic = false;
		for (let i = 0, len = array.length; i < len; i++) {
			let item = array[i], t;
			if (item == null || item === true || item === false);
			else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item) || dynamic;
			else if ((t = typeof item) === "string" || t === "number") normalized.push(createTextNode$1(item));
			else if (t === "function") if (unwrap) {
				while (typeof item === "function") item = item();
				dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;
			} else {
				normalized.push(item);
				dynamic = true;
			}
			else normalized.push(item);
		}
		return dynamic;
	}
	function reconcileArrays(parentNode, a, b) {
		let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = getNextSibling(a[aEnd - 1]), map = null;
		while (aStart < aEnd || bStart < bEnd) {
			if (a[aStart] === b[bStart]) {
				aStart++;
				bStart++;
				continue;
			}
			while (a[aEnd - 1] === b[bEnd - 1]) {
				aEnd--;
				bEnd--;
			}
			if (aEnd === aStart) {
				const node = bEnd < bLength ? bStart ? getNextSibling(b[bStart - 1]) : b[bEnd - bStart] : after;
				while (bStart < bEnd) insertNode$1(parentNode, b[bStart++], node);
			} else if (bEnd === bStart) while (aStart < aEnd) {
				if (!map || !map.has(a[aStart])) removeNode(parentNode, a[aStart]);
				aStart++;
			}
			else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
				const node = getNextSibling(a[--aEnd]);
				insertNode$1(parentNode, b[bStart++], getNextSibling(a[aStart++]));
				insertNode$1(parentNode, b[--bEnd], node);
				a[aEnd] = b[bEnd];
			} else {
				if (!map) {
					map = /* @__PURE__ */ new Map();
					let i = bStart;
					while (i < bEnd) map.set(b[i], i++);
				}
				const index = map.get(a[aStart]);
				if (index != null) if (bStart < index && index < bEnd) {
					let i = aStart, sequence = 1, t;
					while (++i < aEnd && i < bEnd) {
						if ((t = map.get(a[i])) == null || t !== index + sequence) break;
						sequence++;
					}
					if (sequence > index - bStart) {
						const node = a[aStart];
						while (bStart < index) insertNode$1(parentNode, b[bStart++], node);
					} else replaceNode(parentNode, b[bStart++], a[aStart++]);
				} else aStart++;
				else removeNode(parentNode, a[aStart++]);
			}
		}
	}
	function cleanChildren(parent, current, marker, replacement) {
		if (marker === void 0) {
			let removed;
			while (removed = getFirstChild(parent)) removeNode(parent, removed);
			replacement && insertNode$1(parent, replacement);
			return "";
		}
		const node = replacement || createTextNode$1("");
		if (current.length) {
			let inserted = false;
			for (let i = current.length - 1; i >= 0; i--) {
				const el = current[i];
				if (node !== el) {
					const isParent = getParentNode(el) === parent;
					if (!inserted && !i) isParent ? replaceNode(parent, node, el) : insertNode$1(parent, node, marker);
					else isParent && removeNode(parent, el);
				} else inserted = true;
			}
		} else insertNode$1(parent, node, marker);
		return [node];
	}
	function appendNodes(parent, array, marker) {
		for (let i = 0, len = array.length; i < len; i++) insertNode$1(parent, array[i], marker);
	}
	function replaceNode(parent, newNode, oldNode) {
		insertNode$1(parent, newNode, oldNode);
		removeNode(parent, oldNode);
	}
	function spreadExpression(node, props, prevProps = {}, skipChildren) {
		props || (props = {});
		if (!skipChildren) createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
		createRenderEffect(() => props.ref && props.ref(node));
		createRenderEffect(() => {
			for (const prop in props) {
				if (prop === "children" || prop === "ref") continue;
				const value = props[prop];
				if (value === prevProps[prop]) continue;
				setProperty(node, prop, value, prevProps[prop]);
				prevProps[prop] = value;
			}
		});
		return prevProps;
	}
	return {
		render(code, element) {
			let disposer;
			createRoot((dispose) => {
				disposer = dispose;
				insert$1(element, code());
			});
			return disposer;
		},
		insert: insert$1,
		spread(node, accessor, skipChildren) {
			if (typeof accessor === "function") createRenderEffect((current) => spreadExpression(node, accessor(), current, skipChildren));
			else spreadExpression(node, accessor, void 0, skipChildren);
		},
		createElement: createElement$1,
		createTextNode: createTextNode$1,
		insertNode: insertNode$1,
		setProp(node, name, value, prev) {
			setProperty(node, name, value, prev);
			return value;
		},
		mergeProps: mergeProps$1,
		effect: createRenderEffect,
		memo: memo$1,
		createComponent: createComponent$1,
		use(fn, element, arg) {
			return untrack(() => fn(element, arg));
		}
	};
}
function createRenderer(options) {
	const renderer = createRenderer$1(options);
	renderer.mergeProps = mergeProps$1;
	return renderer;
}

//#endregion
//#region tests/helpers/universal-mode-renderer.ts
const { createComponent, createElement, createTextNode, effect, insert, insertNode, memo, mergeProps, render, setProp, spread, use } = createRenderer({
	createElement() {},
	createTextNode() {},
	getFirstChild() {},
	getNextSibling() {},
	getParentNode() {},
	insertNode() {},
	isTextNode() {
		return true;
	},
	removeNode() {},
	replaceText() {},
	setProperty() {}
});

//#endregion
//#region tests/fixtures/templates.tsx
function TestSvgWrap() {
	return (() => {
		var _el$ = createElement("svg"), _el$2 = createElement("circle"), _el$3 = createElement("foreignObject"), _el$4 = createElement("div"), _el$5 = createElement("p");
		insertNode(_el$, _el$2);
		insertNode(_el$, _el$3);
		setProp(_el$, "width", "100");
		setProp(_el$, "height", "100");
		setProp(_el$2, "cx", "50");
		setProp(_el$2, "cy", "50");
		setProp(_el$2, "r", "40");
		setProp(_el$2, "fill", "red");
		insertNode(_el$3, _el$4);
		setProp(_el$3, "x", "10");
		setProp(_el$3, "y", "10");
		setProp(_el$3, "width", "80");
		setProp(_el$3, "height", "80");
		insertNode(_el$4, _el$5);
		insertNode(_el$5, createTextNode(\`HTML content inside SVG\`));
		return _el$;
	})();
}
function TestNestedSvg() {
	return (() => {
		var _el$7 = createElement("div"), _el$8 = createElement("svg"), _el$9 = createElement("g"), _el$0 = createElement("rect");
		insertNode(_el$7, _el$8);
		insertNode(_el$8, _el$9);
		insertNode(_el$9, _el$0);
		setProp(_el$0, "x", "0");
		setProp(_el$0, "y", "0");
		setProp(_el$0, "width", "100");
		setProp(_el$0, "height", "100");
		return _el$7;
	})();
}
function TestEventDelegation() {
	return (() => {
		var _el$1 = createElement("div"), _el$10 = createElement("button"), _el$12 = createElement("div"), _el$14 = createElement("input"), _el$15 = createElement("form"), _el$16 = createElement("select"), _el$17 = createElement("option"), _el$19 = createElement("option");
		insertNode(_el$1, _el$10);
		insertNode(_el$1, _el$12);
		insertNode(_el$1, _el$14);
		insertNode(_el$1, _el$15);
		insertNode(_el$10, createTextNode(\`Click me\`));
		setProp(_el$10, "onClick", () => console.log("click"));
		insertNode(_el$12, createTextNode(\`Hover me\`));
		setProp(_el$12, "onMouseOver", () => console.log("hover"));
		setProp(_el$14, "onInput", (e) => console.log(e.target.value));
		insertNode(_el$15, _el$16);
		setProp(_el$15, "onSubmit", (e) => e.preventDefault());
		insertNode(_el$16, _el$17);
		insertNode(_el$16, _el$19);
		setProp(_el$16, "onChange", (e) => console.log(e.target.value));
		insertNode(_el$17, createTextNode(\`Option 1\`));
		setProp(_el$17, "value", "1");
		insertNode(_el$19, createTextNode(\`Option 2\`));
		setProp(_el$19, "value", "2");
		return _el$1;
	})();
}
function TestComplexTemplates() {
	const items = [
		"a",
		"b",
		"c"
	];
	return (() => {
		var _el$21 = createElement("div"), _el$22 = createElement("h1"), _el$24 = createElement("ul"), _el$25 = createElement("div");
		insertNode(_el$21, _el$22);
		insertNode(_el$21, _el$24);
		insertNode(_el$21, _el$25);
		setProp(_el$21, "class", "container");
		insertNode(_el$22, createTextNode(\`Title\`));
		insert(_el$21, (() => {
			var _el$27 = createElement("p");
			insertNode(_el$27, createTextNode(\`Conditional content\`));
			return _el$27;
		})(), _el$24);
		insert(_el$24, () => items.map((item) => (() => {
			var _el$29 = createElement("li");
			insert(_el$29, item);
			return _el$29;
		})()));
		insertNode(_el$25, createTextNode(\`Styled content\`));
		setProp(_el$25, "style", {
			color: "red",
			"font-size": "16px"
		});
		return _el$21;
	})();
}
function TestAttributeTemplates() {
	return (() => {
		var _el$30 = createElement("div"), _el$31 = createElement("img"), _el$32 = createElement("input");
		insertNode(_el$30, _el$31);
		insertNode(_el$30, _el$32);
		setProp(_el$30, "id", "test");
		setProp(_el$30, "class", "my-class");
		setProp(_el$30, "data-testid", "element");
		setProp(_el$30, "aria-label", "Accessible element");
		setProp(_el$30, "role", "button");
		setProp(_el$30, "tabIndex", 0);
		setProp(_el$31, "src", "test.jpg");
		setProp(_el$31, "alt", "test image");
		setProp(_el$31, "width", "100");
		setProp(_el$31, "height", "100");
		setProp(_el$32, "type", "text");
		setProp(_el$32, "placeholder", "Enter text");
		setProp(_el$32, "required", true);
		setProp(_el$32, "disabled", false);
		return _el$30;
	})();
}
function TestSVGTemplates() {
	return (() => {
		var _el$33 = createElement("svg"), _el$34 = createElement("circle"), _el$35 = createElement("rect"), _el$36 = createElement("text");
		insertNode(_el$33, _el$34);
		insertNode(_el$33, _el$35);
		insertNode(_el$33, _el$36);
		setProp(_el$33, "width", "100");
		setProp(_el$33, "height", "100");
		setProp(_el$34, "cx", "50");
		setProp(_el$34, "cy", "50");
		setProp(_el$34, "r", "40");
		setProp(_el$34, "fill", "red");
		setProp(_el$35, "x", "10");
		setProp(_el$35, "y", "10");
		setProp(_el$35, "width", "30");
		setProp(_el$35, "height", "30");
		setProp(_el$35, "fill", "blue");
		insertNode(_el$36, createTextNode(\`SVG Text\`));
		setProp(_el$36, "x", "50");
		setProp(_el$36, "y", "50");
		setProp(_el$36, "text-anchor", "middle");
		return _el$33;
	})();
}
function TestSSRHeadElement() {
	return (() => {
		var _el$38 = createElement("head"), _el$39 = createElement("title"), _el$41 = createElement("meta"), _el$42 = createElement("meta");
		insertNode(_el$38, _el$39);
		insertNode(_el$38, _el$41);
		insertNode(_el$38, _el$42);
		insertNode(_el$39, createTextNode(\`SSR Test\`));
		setProp(_el$41, "charset", "utf-8");
		setProp(_el$42, "name", "viewport");
		setProp(_el$42, "content", "width=device-width");
		return _el$38;
	})();
}
function TestSSRScriptStyle() {
	return (() => {
		var _el$43 = createElement("div"), _el$44 = createElement("script"), _el$46 = createElement("style");
		insertNode(_el$43, _el$44);
		insertNode(_el$43, _el$46);
		insertNode(_el$44, createTextNode(\`console.log('test');\`));
		insertNode(_el$46, createTextNode(\`body \\{ margin: 0; }\`));
		return _el$43;
	})();
}
function TestSSRHydration() {
	return (() => {
		var _el$48 = createElement("div"), _el$49 = createElement("p"), _el$51 = createElement("div"), _el$52 = createElement("ul");
		insertNode(_el$48, _el$49);
		insertNode(_el$48, _el$51);
		insertNode(_el$48, _el$52);
		insertNode(_el$49, createTextNode(\`Static content\`));
		insert(_el$51, () => \`Dynamic content: \${Date.now()}\`);
		insert(_el$52, () => [
			1,
			2,
			3
		].map((item) => (() => {
			var _el$53 = createElement("li");
			insertNode(_el$53, createTextNode(\`Item \`));
			insert(_el$53, item, null);
			return _el$53;
		})()));
		return _el$48;
	})();
}
function TestSSRSpreadAttributes() {
	const props = {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	};
	return (() => {
		var _el$55 = createElement("div");
		insertNode(_el$55, createTextNode(\`Spread attributes\`));
		spread(_el$55, props, true);
		return _el$55;
	})();
}
function TestSSRSpecialElements() {
	return (() => {
		var _el$57 = createElement("table"), _el$58 = createElement("thead"), _el$59 = createElement("tr"), _el$60 = createElement("th"), _el$62 = createElement("th"), _el$64 = createElement("tbody"), _el$65 = createElement("tr"), _el$66 = createElement("td"), _el$68 = createElement("td");
		insertNode(_el$57, _el$58);
		insertNode(_el$57, _el$64);
		insertNode(_el$58, _el$59);
		insertNode(_el$59, _el$60);
		insertNode(_el$59, _el$62);
		insertNode(_el$60, createTextNode(\`Header 1\`));
		insertNode(_el$62, createTextNode(\`Header 2\`));
		insertNode(_el$64, _el$65);
		insertNode(_el$65, _el$66);
		insertNode(_el$65, _el$68);
		insertNode(_el$66, createTextNode(\`Cell 1\`));
		insertNode(_el$68, createTextNode(\`Cell 2\`));
		return _el$57;
	})();
}
function TestValidationScenarios() {
	return (() => {
		var _el$70 = createElement("div"), _el$71 = createElement("section"), _el$72 = createElement("article"), _el$73 = createElement("header"), _el$74 = createElement("h1"), _el$76 = createElement("main"), _el$77 = createElement("p"), _el$79 = createElement("footer"), _el$80 = createElement("small"), _el$82 = createElement("table"), _el$83 = createElement("tr"), _el$84 = createElement("td"), _el$86 = createElement("td"), _el$88 = createElement("img"), _el$89 = createElement("br"), _el$90 = createElement("hr");
		insertNode(_el$70, _el$71);
		insertNode(_el$70, _el$82);
		insertNode(_el$70, _el$88);
		insertNode(_el$70, _el$89);
		insertNode(_el$70, _el$90);
		insertNode(_el$71, _el$72);
		insertNode(_el$72, _el$73);
		insertNode(_el$72, _el$76);
		insertNode(_el$72, _el$79);
		insertNode(_el$73, _el$74);
		insertNode(_el$74, createTextNode(\`Title\`));
		insertNode(_el$76, _el$77);
		insertNode(_el$77, createTextNode(\`Content\`));
		insertNode(_el$79, _el$80);
		insertNode(_el$80, createTextNode(\`Footer\`));
		insertNode(_el$82, _el$83);
		insertNode(_el$83, _el$84);
		insertNode(_el$83, _el$86);
		insertNode(_el$84, createTextNode(\`Cell 1\`));
		insertNode(_el$86, createTextNode(\`Cell 2\`));
		setProp(_el$88, "src", "test.jpg");
		setProp(_el$88, "alt", "test");
		return _el$70;
	})();
}

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;

exports[`rolldown-plugin-solid dist should transform templates with universal and hydratable 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
	sharedConfig.context = context;
}
function nextHydrateContext() {
	return {
		...sharedConfig.context,
		id: sharedConfig.getNextContextId(),
		count: 0
	};
}
const equalFn = (a, b) => a === b;
const $PROXY = Symbol("solid-proxy");
const SUPPORTS_PROXY = typeof Proxy === "function";
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
	const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
		owned: null,
		cleanups: null,
		context: current ? current.context : null,
		owner: current
	}, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
	Owner = root;
	Listener = null;
	try {
		return runUpdates(updateFn, true);
	} finally {
		Listener = listener;
		Owner = owner;
	}
}
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function createMemo(fn, value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const c = createComputation(fn, value, true, 0);
	c.observers = null;
	c.observerSlots = null;
	c.comparator = options.equals || void 0;
	if (Scheduler && Transition && Transition.running) {
		c.tState = STALE;
		Updates.push(c);
	} else updateComputation(c);
	return readSignal.bind(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}
let hydrationEnabled = false;
function createComponent$1(Comp, props) {
	if (hydrationEnabled) {
		if (sharedConfig.context) {
			const c = sharedConfig.context;
			setHydrateContext(nextHydrateContext());
			const r = untrack(() => Comp(props || {}));
			setHydrateContext(c);
			return r;
		}
	}
	return untrack(() => Comp(props || {}));
}
function trueFn() {
	return true;
}
const propTraps = {
	get(_, property, receiver) {
		if (property === $PROXY) return receiver;
		return _.get(property);
	},
	has(_, property) {
		if (property === $PROXY) return true;
		return _.has(property);
	},
	set: trueFn,
	deleteProperty: trueFn,
	getOwnPropertyDescriptor(_, property) {
		return {
			configurable: true,
			enumerable: true,
			get() {
				return _.get(property);
			},
			set: trueFn,
			deleteProperty: trueFn
		};
	},
	ownKeys(_) {
		return _.keys();
	}
};
function resolveSource(s) {
	return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
	for (let i = 0, length = this.length; i < length; ++i) {
		const v = this[i]();
		if (v !== void 0) return v;
	}
}
function mergeProps$1(...sources) {
	let proxy = false;
	for (let i = 0; i < sources.length; i++) {
		const s = sources[i];
		proxy = proxy || !!s && $PROXY in s;
		sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
	}
	if (SUPPORTS_PROXY && proxy) return new Proxy({
		get(property) {
			for (let i = sources.length - 1; i >= 0; i--) {
				const v = resolveSource(sources[i])[property];
				if (v !== void 0) return v;
			}
		},
		has(property) {
			for (let i = sources.length - 1; i >= 0; i--) if (property in resolveSource(sources[i])) return true;
			return false;
		},
		keys() {
			const keys = [];
			for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));
			return [...new Set(keys)];
		}
	}, propTraps);
	const sourcesMap = {};
	const defined = Object.create(null);
	for (let i = sources.length - 1; i >= 0; i--) {
		const source = sources[i];
		if (!source) continue;
		const sourceKeys = Object.getOwnPropertyNames(source);
		for (let i$1 = sourceKeys.length - 1; i$1 >= 0; i$1--) {
			const key = sourceKeys[i$1];
			if (key === "__proto__" || key === "constructor") continue;
			const desc = Object.getOwnPropertyDescriptor(source, key);
			if (!defined[key]) defined[key] = desc.get ? {
				enumerable: true,
				configurable: true,
				get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
			} : desc.value !== void 0 ? desc : void 0;
			else {
				const sources$1 = sourcesMap[key];
				if (sources$1) {
					if (desc.get) sources$1.push(desc.get.bind(source));
					else if (desc.value !== void 0) sources$1.push(() => desc.value);
				}
			}
		}
	}
	const target = {};
	const definedKeys = Object.keys(defined);
	for (let i = definedKeys.length - 1; i >= 0; i--) {
		const key = definedKeys[i], desc = defined[key];
		if (desc && desc.get) Object.defineProperty(target, key, desc);
		else target[key] = desc ? desc.value : void 0;
	}
	return target;
}

//#endregion
//#region node_modules/solid-js/universal/dist/universal.js
const memo$1 = (fn) => createMemo(() => fn());
function createRenderer$1({ createElement: createElement$1, createTextNode: createTextNode$1, isTextNode, replaceText, insertNode: insertNode$1, removeNode, setProperty, getParentNode, getFirstChild, getNextSibling }) {
	function insert$1(parent, accessor, marker, initial) {
		if (marker !== void 0 && !initial) initial = [];
		if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
		createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
	}
	function insertExpression(parent, value, current, marker, unwrapArray) {
		while (typeof current === "function") current = current();
		if (value === current) return current;
		const t = typeof value, multi = marker !== void 0;
		if (t === "string" || t === "number") {
			if (t === "number") value = value.toString();
			if (multi) {
				let node = current[0];
				if (node && isTextNode(node)) replaceText(node, value);
				else node = createTextNode$1(value);
				current = cleanChildren(parent, current, marker, node);
			} else if (current !== "" && typeof current === "string") replaceText(getFirstChild(parent), current = value);
			else {
				cleanChildren(parent, current, marker, createTextNode$1(value));
				current = value;
			}
		} else if (value == null || t === "boolean") current = cleanChildren(parent, current, marker);
		else if (t === "function") {
			createRenderEffect(() => {
				let v = value();
				while (typeof v === "function") v = v();
				current = insertExpression(parent, v, current, marker);
			});
			return () => current;
		} else if (Array.isArray(value)) {
			const array = [];
			if (normalizeIncomingArray(array, value, unwrapArray)) {
				createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
				return () => current;
			}
			if (array.length === 0) {
				const replacement = cleanChildren(parent, current, marker);
				if (multi) return current = replacement;
			} else if (Array.isArray(current)) if (current.length === 0) appendNodes(parent, array, marker);
			else reconcileArrays(parent, current, array);
			else if (current == null || current === "") appendNodes(parent, array);
			else reconcileArrays(parent, multi && current || [getFirstChild(parent)], array);
			current = array;
		} else {
			if (Array.isArray(current)) {
				if (multi) return current = cleanChildren(parent, current, marker, value);
				cleanChildren(parent, current, null, value);
			} else if (current == null || current === "" || !getFirstChild(parent)) insertNode$1(parent, value);
			else replaceNode(parent, value, getFirstChild(parent));
			current = value;
		}
		return current;
	}
	function normalizeIncomingArray(normalized, array, unwrap) {
		let dynamic = false;
		for (let i = 0, len = array.length; i < len; i++) {
			let item = array[i], t;
			if (item == null || item === true || item === false);
			else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item) || dynamic;
			else if ((t = typeof item) === "string" || t === "number") normalized.push(createTextNode$1(item));
			else if (t === "function") if (unwrap) {
				while (typeof item === "function") item = item();
				dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;
			} else {
				normalized.push(item);
				dynamic = true;
			}
			else normalized.push(item);
		}
		return dynamic;
	}
	function reconcileArrays(parentNode, a, b) {
		let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = getNextSibling(a[aEnd - 1]), map = null;
		while (aStart < aEnd || bStart < bEnd) {
			if (a[aStart] === b[bStart]) {
				aStart++;
				bStart++;
				continue;
			}
			while (a[aEnd - 1] === b[bEnd - 1]) {
				aEnd--;
				bEnd--;
			}
			if (aEnd === aStart) {
				const node = bEnd < bLength ? bStart ? getNextSibling(b[bStart - 1]) : b[bEnd - bStart] : after;
				while (bStart < bEnd) insertNode$1(parentNode, b[bStart++], node);
			} else if (bEnd === bStart) while (aStart < aEnd) {
				if (!map || !map.has(a[aStart])) removeNode(parentNode, a[aStart]);
				aStart++;
			}
			else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
				const node = getNextSibling(a[--aEnd]);
				insertNode$1(parentNode, b[bStart++], getNextSibling(a[aStart++]));
				insertNode$1(parentNode, b[--bEnd], node);
				a[aEnd] = b[bEnd];
			} else {
				if (!map) {
					map = /* @__PURE__ */ new Map();
					let i = bStart;
					while (i < bEnd) map.set(b[i], i++);
				}
				const index = map.get(a[aStart]);
				if (index != null) if (bStart < index && index < bEnd) {
					let i = aStart, sequence = 1, t;
					while (++i < aEnd && i < bEnd) {
						if ((t = map.get(a[i])) == null || t !== index + sequence) break;
						sequence++;
					}
					if (sequence > index - bStart) {
						const node = a[aStart];
						while (bStart < index) insertNode$1(parentNode, b[bStart++], node);
					} else replaceNode(parentNode, b[bStart++], a[aStart++]);
				} else aStart++;
				else removeNode(parentNode, a[aStart++]);
			}
		}
	}
	function cleanChildren(parent, current, marker, replacement) {
		if (marker === void 0) {
			let removed;
			while (removed = getFirstChild(parent)) removeNode(parent, removed);
			replacement && insertNode$1(parent, replacement);
			return "";
		}
		const node = replacement || createTextNode$1("");
		if (current.length) {
			let inserted = false;
			for (let i = current.length - 1; i >= 0; i--) {
				const el = current[i];
				if (node !== el) {
					const isParent = getParentNode(el) === parent;
					if (!inserted && !i) isParent ? replaceNode(parent, node, el) : insertNode$1(parent, node, marker);
					else isParent && removeNode(parent, el);
				} else inserted = true;
			}
		} else insertNode$1(parent, node, marker);
		return [node];
	}
	function appendNodes(parent, array, marker) {
		for (let i = 0, len = array.length; i < len; i++) insertNode$1(parent, array[i], marker);
	}
	function replaceNode(parent, newNode, oldNode) {
		insertNode$1(parent, newNode, oldNode);
		removeNode(parent, oldNode);
	}
	function spreadExpression(node, props, prevProps = {}, skipChildren) {
		props || (props = {});
		if (!skipChildren) createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
		createRenderEffect(() => props.ref && props.ref(node));
		createRenderEffect(() => {
			for (const prop in props) {
				if (prop === "children" || prop === "ref") continue;
				const value = props[prop];
				if (value === prevProps[prop]) continue;
				setProperty(node, prop, value, prevProps[prop]);
				prevProps[prop] = value;
			}
		});
		return prevProps;
	}
	return {
		render(code, element) {
			let disposer;
			createRoot((dispose) => {
				disposer = dispose;
				insert$1(element, code());
			});
			return disposer;
		},
		insert: insert$1,
		spread(node, accessor, skipChildren) {
			if (typeof accessor === "function") createRenderEffect((current) => spreadExpression(node, accessor(), current, skipChildren));
			else spreadExpression(node, accessor, void 0, skipChildren);
		},
		createElement: createElement$1,
		createTextNode: createTextNode$1,
		insertNode: insertNode$1,
		setProp(node, name, value, prev) {
			setProperty(node, name, value, prev);
			return value;
		},
		mergeProps: mergeProps$1,
		effect: createRenderEffect,
		memo: memo$1,
		createComponent: createComponent$1,
		use(fn, element, arg) {
			return untrack(() => fn(element, arg));
		}
	};
}
function createRenderer(options) {
	const renderer = createRenderer$1(options);
	renderer.mergeProps = mergeProps$1;
	return renderer;
}

//#endregion
//#region tests/helpers/universal-mode-renderer.ts
const { createComponent, createElement, createTextNode, effect, insert, insertNode, memo, mergeProps, render, setProp, spread, use } = createRenderer({
	createElement() {},
	createTextNode() {},
	getFirstChild() {},
	getNextSibling() {},
	getParentNode() {},
	insertNode() {},
	isTextNode() {
		return true;
	},
	removeNode() {},
	replaceText() {},
	setProperty() {}
});

//#endregion
//#region tests/fixtures/templates.tsx
function TestSvgWrap() {
	return (() => {
		var _el$ = createElement("svg"), _el$2 = createElement("circle"), _el$3 = createElement("foreignObject"), _el$4 = createElement("div"), _el$5 = createElement("p");
		insertNode(_el$, _el$2);
		insertNode(_el$, _el$3);
		setProp(_el$, "width", "100");
		setProp(_el$, "height", "100");
		setProp(_el$2, "cx", "50");
		setProp(_el$2, "cy", "50");
		setProp(_el$2, "r", "40");
		setProp(_el$2, "fill", "red");
		insertNode(_el$3, _el$4);
		setProp(_el$3, "x", "10");
		setProp(_el$3, "y", "10");
		setProp(_el$3, "width", "80");
		setProp(_el$3, "height", "80");
		insertNode(_el$4, _el$5);
		insertNode(_el$5, createTextNode(\`HTML content inside SVG\`));
		return _el$;
	})();
}
function TestNestedSvg() {
	return (() => {
		var _el$7 = createElement("div"), _el$8 = createElement("svg"), _el$9 = createElement("g"), _el$0 = createElement("rect");
		insertNode(_el$7, _el$8);
		insertNode(_el$8, _el$9);
		insertNode(_el$9, _el$0);
		setProp(_el$0, "x", "0");
		setProp(_el$0, "y", "0");
		setProp(_el$0, "width", "100");
		setProp(_el$0, "height", "100");
		return _el$7;
	})();
}
function TestEventDelegation() {
	return (() => {
		var _el$1 = createElement("div"), _el$10 = createElement("button"), _el$12 = createElement("div"), _el$14 = createElement("input"), _el$15 = createElement("form"), _el$16 = createElement("select"), _el$17 = createElement("option"), _el$19 = createElement("option");
		insertNode(_el$1, _el$10);
		insertNode(_el$1, _el$12);
		insertNode(_el$1, _el$14);
		insertNode(_el$1, _el$15);
		insertNode(_el$10, createTextNode(\`Click me\`));
		setProp(_el$10, "onClick", () => console.log("click"));
		insertNode(_el$12, createTextNode(\`Hover me\`));
		setProp(_el$12, "onMouseOver", () => console.log("hover"));
		setProp(_el$14, "onInput", (e) => console.log(e.target.value));
		insertNode(_el$15, _el$16);
		setProp(_el$15, "onSubmit", (e) => e.preventDefault());
		insertNode(_el$16, _el$17);
		insertNode(_el$16, _el$19);
		setProp(_el$16, "onChange", (e) => console.log(e.target.value));
		insertNode(_el$17, createTextNode(\`Option 1\`));
		setProp(_el$17, "value", "1");
		insertNode(_el$19, createTextNode(\`Option 2\`));
		setProp(_el$19, "value", "2");
		return _el$1;
	})();
}
function TestComplexTemplates() {
	const items = [
		"a",
		"b",
		"c"
	];
	return (() => {
		var _el$21 = createElement("div"), _el$22 = createElement("h1"), _el$24 = createElement("ul"), _el$25 = createElement("div");
		insertNode(_el$21, _el$22);
		insertNode(_el$21, _el$24);
		insertNode(_el$21, _el$25);
		setProp(_el$21, "class", "container");
		insertNode(_el$22, createTextNode(\`Title\`));
		insert(_el$21, (() => {
			var _el$27 = createElement("p");
			insertNode(_el$27, createTextNode(\`Conditional content\`));
			return _el$27;
		})(), _el$24);
		insert(_el$24, () => items.map((item) => (() => {
			var _el$29 = createElement("li");
			insert(_el$29, item);
			return _el$29;
		})()));
		insertNode(_el$25, createTextNode(\`Styled content\`));
		setProp(_el$25, "style", {
			color: "red",
			"font-size": "16px"
		});
		return _el$21;
	})();
}
function TestAttributeTemplates() {
	return (() => {
		var _el$30 = createElement("div"), _el$31 = createElement("img"), _el$32 = createElement("input");
		insertNode(_el$30, _el$31);
		insertNode(_el$30, _el$32);
		setProp(_el$30, "id", "test");
		setProp(_el$30, "class", "my-class");
		setProp(_el$30, "data-testid", "element");
		setProp(_el$30, "aria-label", "Accessible element");
		setProp(_el$30, "role", "button");
		setProp(_el$30, "tabIndex", 0);
		setProp(_el$31, "src", "test.jpg");
		setProp(_el$31, "alt", "test image");
		setProp(_el$31, "width", "100");
		setProp(_el$31, "height", "100");
		setProp(_el$32, "type", "text");
		setProp(_el$32, "placeholder", "Enter text");
		setProp(_el$32, "required", true);
		setProp(_el$32, "disabled", false);
		return _el$30;
	})();
}
function TestSVGTemplates() {
	return (() => {
		var _el$33 = createElement("svg"), _el$34 = createElement("circle"), _el$35 = createElement("rect"), _el$36 = createElement("text");
		insertNode(_el$33, _el$34);
		insertNode(_el$33, _el$35);
		insertNode(_el$33, _el$36);
		setProp(_el$33, "width", "100");
		setProp(_el$33, "height", "100");
		setProp(_el$34, "cx", "50");
		setProp(_el$34, "cy", "50");
		setProp(_el$34, "r", "40");
		setProp(_el$34, "fill", "red");
		setProp(_el$35, "x", "10");
		setProp(_el$35, "y", "10");
		setProp(_el$35, "width", "30");
		setProp(_el$35, "height", "30");
		setProp(_el$35, "fill", "blue");
		insertNode(_el$36, createTextNode(\`SVG Text\`));
		setProp(_el$36, "x", "50");
		setProp(_el$36, "y", "50");
		setProp(_el$36, "text-anchor", "middle");
		return _el$33;
	})();
}
function TestSSRHeadElement() {
	return (() => {
		var _el$38 = createElement("head"), _el$39 = createElement("title"), _el$41 = createElement("meta"), _el$42 = createElement("meta");
		insertNode(_el$38, _el$39);
		insertNode(_el$38, _el$41);
		insertNode(_el$38, _el$42);
		insertNode(_el$39, createTextNode(\`SSR Test\`));
		setProp(_el$41, "charset", "utf-8");
		setProp(_el$42, "name", "viewport");
		setProp(_el$42, "content", "width=device-width");
		return _el$38;
	})();
}
function TestSSRScriptStyle() {
	return (() => {
		var _el$43 = createElement("div"), _el$44 = createElement("script"), _el$46 = createElement("style");
		insertNode(_el$43, _el$44);
		insertNode(_el$43, _el$46);
		insertNode(_el$44, createTextNode(\`console.log('test');\`));
		insertNode(_el$46, createTextNode(\`body \\{ margin: 0; }\`));
		return _el$43;
	})();
}
function TestSSRHydration() {
	return (() => {
		var _el$48 = createElement("div"), _el$49 = createElement("p"), _el$51 = createElement("div"), _el$52 = createElement("ul");
		insertNode(_el$48, _el$49);
		insertNode(_el$48, _el$51);
		insertNode(_el$48, _el$52);
		insertNode(_el$49, createTextNode(\`Static content\`));
		insert(_el$51, () => \`Dynamic content: \${Date.now()}\`);
		insert(_el$52, () => [
			1,
			2,
			3
		].map((item) => (() => {
			var _el$53 = createElement("li");
			insertNode(_el$53, createTextNode(\`Item \`));
			insert(_el$53, item, null);
			return _el$53;
		})()));
		return _el$48;
	})();
}
function TestSSRSpreadAttributes() {
	const props = {
		class: "dynamic-class",
		id: "dynamic-id",
		"data-test": "value"
	};
	return (() => {
		var _el$55 = createElement("div");
		insertNode(_el$55, createTextNode(\`Spread attributes\`));
		spread(_el$55, props, true);
		return _el$55;
	})();
}
function TestSSRSpecialElements() {
	return (() => {
		var _el$57 = createElement("table"), _el$58 = createElement("thead"), _el$59 = createElement("tr"), _el$60 = createElement("th"), _el$62 = createElement("th"), _el$64 = createElement("tbody"), _el$65 = createElement("tr"), _el$66 = createElement("td"), _el$68 = createElement("td");
		insertNode(_el$57, _el$58);
		insertNode(_el$57, _el$64);
		insertNode(_el$58, _el$59);
		insertNode(_el$59, _el$60);
		insertNode(_el$59, _el$62);
		insertNode(_el$60, createTextNode(\`Header 1\`));
		insertNode(_el$62, createTextNode(\`Header 2\`));
		insertNode(_el$64, _el$65);
		insertNode(_el$65, _el$66);
		insertNode(_el$65, _el$68);
		insertNode(_el$66, createTextNode(\`Cell 1\`));
		insertNode(_el$68, createTextNode(\`Cell 2\`));
		return _el$57;
	})();
}
function TestValidationScenarios() {
	return (() => {
		var _el$70 = createElement("div"), _el$71 = createElement("section"), _el$72 = createElement("article"), _el$73 = createElement("header"), _el$74 = createElement("h1"), _el$76 = createElement("main"), _el$77 = createElement("p"), _el$79 = createElement("footer"), _el$80 = createElement("small"), _el$82 = createElement("table"), _el$83 = createElement("tr"), _el$84 = createElement("td"), _el$86 = createElement("td"), _el$88 = createElement("img"), _el$89 = createElement("br"), _el$90 = createElement("hr");
		insertNode(_el$70, _el$71);
		insertNode(_el$70, _el$82);
		insertNode(_el$70, _el$88);
		insertNode(_el$70, _el$89);
		insertNode(_el$70, _el$90);
		insertNode(_el$71, _el$72);
		insertNode(_el$72, _el$73);
		insertNode(_el$72, _el$76);
		insertNode(_el$72, _el$79);
		insertNode(_el$73, _el$74);
		insertNode(_el$74, createTextNode(\`Title\`));
		insertNode(_el$76, _el$77);
		insertNode(_el$77, createTextNode(\`Content\`));
		insertNode(_el$79, _el$80);
		insertNode(_el$80, createTextNode(\`Footer\`));
		insertNode(_el$82, _el$83);
		insertNode(_el$83, _el$84);
		insertNode(_el$83, _el$86);
		insertNode(_el$84, createTextNode(\`Cell 1\`));
		insertNode(_el$86, createTextNode(\`Cell 2\`));
		setProp(_el$88, "src", "test.jpg");
		setProp(_el$88, "alt", "test");
		return _el$70;
	})();
}

//#endregion
export { TestAttributeTemplates, TestComplexTemplates, TestEventDelegation, TestNestedSvg, TestSSRHeadElement, TestSSRHydration, TestSSRScriptStyle, TestSSRSpecialElements, TestSSRSpreadAttributes, TestSVGTemplates, TestSvgWrap, TestValidationScenarios };"
`;
