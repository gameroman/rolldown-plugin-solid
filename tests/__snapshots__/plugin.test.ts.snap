// Bun Snapshot v1, https://bun.sh/docs/test/snapshots

exports[`rolldown-plugin-solid should transform basic SolidJS component 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
	sharedConfig.context = context;
}
function nextHydrateContext() {
	return {
		...sharedConfig.context,
		id: sharedConfig.getNextContextId(),
		count: 0
	};
}
const equalFn = (a, b) => a === b;
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
	const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
		owned: null,
		cleanups: null,
		context: current ? current.context : null,
		owner: current
	}, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
	Owner = root;
	Listener = null;
	try {
		return runUpdates(updateFn, true);
	} finally {
		Listener = listener;
		Owner = owner;
	}
}
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}
let hydrationEnabled = false;
function createComponent(Comp, props) {
	if (hydrationEnabled) {
		if (sharedConfig.context) {
			const c = sharedConfig.context;
			setHydrateContext(nextHydrateContext());
			const r = untrack(() => Comp(props || {}));
			setHydrateContext(c);
			return r;
		}
	}
	return untrack(() => Comp(props || {}));
}

//#endregion
//#region node_modules/solid-js/web/dist/web.js
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
function reconcileArrays(parentNode, a, b) {
	let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
	while (aStart < aEnd || bStart < bEnd) {
		if (a[aStart] === b[bStart]) {
			aStart++;
			bStart++;
			continue;
		}
		while (a[aEnd - 1] === b[bEnd - 1]) {
			aEnd--;
			bEnd--;
		}
		if (aEnd === aStart) {
			const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
			while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
		} else if (bEnd === bStart) while (aStart < aEnd) {
			if (!map || !map.has(a[aStart])) a[aStart].remove();
			aStart++;
		}
		else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
			const node = a[--aEnd].nextSibling;
			parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
			parentNode.insertBefore(b[--bEnd], node);
			a[aEnd] = b[bEnd];
		} else {
			if (!map) {
				map = /* @__PURE__ */ new Map();
				let i = bStart;
				while (i < bEnd) map.set(b[i], i++);
			}
			const index = map.get(a[aStart]);
			if (index != null) if (bStart < index && index < bEnd) {
				let i = aStart, sequence = 1, t;
				while (++i < aEnd && i < bEnd) {
					if ((t = map.get(a[i])) == null || t !== index + sequence) break;
					sequence++;
				}
				if (sequence > index - bStart) {
					const node = a[aStart];
					while (bStart < index) parentNode.insertBefore(b[bStart++], node);
				} else parentNode.replaceChild(b[bStart++], a[aStart++]);
			} else aStart++;
			else a[aStart++].remove();
		}
	}
}
const $$EVENTS = "_$DX_DELEGATE";
function render(code, element, init, options = {}) {
	let disposer;
	createRoot((dispose) => {
		disposer = dispose;
		element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
	}, options.owner);
	return () => {
		disposer();
		element.textContent = "";
	};
}
function template(html, isImportNode, isSVG, isMathML) {
	let node;
	const create = () => {
		const t = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
		t.innerHTML = html;
		return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;
	};
	const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
	fn.cloneNode = fn;
	return fn;
}
function delegateEvents(eventNames, document$1 = window.document) {
	const e = document$1[$$EVENTS] || (document$1[$$EVENTS] = /* @__PURE__ */ new Set());
	for (let i = 0, l = eventNames.length; i < l; i++) {
		const name = eventNames[i];
		if (!e.has(name)) {
			e.add(name);
			document$1.addEventListener(name, eventHandler);
		}
	}
}
function insert(parent, accessor, marker, initial) {
	if (marker !== void 0 && !initial) initial = [];
	if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
	createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function isHydrating(node) {
	return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function eventHandler(e) {
	if (sharedConfig.registry && sharedConfig.events) {
		if (sharedConfig.events.find(([el, ev]) => ev === e)) return;
	}
	let node = e.target;
	const key = \`$$\${e.type}\`;
	const oriTarget = e.target;
	const oriCurrentTarget = e.currentTarget;
	const retarget = (value) => Object.defineProperty(e, "target", {
		configurable: true,
		value
	});
	const handleNode = () => {
		const handler = node[key];
		if (handler && !node.disabled) {
			const data = node[\`\${key}Data\`];
			data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
			if (e.cancelBubble) return;
		}
		node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
		return true;
	};
	const walkUpTree = () => {
		while (handleNode() && (node = node._$host || node.parentNode || node.host));
	};
	Object.defineProperty(e, "currentTarget", {
		configurable: true,
		get() {
			return node || document;
		}
	});
	if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
	if (e.composedPath) {
		const path = e.composedPath();
		retarget(path[0]);
		for (let i = 0; i < path.length - 2; i++) {
			node = path[i];
			if (!handleNode()) break;
			if (node._$host) {
				node = node._$host;
				walkUpTree();
				break;
			}
			if (node.parentNode === oriCurrentTarget) break;
		}
	} else walkUpTree();
	retarget(oriTarget);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
	const hydrating = isHydrating(parent);
	if (hydrating) {
		!current && (current = [...parent.childNodes]);
		let cleaned = [];
		for (let i = 0; i < current.length; i++) {
			const node = current[i];
			if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
			else cleaned.push(node);
		}
		current = cleaned;
	}
	while (typeof current === "function") current = current();
	if (value === current) return current;
	const t = typeof value, multi = marker !== void 0;
	parent = multi && current[0] && current[0].parentNode || parent;
	if (t === "string" || t === "number") {
		if (hydrating) return current;
		if (t === "number") {
			value = value.toString();
			if (value === current) return current;
		}
		if (multi) {
			let node = current[0];
			if (node && node.nodeType === 3) node.data !== value && (node.data = value);
			else node = document.createTextNode(value);
			current = cleanChildren(parent, current, marker, node);
		} else if (current !== "" && typeof current === "string") current = parent.firstChild.data = value;
		else current = parent.textContent = value;
	} else if (value == null || t === "boolean") {
		if (hydrating) return current;
		current = cleanChildren(parent, current, marker);
	} else if (t === "function") {
		createRenderEffect(() => {
			let v = value();
			while (typeof v === "function") v = v();
			current = insertExpression(parent, v, current, marker);
		});
		return () => current;
	} else if (Array.isArray(value)) {
		const array = [];
		const currentArray = current && Array.isArray(current);
		if (normalizeIncomingArray(array, value, current, unwrapArray)) {
			createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
			return () => current;
		}
		if (hydrating) {
			if (!array.length) return current;
			if (marker === void 0) return current = [...parent.childNodes];
			let node = array[0];
			if (node.parentNode !== parent) return current;
			const nodes = [node];
			while ((node = node.nextSibling) !== marker) nodes.push(node);
			return current = nodes;
		}
		if (array.length === 0) {
			current = cleanChildren(parent, current, marker);
			if (multi) return current;
		} else if (currentArray) if (current.length === 0) appendNodes(parent, array, marker);
		else reconcileArrays(parent, current, array);
		else {
			current && cleanChildren(parent);
			appendNodes(parent, array);
		}
		current = array;
	} else if (value.nodeType) {
		if (hydrating && value.parentNode) return current = multi ? [value] : value;
		if (Array.isArray(current)) {
			if (multi) return current = cleanChildren(parent, current, marker, value);
			cleanChildren(parent, current, null, value);
		} else if (current == null || current === "" || !parent.firstChild) parent.appendChild(value);
		else parent.replaceChild(value, parent.firstChild);
		current = value;
	}
	return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
	let dynamic = false;
	for (let i = 0, len = array.length; i < len; i++) {
		let item = array[i], prev = current && current[normalized.length], t;
		if (item == null || item === true || item === false);
		else if ((t = typeof item) === "object" && item.nodeType) normalized.push(item);
		else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
		else if (t === "function") if (unwrap) {
			while (typeof item === "function") item = item();
			dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
		} else {
			normalized.push(item);
			dynamic = true;
		}
		else {
			const value = String(item);
			if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
			else normalized.push(document.createTextNode(value));
		}
	}
	return dynamic;
}
function appendNodes(parent, array, marker = null) {
	for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
	if (marker === void 0) return parent.textContent = "";
	const node = replacement || document.createTextNode("");
	if (current.length) {
		let inserted = false;
		for (let i = current.length - 1; i >= 0; i--) {
			const el = current[i];
			if (node !== el) {
				const isParent = el.parentNode === parent;
				if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
				else isParent && el.remove();
			} else inserted = true;
		}
	} else parent.insertBefore(node, marker);
	return [node];
}

//#endregion
//#region tests/fixtures/basic.tsx
var _tmpl$ = /* @__PURE__ */ template(\`<button type=button>\`);
const App = () => {
	const [count, setCount] = createSignal(0);
	const inc = (by = 1) => setCount(count() + by);
	return (() => {
		var _el$ = _tmpl$();
		_el$.$$click = () => inc(1);
		insert(_el$, count);
		return _el$;
	})();
};
render(() => createComponent(App, {}), document.getElementById("app"));
delegateEvents(["click"]);

//#endregion"
`;

exports[`rolldown-plugin-solid should transform SSR component 1`] = `
"//#region node_modules/solid-js/dist/server.js
const ERROR = Symbol("error");
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function handleError(err, owner = Owner) {
	const fns = owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	try {
		for (const f$2 of fns) f$2(error);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
const UNOWNED = {
	context: null,
	owner: null,
	owned: null,
	cleanups: null
};
let Owner = null;
function createOwner() {
	const o$1 = {
		owner: Owner,
		context: Owner ? Owner.context : null,
		owned: null,
		cleanups: null
	};
	if (Owner) if (!Owner.owned) Owner.owned = [o$1];
	else Owner.owned.push(o$1);
	return o$1;
}
function createRoot(fn, detachedOwner) {
	const owner = Owner, current = detachedOwner === void 0 ? owner : detachedOwner, root = fn.length === 0 ? UNOWNED : {
		context: current ? current.context : null,
		owner: current,
		owned: null,
		cleanups: null
	};
	Owner = root;
	let result;
	try {
		result = fn(fn.length === 0 ? () => {} : () => cleanNode(root));
	} catch (err) {
		handleError(err);
	} finally {
		Owner = owner;
	}
	return result;
}
function createSignal(value, options) {
	return [() => value, (v$1) => {
		return value = typeof v$1 === "function" ? v$1(value) : v$1;
	}];
}
function createMemo(fn, value) {
	Owner = createOwner();
	let v$1;
	try {
		v$1 = fn(value);
	} catch (err) {
		handleError(err);
	} finally {
		Owner = Owner.owner;
	}
	return () => v$1;
}
function cleanNode(node) {
	if (node.owned) {
		for (let i$1 = 0; i$1 < node.owned.length; i$1++) cleanNode(node.owned[i$1]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (let i$1 = 0; i$1 < node.cleanups.length; i$1++) node.cleanups[i$1]();
		node.cleanups = null;
	}
}
function createContext(defaultValue) {
	const id = Symbol("context");
	return {
		id,
		Provider: createProvider(id),
		defaultValue
	};
}
function children(fn) {
	const memo = createMemo(() => resolveChildren(fn()));
	memo.toArray = () => {
		const c$1 = memo();
		return Array.isArray(c$1) ? c$1 : c$1 != null ? [c$1] : [];
	};
	return memo;
}
function resolveChildren(children$1) {
	if (typeof children$1 === "function" && !children$1.length) return resolveChildren(children$1());
	if (Array.isArray(children$1)) {
		const results = [];
		for (let i$1 = 0; i$1 < children$1.length; i$1++) {
			const result = resolveChildren(children$1[i$1]);
			Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
		}
		return results;
	}
	return children$1;
}
function createProvider(id) {
	return function provider(props) {
		return createMemo(() => {
			Owner.context = {
				...Owner.context,
				[id]: props.value
			};
			return children(() => props.children);
		});
	};
}
const sharedConfig = {
	context: void 0,
	getContextId() {
		if (!this.context) throw new Error(\`getContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count);
	},
	getNextContextId() {
		if (!this.context) throw new Error(\`getNextContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
const SuspenseContext = createContext();

//#endregion
//#region node_modules/seroval/dist/esm/production/index.mjs
var R = ((a) => (a[a.AggregateError = 1] = "AggregateError", a[a.ArrowFunction = 2] = "ArrowFunction", a[a.ErrorPrototypeStack = 4] = "ErrorPrototypeStack", a[a.ObjectAssign = 8] = "ObjectAssign", a[a.BigIntTypedArray = 16] = "BigIntTypedArray", a))(R || {});
function Nr(o$1) {
	switch (o$1) {
		case "\\"": return "\\\\\\"";
		case "\\\\": return "\\\\\\\\";
		case \`
\`: return "\\\\n";
		case "\\r": return "\\\\r";
		case "\\b": return "\\\\b";
		case "	": return "\\\\t";
		case "\\f": return "\\\\f";
		case "<": return "\\\\x3C";
		case "\\u2028": return "\\\\u2028";
		case "\\u2029": return "\\\\u2029";
		default: return;
	}
}
function d(o$1) {
	let e = "", r = 0, t;
	for (let n = 0, a = o$1.length; n < a; n++) t = Nr(o$1[n]), t && (e += o$1.slice(r, n) + t, r = n + 1);
	return r === 0 ? e = o$1 : e += o$1.slice(r), e;
}
var O$1 = "__SEROVAL_REFS__", Q = "$R", ae = \`self.\${Q}\`;
function xr(o$1) {
	return o$1 == null ? \`\${ae}=\${ae}||[]\` : \`(\${ae}=\${ae}||{})["\${d(o$1)}"]=[]\`;
}
function f$1(o$1, e) {
	if (!o$1) throw e;
}
var Be = /* @__PURE__ */ new Map(), C$1 = /* @__PURE__ */ new Map();
function je(o$1) {
	return Be.has(o$1);
}
function Ke(o$1) {
	return f$1(je(o$1), new ie$1(o$1)), Be.get(o$1);
}
typeof globalThis != "undefined" ? Object.defineProperty(globalThis, O$1, {
	value: C$1,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof window != "undefined" ? Object.defineProperty(window, O$1, {
	value: C$1,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof self != "undefined" ? Object.defineProperty(self, O$1, {
	value: C$1,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof global != "undefined" && Object.defineProperty(global, O$1, {
	value: C$1,
	configurable: !0,
	writable: !1,
	enumerable: !1
});
function Hr(o$1) {
	return o$1;
}
function Ye(o$1, e) {
	for (let r = 0, t = e.length; r < t; r++) {
		let n = e[r];
		o$1.has(n) || (o$1.add(n), n.extends && Ye(o$1, n.extends));
	}
}
function m$1(o$1) {
	if (o$1) {
		let e = /* @__PURE__ */ new Set();
		return Ye(e, o$1), [...e];
	}
}
var $e = {
	0: "Symbol.asyncIterator",
	1: "Symbol.hasInstance",
	2: "Symbol.isConcatSpreadable",
	3: "Symbol.iterator",
	4: "Symbol.match",
	5: "Symbol.matchAll",
	6: "Symbol.replace",
	7: "Symbol.search",
	8: "Symbol.species",
	9: "Symbol.split",
	10: "Symbol.toPrimitive",
	11: "Symbol.toStringTag",
	12: "Symbol.unscopables"
}, ce = {
	[Symbol.asyncIterator]: 0,
	[Symbol.hasInstance]: 1,
	[Symbol.isConcatSpreadable]: 2,
	[Symbol.iterator]: 3,
	[Symbol.match]: 4,
	[Symbol.matchAll]: 5,
	[Symbol.replace]: 6,
	[Symbol.search]: 7,
	[Symbol.species]: 8,
	[Symbol.split]: 9,
	[Symbol.toPrimitive]: 10,
	[Symbol.toStringTag]: 11,
	[Symbol.unscopables]: 12
}, Ge = {
	0: Symbol.asyncIterator,
	1: Symbol.hasInstance,
	2: Symbol.isConcatSpreadable,
	3: Symbol.iterator,
	4: Symbol.match,
	5: Symbol.matchAll,
	6: Symbol.replace,
	7: Symbol.search,
	8: Symbol.species,
	9: Symbol.split,
	10: Symbol.toPrimitive,
	11: Symbol.toStringTag,
	12: Symbol.unscopables
}, qe = {
	2: "!0",
	3: "!1",
	1: "void 0",
	0: "null",
	4: "-0",
	5: "1/0",
	6: "-1/0",
	7: "0/0"
}, He = {
	2: !0,
	3: !1,
	1: void 0,
	0: null,
	4: -0,
	5: Number.POSITIVE_INFINITY,
	6: Number.NEGATIVE_INFINITY,
	7: NaN
};
var ue$1 = {
	0: "Error",
	1: "EvalError",
	2: "RangeError",
	3: "ReferenceError",
	4: "SyntaxError",
	5: "TypeError",
	6: "URIError"
}, Ze = {
	0: Error,
	1: EvalError,
	2: RangeError,
	3: ReferenceError,
	4: SyntaxError,
	5: TypeError,
	6: URIError
}, s$1 = void 0;
function u$1(o$1, e, r, t, n, a, i$1, l$1, c$1, p$1, h$1, X) {
	return {
		t: o$1,
		i: e,
		s: r,
		l: t,
		c: n,
		m: a,
		p: i$1,
		e: l$1,
		a: c$1,
		f: p$1,
		b: h$1,
		o: X
	};
}
function x$1(o$1) {
	return u$1(2, s$1, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
var I = x$1(2), A$1 = x$1(3), pe = x$1(1), de = x$1(0), Xe = x$1(4), Qe = x$1(5), er = x$1(6), rr = x$1(7);
function me$1(o$1) {
	return o$1 instanceof EvalError ? 1 : o$1 instanceof RangeError ? 2 : o$1 instanceof ReferenceError ? 3 : o$1 instanceof SyntaxError ? 4 : o$1 instanceof TypeError ? 5 : o$1 instanceof URIError ? 6 : 0;
}
function wr(o$1) {
	let e = ue$1[me$1(o$1)];
	return o$1.name !== e ? { name: o$1.name } : o$1.constructor.name !== e ? { name: o$1.constructor.name } : {};
}
function j(o$1, e) {
	let r = wr(o$1), t = Object.getOwnPropertyNames(o$1);
	for (let n = 0, a = t.length, i$1; n < a; n++) i$1 = t[n], i$1 !== "name" && i$1 !== "message" && (i$1 === "stack" ? e & 4 && (r = r || {}, r[i$1] = o$1[i$1]) : (r = r || {}, r[i$1] = o$1[i$1]));
	return r;
}
function fe(o$1) {
	return Object.isFrozen(o$1) ? 3 : Object.isSealed(o$1) ? 2 : Object.isExtensible(o$1) ? 0 : 1;
}
function ge(o$1) {
	switch (o$1) {
		case Number.POSITIVE_INFINITY: return Qe;
		case Number.NEGATIVE_INFINITY: return er;
	}
	return o$1 !== o$1 ? rr : Object.is(o$1, -0) ? Xe : u$1(0, s$1, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function w$1(o$1) {
	return u$1(1, s$1, d(o$1), s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function Se(o$1) {
	return u$1(3, s$1, "" + o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function sr(o$1) {
	return u$1(4, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function he(o$1, e) {
	let r = e.valueOf();
	return u$1(5, o$1, r !== r ? "" : e.toISOString(), s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function ye(o$1, e) {
	return u$1(6, o$1, s$1, s$1, d(e.source), e.flags, s$1, s$1, s$1, s$1, s$1, s$1);
}
function ve(o$1, e) {
	let r = new Uint8Array(e), t = r.length, n = new Array(t);
	for (let a = 0; a < t; a++) n[a] = r[a];
	return u$1(19, o$1, n, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function or(o$1, e) {
	return u$1(17, o$1, ce[e], s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function nr(o$1, e) {
	return u$1(18, o$1, d(Ke(e)), s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function _$1(o$1, e, r) {
	return u$1(25, o$1, r, s$1, d(e), s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function Ne(o$1, e, r) {
	return u$1(9, o$1, s$1, e.length, s$1, s$1, s$1, s$1, r, s$1, s$1, fe(e));
}
function be(o$1, e) {
	return u$1(21, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, e, s$1, s$1);
}
function xe(o$1, e, r) {
	return u$1(15, o$1, s$1, e.length, e.constructor.name, s$1, s$1, s$1, s$1, r, e.byteOffset, s$1);
}
function Ie(o$1, e, r) {
	return u$1(16, o$1, s$1, e.length, e.constructor.name, s$1, s$1, s$1, s$1, r, e.byteOffset, s$1);
}
function Ae(o$1, e, r) {
	return u$1(20, o$1, s$1, e.byteLength, s$1, s$1, s$1, s$1, s$1, r, e.byteOffset, s$1);
}
function we(o$1, e, r) {
	return u$1(13, o$1, me$1(e), s$1, s$1, d(e.message), r, s$1, s$1, s$1, s$1, s$1);
}
function Ee(o$1, e, r) {
	return u$1(14, o$1, me$1(e), s$1, s$1, d(e.message), r, s$1, s$1, s$1, s$1, s$1);
}
function Pe(o$1, e, r) {
	return u$1(7, o$1, s$1, e, s$1, s$1, s$1, s$1, r, s$1, s$1, s$1);
}
function M(o$1, e) {
	return u$1(28, s$1, s$1, s$1, s$1, s$1, s$1, s$1, [o$1, e], s$1, s$1, s$1);
}
function U(o$1, e) {
	return u$1(30, s$1, s$1, s$1, s$1, s$1, s$1, s$1, [o$1, e], s$1, s$1, s$1);
}
function L(o$1, e, r) {
	return u$1(31, o$1, s$1, s$1, s$1, s$1, s$1, s$1, r, e, s$1, s$1);
}
function Re(o$1, e) {
	return u$1(32, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, e, s$1, s$1);
}
function Oe(o$1, e) {
	return u$1(33, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, e, s$1, s$1);
}
function Ce(o$1, e) {
	return u$1(34, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, e, s$1, s$1);
}
var { toString: _e } = Object.prototype;
function Er(o$1, e) {
	return e instanceof Error ? \`Seroval caught an error during the \${o$1} process.
  
\${e.name}
\${e.message}

- For more information, please check the "cause" property of this error.
- If you believe this is an error in Seroval, please submit an issue at https://github.com/lxsmnsyc/seroval/issues/new\` : \`Seroval caught an error during the \${o$1} process.

"\${_e.call(e)}"

For more information, please check the "cause" property of this error.\`;
}
var ee$1 = class extends Error {
	constructor(r, t) {
		super(Er(r, t));
		this.cause = t;
	}
}, E$1 = class extends ee$1 {
	constructor(e) {
		super("parsing", e);
	}
}, Te = class extends ee$1 {
	constructor(e) {
		super("serialization", e);
	}
}, ze = class extends ee$1 {
	constructor(e) {
		super("deserialization", e);
	}
}, g$1 = class extends Error {
	constructor(r) {
		super(\`The value \${_e.call(r)} of type "\${typeof r}" cannot be parsed/serialized.
      
There are few workarounds for this problem:
- Transform the value in a way that it can be serialized.
- If the reference is present on multiple runtimes (isomorphic), you can use the Reference API to map the references.\`);
		this.value = r;
	}
}, y$1 = class extends Error {
	constructor(e) {
		super("Unsupported node type \\"" + e.t + "\\".");
	}
}, W = class extends Error {
	constructor(e) {
		super("Missing plugin for tag \\"" + e + "\\".");
	}
}, P$1 = class extends Error {
	constructor(e) {
		super("Missing \\"" + e + "\\" instance.");
	}
}, ie$1 = class extends Error {
	constructor(r) {
		super("Missing reference for the value \\"" + _e.call(r) + "\\" of type \\"" + typeof r + "\\"");
		this.value = r;
	}
}, le = class extends Error {
	constructor(e) {
		super("Missing reference for id \\"" + d(e) + "\\"");
	}
}, ke = class extends Error {
	constructor(e) {
		super("Unknown TypedArray \\"" + e + "\\"");
	}
};
var T = class {
	constructor(e, r) {
		this.value = e;
		this.replacement = r;
	}
};
function z(o$1, e, r) {
	return o$1 & 2 ? (e.length === 1 ? e[0] : "(" + e.join(",") + ")") + "=>" + (r.startsWith("{") ? "(" + r + ")" : r) : "function(" + e.join(",") + "){return " + r + "}";
}
function S(o$1, e, r) {
	return o$1 & 2 ? (e.length === 1 ? e[0] : "(" + e.join(",") + ")") + "=>{" + r + "}" : "function(" + e.join(",") + "){" + r + "}";
}
var ar = {}, ir = {};
var lr = {
	0: {},
	1: {},
	2: {},
	3: {},
	4: {}
};
function Pr(o$1) {
	return z(o$1, ["r"], "(r.p=new Promise(" + S(o$1, ["s", "f"], "r.s=s,r.f=f") + "))");
}
function Rr(o$1) {
	return S(o$1, ["r", "d"], "r.s(d),r.p.s=1,r.p.v=d");
}
function Or(o$1) {
	return S(o$1, ["r", "d"], "r.f(d),r.p.s=2,r.p.v=d");
}
function Cr(o$1) {
	return z(o$1, [
		"b",
		"a",
		"s",
		"l",
		"p",
		"f",
		"e",
		"n"
	], "(b=[],a=!0,s=!1,l=[],p=0,f=" + S(o$1, [
		"v",
		"m",
		"x"
	], "for(x=0;x<p;x++)l[x]&&l[x][m](v)") + ",n=" + S(o$1, [
		"o",
		"x",
		"z",
		"c"
	], "for(x=0,z=b.length;x<z;x++)(c=b[x],(!a&&x===z-1)?o[s?\\"return\\":\\"throw\\"](c):o.next(c))") + ",e=" + z(o$1, ["o", "t"], "(a&&(l[t=p++]=o),n(o)," + S(o$1, [], "a&&(l[t]=void 0)") + ")") + ",{__SEROVAL_STREAM__:!0,on:" + z(o$1, ["o"], "e(o)") + ",next:" + S(o$1, ["v"], "a&&(b.push(v),f(v,\\"next\\"))") + ",throw:" + S(o$1, ["v"], "a&&(b.push(v),f(v,\\"throw\\"),a=s=!1,l.length=0)") + ",return:" + S(o$1, ["v"], "a&&(b.push(v),f(v,\\"return\\"),a=!1,s=!0,l.length=0)") + "})");
}
function cr(o$1, e) {
	switch (e) {
		case 0: return "[]";
		case 1: return Pr(o$1);
		case 2: return Rr(o$1);
		case 3: return Or(o$1);
		case 4: return Cr(o$1);
		default: return "";
	}
}
function Fe(o$1) {
	return "__SEROVAL_STREAM__" in o$1;
}
function K$1() {
	let o$1 = /* @__PURE__ */ new Set(), e = [], r = !0, t = !0;
	function n(l$1) {
		for (let c$1 of o$1.keys()) c$1.next(l$1);
	}
	function a(l$1) {
		for (let c$1 of o$1.keys()) c$1.throw(l$1);
	}
	function i$1(l$1) {
		for (let c$1 of o$1.keys()) c$1.return(l$1);
	}
	return {
		__SEROVAL_STREAM__: !0,
		on(l$1) {
			r && o$1.add(l$1);
			for (let c$1 = 0, p$1 = e.length; c$1 < p$1; c$1++) {
				let h$1 = e[c$1];
				c$1 === p$1 - 1 && !r ? t ? l$1.return(h$1) : l$1.throw(h$1) : l$1.next(h$1);
			}
			return () => {
				r && o$1.delete(l$1);
			};
		},
		next(l$1) {
			r && (e.push(l$1), n(l$1));
		},
		throw(l$1) {
			r && (e.push(l$1), a(l$1), r = !1, t = !1, o$1.clear());
		},
		return(l$1) {
			r && (e.push(l$1), i$1(l$1), r = !1, t = !0, o$1.clear());
		}
	};
}
function Ve(o$1) {
	let e = K$1(), r = o$1[Symbol.asyncIterator]();
	async function t() {
		try {
			let n = await r.next();
			n.done ? e.return(n.value) : (e.next(n.value), await t());
		} catch (n) {
			e.throw(n);
		}
	}
	return t().catch(() => {}), e;
}
function J(o$1) {
	let e = [], r = -1, t = -1, n = o$1[Symbol.iterator]();
	for (;;) try {
		let a = n.next();
		if (e.push(a.value), a.done) {
			t = e.length - 1;
			break;
		}
	} catch (a) {
		r = e.length, e.push(a);
	}
	return {
		v: e,
		t: r,
		d: t
	};
}
var Y$1 = class {
	constructor(e) {
		this.marked = /* @__PURE__ */ new Set();
		this.plugins = e.plugins, this.features = 31 ^ (e.disabledFeatures || 0), this.refs = e.refs || /* @__PURE__ */ new Map();
	}
	markRef(e) {
		this.marked.add(e);
	}
	isMarked(e) {
		return this.marked.has(e);
	}
	createIndex(e) {
		let r = this.refs.size;
		return this.refs.set(e, r), r;
	}
	getIndexedValue(e) {
		let r = this.refs.get(e);
		return r != null ? (this.markRef(r), {
			type: 1,
			value: sr(r)
		}) : {
			type: 0,
			value: this.createIndex(e)
		};
	}
	getReference(e) {
		let r = this.getIndexedValue(e);
		return r.type === 1 ? r : je(e) ? {
			type: 2,
			value: nr(r.value, e)
		} : r;
	}
	parseWellKnownSymbol(e) {
		let r = this.getReference(e);
		return r.type !== 0 ? r.value : (f$1(e in ce, new g$1(e)), or(r.value, e));
	}
	parseSpecialReference(e) {
		let r = this.getIndexedValue(lr[e]);
		return r.type === 1 ? r.value : u$1(26, r.value, e, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
	}
	parseIteratorFactory() {
		let e = this.getIndexedValue(ar);
		return e.type === 1 ? e.value : u$1(27, e.value, s$1, s$1, s$1, s$1, s$1, s$1, s$1, this.parseWellKnownSymbol(Symbol.iterator), s$1, s$1);
	}
	parseAsyncIteratorFactory() {
		let e = this.getIndexedValue(ir);
		return e.type === 1 ? e.value : u$1(29, e.value, s$1, s$1, s$1, s$1, s$1, s$1, [this.parseSpecialReference(1), this.parseWellKnownSymbol(Symbol.asyncIterator)], s$1, s$1, s$1);
	}
	createObjectNode(e, r, t, n) {
		return u$1(t ? 11 : 10, e, s$1, s$1, s$1, s$1, n, s$1, s$1, s$1, s$1, fe(r));
	}
	createMapNode(e, r, t, n) {
		return u$1(8, e, s$1, s$1, s$1, s$1, s$1, {
			k: r,
			v: t,
			s: n
		}, s$1, this.parseSpecialReference(0), s$1, s$1);
	}
	createPromiseConstructorNode(e, r) {
		return u$1(22, e, r, s$1, s$1, s$1, s$1, s$1, s$1, this.parseSpecialReference(1), s$1, s$1);
	}
};
var kr = /^[$A-Z_][0-9A-Z_$]*$/i;
function Le(o$1) {
	let e = o$1[0];
	return (e === "$" || e === "_" || e >= "A" && e <= "Z" || e >= "a" && e <= "z") && kr.test(o$1);
}
function se(o$1) {
	switch (o$1.t) {
		case 0: return o$1.s + "=" + o$1.v;
		case 2: return o$1.s + ".set(" + o$1.k + "," + o$1.v + ")";
		case 1: return o$1.s + ".add(" + o$1.v + ")";
		case 3: return o$1.s + ".delete(" + o$1.k + ")";
	}
}
function Fr(o$1) {
	let e = [], r = o$1[0];
	for (let t = 1, n = o$1.length, a, i$1 = r; t < n; t++) a = o$1[t], a.t === 0 && a.v === i$1.v ? r = {
		t: 0,
		s: a.s,
		k: s$1,
		v: se(r)
	} : a.t === 2 && a.s === i$1.s ? r = {
		t: 2,
		s: se(r),
		k: a.k,
		v: a.v
	} : a.t === 1 && a.s === i$1.s ? r = {
		t: 1,
		s: se(r),
		k: s$1,
		v: a.v
	} : a.t === 3 && a.s === i$1.s ? r = {
		t: 3,
		s: se(r),
		k: a.k,
		v: s$1
	} : (e.push(r), r = a), i$1 = a;
	return e.push(r), e;
}
function fr(o$1) {
	if (o$1.length) {
		let e = "", r = Fr(o$1);
		for (let t = 0, n = r.length; t < n; t++) e += se(r[t]) + ",";
		return e;
	}
	return s$1;
}
var Vr = "Object.create(null)", Dr = "new Set", Br = "new Map", jr = "Promise.resolve", _r = "Promise.reject", Mr = {
	3: "Object.freeze",
	2: "Object.seal",
	1: "Object.preventExtensions",
	0: s$1
}, V = class {
	constructor(e) {
		this.stack = [];
		this.flags = [];
		this.assignments = [];
		this.plugins = e.plugins, this.features = e.features, this.marked = new Set(e.markedRefs);
	}
	createFunction(e, r) {
		return z(this.features, e, r);
	}
	createEffectfulFunction(e, r) {
		return S(this.features, e, r);
	}
	markRef(e) {
		this.marked.add(e);
	}
	isMarked(e) {
		return this.marked.has(e);
	}
	pushObjectFlag(e, r) {
		e !== 0 && (this.markRef(r), this.flags.push({
			type: e,
			value: this.getRefParam(r)
		}));
	}
	resolveFlags() {
		let e = "";
		for (let r = 0, t = this.flags, n = t.length; r < n; r++) {
			let a = t[r];
			e += Mr[a.type] + "(" + a.value + "),";
		}
		return e;
	}
	resolvePatches() {
		let e = fr(this.assignments), r = this.resolveFlags();
		return e ? r ? e + r : e : r;
	}
	createAssignment(e, r) {
		this.assignments.push({
			t: 0,
			s: e,
			k: s$1,
			v: r
		});
	}
	createAddAssignment(e, r) {
		this.assignments.push({
			t: 1,
			s: this.getRefParam(e),
			k: s$1,
			v: r
		});
	}
	createSetAssignment(e, r, t) {
		this.assignments.push({
			t: 2,
			s: this.getRefParam(e),
			k: r,
			v: t
		});
	}
	createDeleteAssignment(e, r) {
		this.assignments.push({
			t: 3,
			s: this.getRefParam(e),
			k: r,
			v: s$1
		});
	}
	createArrayAssign(e, r, t) {
		this.createAssignment(this.getRefParam(e) + "[" + r + "]", t);
	}
	createObjectAssign(e, r, t) {
		this.createAssignment(this.getRefParam(e) + "." + r, t);
	}
	isIndexedValueInStack(e) {
		return e.t === 4 && this.stack.includes(e.i);
	}
	serializeReference(e) {
		return this.assignIndexedValue(e.i, O$1 + ".get(\\"" + e.s + "\\")");
	}
	serializeArrayItem(e, r, t) {
		return r ? this.isIndexedValueInStack(r) ? (this.markRef(e), this.createArrayAssign(e, t, this.getRefParam(r.i)), "") : this.serialize(r) : "";
	}
	serializeArray(e) {
		let r = e.i;
		if (e.l) {
			this.stack.push(r);
			let t = e.a, n = this.serializeArrayItem(r, t[0], 0), a = n === "";
			for (let i$1 = 1, l$1 = e.l, c$1; i$1 < l$1; i$1++) c$1 = this.serializeArrayItem(r, t[i$1], i$1), n += "," + c$1, a = c$1 === "";
			return this.stack.pop(), this.pushObjectFlag(e.o, e.i), this.assignIndexedValue(r, "[" + n + (a ? ",]" : "]"));
		}
		return this.assignIndexedValue(r, "[]");
	}
	serializeProperty(e, r, t) {
		if (typeof r == "string") {
			let n = Number(r), a = n >= 0 && n.toString() === r || Le(r);
			if (this.isIndexedValueInStack(t)) {
				let i$1 = this.getRefParam(t.i);
				return this.markRef(e.i), a && n !== n ? this.createObjectAssign(e.i, r, i$1) : this.createArrayAssign(e.i, a ? r : "\\"" + r + "\\"", i$1), "";
			}
			return (a ? r : "\\"" + r + "\\"") + ":" + this.serialize(t);
		}
		return "[" + this.serialize(r) + "]:" + this.serialize(t);
	}
	serializeProperties(e, r) {
		let t = r.s;
		if (t) {
			let n = r.k, a = r.v;
			this.stack.push(e.i);
			let i$1 = this.serializeProperty(e, n[0], a[0]);
			for (let l$1 = 1, c$1 = i$1; l$1 < t; l$1++) c$1 = this.serializeProperty(e, n[l$1], a[l$1]), i$1 += (c$1 && i$1 && ",") + c$1;
			return this.stack.pop(), "{" + i$1 + "}";
		}
		return "{}";
	}
	serializeObject(e) {
		return this.pushObjectFlag(e.o, e.i), this.assignIndexedValue(e.i, this.serializeProperties(e, e.p));
	}
	serializeWithObjectAssign(e, r, t) {
		let n = this.serializeProperties(e, r);
		return n !== "{}" ? "Object.assign(" + t + "," + n + ")" : t;
	}
	serializeStringKeyAssignment(e, r, t, n) {
		let a = this.serialize(n), i$1 = Number(t), l$1 = i$1 >= 0 && i$1.toString() === t || Le(t);
		if (this.isIndexedValueInStack(n)) l$1 && i$1 !== i$1 ? this.createObjectAssign(e.i, t, a) : this.createArrayAssign(e.i, l$1 ? t : "\\"" + t + "\\"", a);
		else {
			let c$1 = this.assignments;
			this.assignments = r, l$1 && i$1 !== i$1 ? this.createObjectAssign(e.i, t, a) : this.createArrayAssign(e.i, l$1 ? t : "\\"" + t + "\\"", a), this.assignments = c$1;
		}
	}
	serializeAssignment(e, r, t, n) {
		if (typeof t == "string") this.serializeStringKeyAssignment(e, r, t, n);
		else {
			let a = this.stack;
			this.stack = [];
			let i$1 = this.serialize(n);
			this.stack = a;
			let l$1 = this.assignments;
			this.assignments = r, this.createArrayAssign(e.i, this.serialize(t), i$1), this.assignments = l$1;
		}
	}
	serializeAssignments(e, r) {
		let t = r.s;
		if (t) {
			let n = [], a = r.k, i$1 = r.v;
			this.stack.push(e.i);
			for (let l$1 = 0; l$1 < t; l$1++) this.serializeAssignment(e, n, a[l$1], i$1[l$1]);
			return this.stack.pop(), fr(n);
		}
		return s$1;
	}
	serializeDictionary(e, r) {
		if (e.p) if (this.features & 8) r = this.serializeWithObjectAssign(e, e.p, r);
		else {
			this.markRef(e.i);
			let t = this.serializeAssignments(e, e.p);
			if (t) return "(" + this.assignIndexedValue(e.i, r) + "," + t + this.getRefParam(e.i) + ")";
		}
		return this.assignIndexedValue(e.i, r);
	}
	serializeNullConstructor(e) {
		return this.pushObjectFlag(e.o, e.i), this.serializeDictionary(e, Vr);
	}
	serializeDate(e) {
		return this.assignIndexedValue(e.i, "new Date(\\"" + e.s + "\\")");
	}
	serializeRegExp(e) {
		return this.assignIndexedValue(e.i, "/" + e.c + "/" + e.m);
	}
	serializeSetItem(e, r) {
		return this.isIndexedValueInStack(r) ? (this.markRef(e), this.createAddAssignment(e, this.getRefParam(r.i)), "") : this.serialize(r);
	}
	serializeSet(e) {
		let r = Dr, t = e.l, n = e.i;
		if (t) {
			let a = e.a;
			this.stack.push(n);
			let i$1 = this.serializeSetItem(n, a[0]);
			for (let l$1 = 1, c$1 = i$1; l$1 < t; l$1++) c$1 = this.serializeSetItem(n, a[l$1]), i$1 += (c$1 && i$1 && ",") + c$1;
			this.stack.pop(), i$1 && (r += "([" + i$1 + "])");
		}
		return this.assignIndexedValue(n, r);
	}
	serializeMapEntry(e, r, t, n) {
		if (this.isIndexedValueInStack(r)) {
			let a = this.getRefParam(r.i);
			if (this.markRef(e), this.isIndexedValueInStack(t)) {
				let l$1 = this.getRefParam(t.i);
				return this.createSetAssignment(e, a, l$1), "";
			}
			if (t.t !== 4 && t.i != null && this.isMarked(t.i)) {
				let l$1 = "(" + this.serialize(t) + ",[" + n + "," + n + "])";
				return this.createSetAssignment(e, a, this.getRefParam(t.i)), this.createDeleteAssignment(e, n), l$1;
			}
			let i$1 = this.stack;
			return this.stack = [], this.createSetAssignment(e, a, this.serialize(t)), this.stack = i$1, "";
		}
		if (this.isIndexedValueInStack(t)) {
			let a = this.getRefParam(t.i);
			if (this.markRef(e), r.t !== 4 && r.i != null && this.isMarked(r.i)) {
				let l$1 = "(" + this.serialize(r) + ",[" + n + "," + n + "])";
				return this.createSetAssignment(e, this.getRefParam(r.i), a), this.createDeleteAssignment(e, n), l$1;
			}
			let i$1 = this.stack;
			return this.stack = [], this.createSetAssignment(e, this.serialize(r), a), this.stack = i$1, "";
		}
		return "[" + this.serialize(r) + "," + this.serialize(t) + "]";
	}
	serializeMap(e) {
		let r = Br, t = e.e.s, n = e.i, a = e.f, i$1 = this.getRefParam(a.i);
		if (t) {
			let l$1 = e.e.k, c$1 = e.e.v;
			this.stack.push(n);
			let p$1 = this.serializeMapEntry(n, l$1[0], c$1[0], i$1);
			for (let h$1 = 1, X = p$1; h$1 < t; h$1++) X = this.serializeMapEntry(n, l$1[h$1], c$1[h$1], i$1), p$1 += (X && p$1 && ",") + X;
			this.stack.pop(), p$1 && (r += "([" + p$1 + "])");
		}
		return a.t === 26 && (this.markRef(a.i), r = "(" + this.serialize(a) + "," + r + ")"), this.assignIndexedValue(n, r);
	}
	serializeArrayBuffer(e) {
		let r = "new Uint8Array(", t = e.s, n = t.length;
		if (n) {
			r += "[" + t[0];
			for (let a = 1; a < n; a++) r += "," + t[a];
			r += "]";
		}
		return this.assignIndexedValue(e.i, r + ").buffer");
	}
	serializeTypedArray(e) {
		return this.assignIndexedValue(e.i, "new " + e.c + "(" + this.serialize(e.f) + "," + e.b + "," + e.l + ")");
	}
	serializeDataView(e) {
		return this.assignIndexedValue(e.i, "new DataView(" + this.serialize(e.f) + "," + e.b + "," + e.l + ")");
	}
	serializeAggregateError(e) {
		let r = e.i;
		this.stack.push(r);
		let t = this.serializeDictionary(e, "new AggregateError([],\\"" + e.m + "\\")");
		return this.stack.pop(), t;
	}
	serializeError(e) {
		return this.serializeDictionary(e, "new " + ue$1[e.s] + "(\\"" + e.m + "\\")");
	}
	serializePromise(e) {
		let r, t = e.f, n = e.i, a = e.s ? jr : _r;
		if (this.isIndexedValueInStack(t)) {
			let i$1 = this.getRefParam(t.i);
			r = a + (e.s ? "().then(" + this.createFunction([], i$1) + ")" : "().catch(" + this.createEffectfulFunction([], "throw " + i$1) + ")");
		} else {
			this.stack.push(n);
			let i$1 = this.serialize(t);
			this.stack.pop(), r = a + "(" + i$1 + ")";
		}
		return this.assignIndexedValue(n, r);
	}
	serializeWellKnownSymbol(e) {
		return this.assignIndexedValue(e.i, $e[e.s]);
	}
	serializeBoxed(e) {
		return this.assignIndexedValue(e.i, "Object(" + this.serialize(e.f) + ")");
	}
	serializePlugin(e) {
		let r = this.plugins;
		if (r) for (let t = 0, n = r.length; t < n; t++) {
			let a = r[t];
			if (a.tag === e.c) return this.assignIndexedValue(e.i, a.serialize(e.s, this, { id: e.i }));
		}
		throw new W(e.c);
	}
	getConstructor(e) {
		let r = this.serialize(e);
		return r === this.getRefParam(e.i) ? r : "(" + r + ")";
	}
	serializePromiseConstructor(e) {
		let r = this.assignIndexedValue(e.s, "{p:0,s:0,f:0}");
		return this.assignIndexedValue(e.i, this.getConstructor(e.f) + "(" + r + ")");
	}
	serializePromiseResolve(e) {
		return this.getConstructor(e.a[0]) + "(" + this.getRefParam(e.i) + "," + this.serialize(e.a[1]) + ")";
	}
	serializePromiseReject(e) {
		return this.getConstructor(e.a[0]) + "(" + this.getRefParam(e.i) + "," + this.serialize(e.a[1]) + ")";
	}
	serializeSpecialReference(e) {
		return this.assignIndexedValue(e.i, cr(this.features, e.s));
	}
	serializeIteratorFactory(e) {
		let r = "", t = !1;
		return e.f.t !== 4 && (this.markRef(e.f.i), r = "(" + this.serialize(e.f) + ",", t = !0), r += this.assignIndexedValue(e.i, this.createFunction(["s"], this.createFunction([
			"i",
			"c",
			"d",
			"t"
		], "(i=0,t={[" + this.getRefParam(e.f.i) + "]:" + this.createFunction([], "t") + ",next:" + this.createEffectfulFunction([], "if(i>s.d)return{done:!0,value:void 0};if(d=s.v[c=i++],c===s.t)throw d;return{done:c===s.d,value:d}") + "})"))), t && (r += ")"), r;
	}
	serializeIteratorFactoryInstance(e) {
		return this.getConstructor(e.a[0]) + "(" + this.serialize(e.a[1]) + ")";
	}
	serializeAsyncIteratorFactory(e) {
		let r = e.a[0], t = e.a[1], n = "";
		r.t !== 4 && (this.markRef(r.i), n += "(" + this.serialize(r)), t.t !== 4 && (this.markRef(t.i), n += (n ? "," : "(") + this.serialize(t)), n && (n += ",");
		let a = this.assignIndexedValue(e.i, this.createFunction(["s"], this.createFunction([
			"b",
			"c",
			"p",
			"d",
			"e",
			"t",
			"f"
		], "(b=[],c=0,p=[],d=-1,e=!1,f=" + this.createEffectfulFunction(["i", "l"], "for(i=0,l=p.length;i<l;i++)p[i].s({done:!0,value:void 0})") + ",s.on({next:" + this.createEffectfulFunction(["v", "t"], "if(t=p.shift())t.s({done:!1,value:v});b.push(v)") + ",throw:" + this.createEffectfulFunction(["v", "t"], "if(t=p.shift())t.f(v);f(),d=b.length,e=!0,b.push(v)") + ",return:" + this.createEffectfulFunction(["v", "t"], "if(t=p.shift())t.s({done:!0,value:v});f(),d=b.length,b.push(v)") + "}),t={[" + this.getRefParam(t.i) + "]:" + this.createFunction([], "t.p") + ",next:" + this.createEffectfulFunction([
			"i",
			"t",
			"v"
		], "if(d===-1){return((i=c++)>=b.length)?(" + this.getRefParam(r.i) + "(t={p:0,s:0,f:0}),p.push(t),t.p):{done:!1,value:b[i]}}if(c>d)return{done:!0,value:void 0};if(v=b[i=c++],i!==d)return{done:!1,value:v};if(e)throw v;return{done:!0,value:v}") + "})")));
		return n ? n + a + ")" : a;
	}
	serializeAsyncIteratorFactoryInstance(e) {
		return this.getConstructor(e.a[0]) + "(" + this.serialize(e.a[1]) + ")";
	}
	serializeStreamConstructor(e) {
		let r = this.assignIndexedValue(e.i, this.getConstructor(e.f) + "()"), t = e.a.length;
		if (t) {
			let n = this.serialize(e.a[0]);
			for (let a = 1; a < t; a++) n += "," + this.serialize(e.a[a]);
			return "(" + r + "," + n + "," + this.getRefParam(e.i) + ")";
		}
		return r;
	}
	serializeStreamNext(e) {
		return this.getRefParam(e.i) + ".next(" + this.serialize(e.f) + ")";
	}
	serializeStreamThrow(e) {
		return this.getRefParam(e.i) + ".throw(" + this.serialize(e.f) + ")";
	}
	serializeStreamReturn(e) {
		return this.getRefParam(e.i) + ".return(" + this.serialize(e.f) + ")";
	}
	serialize(e) {
		try {
			switch (e.t) {
				case 2: return qe[e.s];
				case 0: return "" + e.s;
				case 1: return "\\"" + e.s + "\\"";
				case 3: return e.s + "n";
				case 4: return this.getRefParam(e.i);
				case 18: return this.serializeReference(e);
				case 9: return this.serializeArray(e);
				case 10: return this.serializeObject(e);
				case 11: return this.serializeNullConstructor(e);
				case 5: return this.serializeDate(e);
				case 6: return this.serializeRegExp(e);
				case 7: return this.serializeSet(e);
				case 8: return this.serializeMap(e);
				case 19: return this.serializeArrayBuffer(e);
				case 16:
				case 15: return this.serializeTypedArray(e);
				case 20: return this.serializeDataView(e);
				case 14: return this.serializeAggregateError(e);
				case 13: return this.serializeError(e);
				case 12: return this.serializePromise(e);
				case 17: return this.serializeWellKnownSymbol(e);
				case 21: return this.serializeBoxed(e);
				case 22: return this.serializePromiseConstructor(e);
				case 23: return this.serializePromiseResolve(e);
				case 24: return this.serializePromiseReject(e);
				case 25: return this.serializePlugin(e);
				case 26: return this.serializeSpecialReference(e);
				case 27: return this.serializeIteratorFactory(e);
				case 28: return this.serializeIteratorFactoryInstance(e);
				case 29: return this.serializeAsyncIteratorFactory(e);
				case 30: return this.serializeAsyncIteratorFactoryInstance(e);
				case 31: return this.serializeStreamConstructor(e);
				case 32: return this.serializeStreamNext(e);
				case 33: return this.serializeStreamThrow(e);
				case 34: return this.serializeStreamReturn(e);
				default: throw new y$1(e);
			}
		} catch (r) {
			throw new Te(r);
		}
	}
};
var D = class extends V {
	constructor(r) {
		super(r);
		this.mode = "cross";
		this.scopeId = r.scopeId;
	}
	getRefParam(r) {
		return Q + "[" + r + "]";
	}
	assignIndexedValue(r, t) {
		return this.getRefParam(r) + "=" + t;
	}
	serializeTop(r) {
		let t = this.serialize(r), n = r.i;
		if (n == null) return t;
		let a = this.resolvePatches(), i$1 = this.getRefParam(n), l$1 = this.scopeId == null ? "" : Q, c$1 = a ? "(" + t + "," + a + i$1 + ")" : t;
		if (l$1 === "") return r.t === 10 && !a ? "(" + c$1 + ")" : c$1;
		let p$1 = this.scopeId == null ? "()" : "(" + Q + "[\\"" + d(this.scopeId) + "\\"])";
		return "(" + this.createFunction([l$1], c$1) + ")" + p$1;
	}
};
var v = class extends Y$1 {
	parseItems(e) {
		let r = [];
		for (let t = 0, n = e.length; t < n; t++) t in e && (r[t] = this.parse(e[t]));
		return r;
	}
	parseArray(e, r) {
		return Ne(e, r, this.parseItems(r));
	}
	parseProperties(e) {
		let r = Object.entries(e), t = [], n = [];
		for (let i$1 = 0, l$1 = r.length; i$1 < l$1; i$1++) t.push(d(r[i$1][0])), n.push(this.parse(r[i$1][1]));
		let a = Symbol.iterator;
		return a in e && (t.push(this.parseWellKnownSymbol(a)), n.push(M(this.parseIteratorFactory(), this.parse(J(e))))), a = Symbol.asyncIterator, a in e && (t.push(this.parseWellKnownSymbol(a)), n.push(U(this.parseAsyncIteratorFactory(), this.parse(K$1())))), a = Symbol.toStringTag, a in e && (t.push(this.parseWellKnownSymbol(a)), n.push(w$1(e[a]))), a = Symbol.isConcatSpreadable, a in e && (t.push(this.parseWellKnownSymbol(a)), n.push(e[a] ? I : A$1)), {
			k: t,
			v: n,
			s: t.length
		};
	}
	parsePlainObject(e, r, t) {
		return this.createObjectNode(e, r, t, this.parseProperties(r));
	}
	parseBoxed(e, r) {
		return be(e, this.parse(r.valueOf()));
	}
	parseTypedArray(e, r) {
		return xe(e, r, this.parse(r.buffer));
	}
	parseBigIntTypedArray(e, r) {
		return Ie(e, r, this.parse(r.buffer));
	}
	parseDataView(e, r) {
		return Ae(e, r, this.parse(r.buffer));
	}
	parseError(e, r) {
		let t = j(r, this.features);
		return we(e, r, t ? this.parseProperties(t) : s$1);
	}
	parseAggregateError(e, r) {
		let t = j(r, this.features);
		return Ee(e, r, t ? this.parseProperties(t) : s$1);
	}
	parseMap(e, r) {
		let t = [], n = [];
		for (let [a, i$1] of r.entries()) t.push(this.parse(a)), n.push(this.parse(i$1));
		return this.createMapNode(e, t, n, r.size);
	}
	parseSet(e, r) {
		let t = [];
		for (let n of r.keys()) t.push(this.parse(n));
		return Pe(e, r.size, t);
	}
	parsePlugin(e, r) {
		let t = this.plugins;
		if (t) for (let n = 0, a = t.length; n < a; n++) {
			let i$1 = t[n];
			if (i$1.parse.sync && i$1.test(r)) return _$1(e, i$1.tag, i$1.parse.sync(r, this, { id: e }));
		}
	}
	parseStream(e, r) {
		return L(e, this.parseSpecialReference(4), []);
	}
	parsePromise(e, r) {
		return this.createPromiseConstructorNode(e, this.createIndex({}));
	}
	parseObject(e, r) {
		if (Array.isArray(r)) return this.parseArray(e, r);
		if (Fe(r)) return this.parseStream(e, r);
		let t = r.constructor;
		if (t === T) return this.parse(r.replacement);
		let n = this.parsePlugin(e, r);
		if (n) return n;
		switch (t) {
			case Object: return this.parsePlainObject(e, r, !1);
			case void 0: return this.parsePlainObject(e, r, !0);
			case Date: return he(e, r);
			case RegExp: return ye(e, r);
			case Error:
			case EvalError:
			case RangeError:
			case ReferenceError:
			case SyntaxError:
			case TypeError:
			case URIError: return this.parseError(e, r);
			case Number:
			case Boolean:
			case String:
			case BigInt: return this.parseBoxed(e, r);
			case ArrayBuffer: return ve(e, r);
			case Int8Array:
			case Int16Array:
			case Int32Array:
			case Uint8Array:
			case Uint16Array:
			case Uint32Array:
			case Uint8ClampedArray:
			case Float32Array:
			case Float64Array: return this.parseTypedArray(e, r);
			case DataView: return this.parseDataView(e, r);
			case Map: return this.parseMap(e, r);
			case Set: return this.parseSet(e, r);
			default: break;
		}
		if (t === Promise || r instanceof Promise) return this.parsePromise(e, r);
		let a = this.features;
		if (a & 16) switch (t) {
			case BigInt64Array:
			case BigUint64Array: return this.parseBigIntTypedArray(e, r);
			default: break;
		}
		if (a & 1 && typeof AggregateError != "undefined" && (t === AggregateError || r instanceof AggregateError)) return this.parseAggregateError(e, r);
		if (r instanceof Error) return this.parseError(e, r);
		if (Symbol.iterator in r || Symbol.asyncIterator in r) return this.parsePlainObject(e, r, !!t);
		throw new g$1(r);
	}
	parseFunction(e) {
		let r = this.getReference(e);
		if (r.type !== 0) return r.value;
		let t = this.parsePlugin(r.value, e);
		if (t) return t;
		throw new g$1(e);
	}
	parse(e) {
		switch (typeof e) {
			case "boolean": return e ? I : A$1;
			case "undefined": return pe;
			case "string": return w$1(e);
			case "number": return ge(e);
			case "bigint": return Se(e);
			case "object":
				if (e) {
					let r = this.getReference(e);
					return r.type === 0 ? this.parseObject(r.value, e) : r.value;
				}
				return de;
			case "symbol": return this.parseWellKnownSymbol(e);
			case "function": return this.parseFunction(e);
			default: throw new g$1(e);
		}
	}
	parseTop(e) {
		try {
			return this.parse(e);
		} catch (r) {
			throw r instanceof E$1 ? r : new E$1(r);
		}
	}
};
var oe = class extends v {
	constructor(r) {
		super(r);
		this.alive = !0;
		this.pending = 0;
		this.initial = !0;
		this.buffer = [];
		this.onParseCallback = r.onParse, this.onErrorCallback = r.onError, this.onDoneCallback = r.onDone;
	}
	onParseInternal(r, t) {
		try {
			this.onParseCallback(r, t);
		} catch (n) {
			this.onError(n);
		}
	}
	flush() {
		for (let r = 0, t = this.buffer.length; r < t; r++) this.onParseInternal(this.buffer[r], !1);
	}
	onParse(r) {
		this.initial ? this.buffer.push(r) : this.onParseInternal(r, !1);
	}
	onError(r) {
		if (this.onErrorCallback) this.onErrorCallback(r);
		else throw r;
	}
	onDone() {
		this.onDoneCallback && this.onDoneCallback();
	}
	pushPendingState() {
		this.pending++;
	}
	popPendingState() {
		--this.pending <= 0 && this.onDone();
	}
	parseProperties(r) {
		let t = Object.entries(r), n = [], a = [];
		for (let l$1 = 0, c$1 = t.length; l$1 < c$1; l$1++) n.push(d(t[l$1][0])), a.push(this.parse(t[l$1][1]));
		let i$1 = Symbol.iterator;
		return i$1 in r && (n.push(this.parseWellKnownSymbol(i$1)), a.push(M(this.parseIteratorFactory(), this.parse(J(r))))), i$1 = Symbol.asyncIterator, i$1 in r && (n.push(this.parseWellKnownSymbol(i$1)), a.push(U(this.parseAsyncIteratorFactory(), this.parse(Ve(r))))), i$1 = Symbol.toStringTag, i$1 in r && (n.push(this.parseWellKnownSymbol(i$1)), a.push(w$1(r[i$1]))), i$1 = Symbol.isConcatSpreadable, i$1 in r && (n.push(this.parseWellKnownSymbol(i$1)), a.push(r[i$1] ? I : A$1)), {
			k: n,
			v: a,
			s: n.length
		};
	}
	handlePromiseSuccess(r, t) {
		let n = this.parseWithError(t);
		n && this.onParse(u$1(23, r, s$1, s$1, s$1, s$1, s$1, s$1, [this.parseSpecialReference(2), n], s$1, s$1, s$1)), this.popPendingState();
	}
	handlePromiseFailure(r, t) {
		if (this.alive) {
			let n = this.parseWithError(t);
			n && this.onParse(u$1(24, r, s$1, s$1, s$1, s$1, s$1, s$1, [this.parseSpecialReference(3), n], s$1, s$1, s$1));
		}
		this.popPendingState();
	}
	parsePromise(r, t) {
		let n = this.createIndex({});
		return t.then(this.handlePromiseSuccess.bind(this, n), this.handlePromiseFailure.bind(this, n)), this.pushPendingState(), this.createPromiseConstructorNode(r, n);
	}
	parsePlugin(r, t) {
		let n = this.plugins;
		if (n) for (let a = 0, i$1 = n.length; a < i$1; a++) {
			let l$1 = n[a];
			if (l$1.parse.stream && l$1.test(t)) return _$1(r, l$1.tag, l$1.parse.stream(t, this, { id: r }));
		}
		return s$1;
	}
	parseStream(r, t) {
		let n = L(r, this.parseSpecialReference(4), []);
		return this.pushPendingState(), t.on({
			next: (a) => {
				if (this.alive) {
					let i$1 = this.parseWithError(a);
					i$1 && this.onParse(Re(r, i$1));
				}
			},
			throw: (a) => {
				if (this.alive) {
					let i$1 = this.parseWithError(a);
					i$1 && this.onParse(Oe(r, i$1));
				}
				this.popPendingState();
			},
			return: (a) => {
				if (this.alive) {
					let i$1 = this.parseWithError(a);
					i$1 && this.onParse(Ce(r, i$1));
				}
				this.popPendingState();
			}
		}), n;
	}
	parseWithError(r) {
		try {
			return this.parse(r);
		} catch (t) {
			return this.onError(t), s$1;
		}
	}
	start(r) {
		let t = this.parseWithError(r);
		t && (this.onParseInternal(t, !0), this.initial = !1, this.flush(), this.pending <= 0 && this.destroy());
	}
	destroy() {
		this.alive && (this.onDone(), this.alive = !1);
	}
	isAlive() {
		return this.alive;
	}
};
var G = class extends oe {
	constructor() {
		super(...arguments);
		this.mode = "cross";
	}
};
function gr(o$1, e) {
	let r = m$1(e.plugins), t = new G({
		plugins: r,
		refs: e.refs,
		disabledFeatures: e.disabledFeatures,
		onParse(n, a) {
			let i$1 = new D({
				plugins: r,
				features: t.features,
				scopeId: e.scopeId,
				markedRefs: t.marked
			}), l$1;
			try {
				l$1 = i$1.serializeTop(n);
			} catch (c$1) {
				e.onError && e.onError(c$1);
				return;
			}
			e.onSerialize(l$1, a);
		},
		onError: e.onError,
		onDone: e.onDone
	});
	return t.start(o$1), t.destroy.bind(t);
}
var yr = "hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_", Sr = yr.length, vr = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_", hr = vr.length;
var De = class {
	constructor(e) {
		this.options = e;
		this.alive = !0;
		this.flushed = !1;
		this.done = !1;
		this.pending = 0;
		this.cleanups = [];
		this.refs = /* @__PURE__ */ new Map();
		this.keys = /* @__PURE__ */ new Set();
		this.ids = 0;
		this.plugins = m$1(e.plugins);
	}
	write(e, r) {
		this.alive && !this.flushed && (this.pending++, this.keys.add(e), this.cleanups.push(gr(r, {
			plugins: this.plugins,
			scopeId: this.options.scopeId,
			refs: this.refs,
			disabledFeatures: this.options.disabledFeatures,
			onError: this.options.onError,
			onSerialize: (t, n) => {
				this.alive && this.options.onData(n ? this.options.globalIdentifier + "[\\"" + d(e) + "\\"]=" + t : t);
			},
			onDone: () => {
				this.alive && (this.pending--, this.pending <= 0 && this.flushed && !this.done && this.options.onDone && (this.options.onDone(), this.done = !0));
			}
		})));
	}
	getNextID() {
		for (; this.keys.has("" + this.ids);) this.ids++;
		return "" + this.ids;
	}
	push(e) {
		let r = this.getNextID();
		return this.write(r, e), r;
	}
	flush() {
		this.alive && (this.flushed = !0, this.pending <= 0 && !this.done && this.options.onDone && (this.options.onDone(), this.done = !0));
	}
	close() {
		if (this.alive) {
			for (let e = 0, r = this.cleanups.length; e < r; e++) this.cleanups[e]();
			!this.done && this.options.onDone && (this.options.onDone(), this.done = !0), this.alive = !1;
		}
	}
};

//#endregion
//#region node_modules/seroval-plugins/dist/esm/production/web.mjs
function h(e) {
	e(this.reason);
}
function A(e) {
	this.addEventListener("abort", h.bind(this, e), { once: !0 });
}
function E(e) {
	return new Promise(A.bind(e));
}
var o = class {
	constructor() {
		this.controller = new AbortController();
	}
}, F = Hr({
	tag: "seroval-plugins/web/AbortSignalController",
	test(e) {
		return e instanceof o;
	},
	parse: { stream() {} },
	serialize(e) {
		return "new AbortController";
	},
	deserialize(e) {
		return new o();
	}
}), s = class {
	constructor(r, a) {
		this.controller = r;
		this.reason = a;
	}
};
var C = Hr({
	tag: "seroval-plugins/web/AbortSignal",
	extends: [Hr({
		extends: [F],
		tag: "seroval-plugins/web/AbortSignalAbort",
		test(e) {
			return e instanceof s;
		},
		parse: { stream(e, r) {
			return {
				controller: r.parse(e.controller),
				reason: r.parse(e.reason)
			};
		} },
		serialize(e, r) {
			return r.serialize(e.controller) + ".abort(" + r.serialize(e.reason) + ")";
		},
		deserialize(e, r) {
			let a = r.deserialize(e.controller), t = r.deserialize(e.reason);
			return a.controller.abort(t), new s(a, t);
		}
	})],
	test(e) {
		return typeof AbortSignal == "undefined" ? !1 : e instanceof AbortSignal;
	},
	parse: {
		sync(e, r) {
			return e.aborted ? {
				type: 1,
				reason: r.parse(e.reason)
			} : { type: 0 };
		},
		async async(e, r) {
			if (e.aborted) return {
				type: 1,
				reason: await r.parse(e.reason)
			};
			let a = await E(e);
			return {
				type: 1,
				reason: await r.parse(a)
			};
		},
		stream(e, r) {
			if (e.aborted) return {
				type: 1,
				reason: r.parse(e.reason)
			};
			let a = new o();
			return r.pushPendingState(), e.addEventListener("abort", () => {
				let t = r.parseWithError(new s(a, e.reason));
				t && r.onParse(t), r.popPendingState();
			}, { once: !0 }), {
				type: 2,
				controller: r.parse(a)
			};
		}
	},
	serialize(e, r) {
		return e.type === 0 ? "(new AbortController).signal" : e.type === 1 ? "AbortSignal.abort(" + r.serialize(e.reason) + ")" : "(" + r.serialize(e.controller) + ").signal";
	},
	deserialize(e, r) {
		return e.type === 0 ? new AbortController().signal : e.type === 1 ? AbortSignal.abort(r.deserialize(e.reason)) : r.deserialize(e.controller).controller.signal;
	}
});
var O = Hr({
	tag: "seroval-plugins/web/Blob",
	test(e) {
		return typeof Blob == "undefined" ? !1 : e instanceof Blob;
	},
	parse: { async async(e, r) {
		return {
			type: await r.parse(e.type),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new Blob([" + r.serialize(e.buffer) + "],{type:" + r.serialize(e.type) + "})";
	},
	deserialize(e, r) {
		return new Blob([r.deserialize(e.buffer)], { type: r.deserialize(e.type) });
	}
});
function f(e) {
	return {
		detail: e.detail,
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var H = Hr({
	tag: "seroval-plugins/web/CustomEvent",
	test(e) {
		return typeof CustomEvent == "undefined" ? !1 : e instanceof CustomEvent;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(f(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		}
	},
	serialize(e, r) {
		return "new CustomEvent(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new CustomEvent(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var _ = Hr({
	tag: "seroval-plugins/web/DOMException",
	test(e) {
		return typeof DOMException == "undefined" ? !1 : e instanceof DOMException;
	},
	parse: {
		sync(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		},
		async async(e, r) {
			return {
				name: await r.parse(e.name),
				message: await r.parse(e.message)
			};
		},
		stream(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		}
	},
	serialize(e, r) {
		return "new DOMException(" + r.serialize(e.message) + "," + r.serialize(e.name) + ")";
	},
	deserialize(e, r) {
		return new DOMException(r.deserialize(e.message), r.deserialize(e.name));
	}
});
function m(e) {
	return {
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var Y = Hr({
	tag: "seroval-plugins/web/Event",
	test(e) {
		return typeof Event == "undefined" ? !1 : e instanceof Event;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(m(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(m(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(m(e))
			};
		}
	},
	serialize(e, r) {
		return "new Event(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Event(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var c = Hr({
	tag: "seroval-plugins/web/File",
	test(e) {
		return typeof File == "undefined" ? !1 : e instanceof File;
	},
	parse: { async async(e, r) {
		return {
			name: await r.parse(e.name),
			options: await r.parse({
				type: e.type,
				lastModified: e.lastModified
			}),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new File([" + r.serialize(e.buffer) + "]," + r.serialize(e.name) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new File([r.deserialize(e.buffer)], r.deserialize(e.name), r.deserialize(e.options));
	}
});
function g(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var i = {}, K = Hr({
	tag: "seroval-plugins/web/FormData",
	extends: [c, Hr({
		tag: "seroval-plugins/web/FormDataFactory",
		test(e) {
			return e === i;
		},
		parse: {
			sync() {},
			async async() {
				return await Promise.resolve(void 0);
			},
			stream() {}
		},
		serialize(e, r) {
			return r.createEffectfulFunction([
				"e",
				"f",
				"i",
				"s",
				"t"
			], "f=new FormData;for(i=0,s=e.length;i<s;i++)f.append((t=e[i])[0],t[1]);return f");
		},
		deserialize() {
			return i;
		}
	})],
	test(e) {
		return typeof FormData == "undefined" ? !1 : e instanceof FormData;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(i),
				entries: r.parse(g(e))
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(i),
				entries: await r.parse(g(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(i),
				entries: r.parse(g(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.entries) + ")";
	},
	deserialize(e, r) {
		let a = new FormData(), t = r.deserialize(e.entries);
		for (let n = 0, R$1 = t.length; n < R$1; n++) {
			let b = t[n];
			a.append(b[0], b[1]);
		}
		return a;
	}
});
function y(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var l = Hr({
	tag: "seroval-plugins/web/Headers",
	test(e) {
		return typeof Headers == "undefined" ? !1 : e instanceof Headers;
	},
	parse: {
		sync(e, r) {
			return r.parse(y(e));
		},
		async async(e, r) {
			return await r.parse(y(e));
		},
		stream(e, r) {
			return r.parse(y(e));
		}
	},
	serialize(e, r) {
		return "new Headers(" + r.serialize(e) + ")";
	},
	deserialize(e, r) {
		return new Headers(r.deserialize(e));
	}
});
var x = Hr({
	tag: "seroval-plugins/web/ImageData",
	test(e) {
		return typeof ImageData == "undefined" ? !1 : e instanceof ImageData;
	},
	parse: {
		sync(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		},
		async async(e, r) {
			return {
				data: await r.parse(e.data),
				width: await r.parse(e.width),
				height: await r.parse(e.height),
				options: await r.parse({ colorSpace: e.colorSpace })
			};
		},
		stream(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		}
	},
	serialize(e, r) {
		return "new ImageData(" + r.serialize(e.data) + "," + r.serialize(e.width) + "," + r.serialize(e.height) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new ImageData(r.deserialize(e.data), r.deserialize(e.width), r.deserialize(e.height), r.deserialize(e.options));
	}
});
var p = {}, ee = Hr({
	tag: "seroval-plugins/web/ReadableStreamFactory",
	test(e) {
		return e === p;
	},
	parse: {
		sync() {},
		async async() {
			return await Promise.resolve(void 0);
		},
		stream() {}
	},
	serialize(e, r) {
		return r.createFunction(["d"], "new ReadableStream({start:" + r.createEffectfulFunction(["c"], "d.on({next:" + r.createEffectfulFunction(["v"], "c.enqueue(v)") + ",throw:" + r.createEffectfulFunction(["v"], "c.error(v)") + ",return:" + r.createEffectfulFunction([], "c.close()") + "})") + "})");
	},
	deserialize() {
		return p;
	}
});
function w(e) {
	let r = K$1(), a = e.getReader();
	async function t() {
		try {
			let n = await a.read();
			n.done ? r.return(n.value) : (r.next(n.value), await t());
		} catch (n) {
			r.throw(n);
		}
	}
	return t().catch(() => {}), r;
}
var u = Hr({
	tag: "seroval/plugins/web/ReadableStream",
	extends: [ee],
	test(e) {
		return typeof ReadableStream == "undefined" ? !1 : e instanceof ReadableStream;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(p),
				stream: r.parse(K$1())
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(p),
				stream: await r.parse(w(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(p),
				stream: r.parse(w(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.stream) + ")";
	},
	deserialize(e, r) {
		let a = r.deserialize(e.stream);
		return new ReadableStream({ start(t) {
			a.on({
				next(n) {
					t.enqueue(n);
				},
				throw(n) {
					t.error(n);
				},
				return() {
					t.close();
				}
			});
		} });
	}
});
function P(e, r) {
	return {
		body: r,
		cache: e.cache,
		credentials: e.credentials,
		headers: e.headers,
		integrity: e.integrity,
		keepalive: e.keepalive,
		method: e.method,
		mode: e.mode,
		redirect: e.redirect,
		referrer: e.referrer,
		referrerPolicy: e.referrerPolicy
	};
}
var ne = Hr({
	tag: "seroval-plugins/web/Request",
	extends: [u, l],
	test(e) {
		return typeof Request == "undefined" ? !1 : e instanceof Request;
	},
	parse: {
		async async(e, r) {
			return {
				url: await r.parse(e.url),
				options: await r.parse(P(e, e.body ? await e.clone().arrayBuffer() : null))
			};
		},
		stream(e, r) {
			return {
				url: r.parse(e.url),
				options: r.parse(P(e, e.clone().body))
			};
		}
	},
	serialize(e, r) {
		return "new Request(" + r.serialize(e.url) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Request(r.deserialize(e.url), r.deserialize(e.options));
	}
});
function N(e) {
	return {
		headers: e.headers,
		status: e.status,
		statusText: e.statusText
	};
}
var ie = Hr({
	tag: "seroval-plugins/web/Response",
	extends: [u, l],
	test(e) {
		return typeof Response == "undefined" ? !1 : e instanceof Response;
	},
	parse: {
		async async(e, r) {
			return {
				body: await r.parse(e.body ? await e.clone().arrayBuffer() : null),
				options: await r.parse(N(e))
			};
		},
		stream(e, r) {
			return {
				body: r.parse(e.clone().body),
				options: r.parse(N(e))
			};
		}
	},
	serialize(e, r) {
		return "new Response(" + r.serialize(e.body) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Response(r.deserialize(e.body), r.deserialize(e.options));
	}
});
var ue = Hr({
	tag: "seroval-plugins/web/URL",
	test(e) {
		return typeof URL == "undefined" ? !1 : e instanceof URL;
	},
	parse: {
		sync(e, r) {
			return r.parse(e.href);
		},
		async async(e, r) {
			return await r.parse(e.href);
		},
		stream(e, r) {
			return r.parse(e.href);
		}
	},
	serialize(e, r) {
		return "new URL(" + r.serialize(e) + ")";
	},
	deserialize(e, r) {
		return new URL(r.deserialize(e));
	}
});
var me = Hr({
	tag: "seroval-plugins/web/URLSearchParams",
	test(e) {
		return typeof URLSearchParams == "undefined" ? !1 : e instanceof URLSearchParams;
	},
	parse: {
		sync(e, r) {
			return r.parse(e.toString());
		},
		async async(e, r) {
			return await r.parse(e.toString());
		},
		stream(e, r) {
			return r.parse(e.toString());
		}
	},
	serialize(e, r) {
		return "new URLSearchParams(" + r.serialize(e) + ")";
	},
	deserialize(e, r) {
		return new URLSearchParams(r.deserialize(e));
	}
});

//#endregion
//#region node_modules/solid-js/web/dist/server.js
const booleans = [
	"allowfullscreen",
	"async",
	"alpha",
	"autofocus",
	"autoplay",
	"checked",
	"controls",
	"default",
	"disabled",
	"formnovalidate",
	"hidden",
	"indeterminate",
	"inert",
	"ismap",
	"loop",
	"multiple",
	"muted",
	"nomodule",
	"novalidate",
	"open",
	"playsinline",
	"readonly",
	"required",
	"reversed",
	"seamless",
	"selected",
	"adauctionheaders",
	"browsingtopics",
	"credentialless",
	"defaultchecked",
	"defaultmuted",
	"defaultselected",
	"defer",
	"disablepictureinpicture",
	"disableremoteplayback",
	"preservespitch",
	"shadowrootclonable",
	"shadowrootcustomelementregistry",
	"shadowrootdelegatesfocus",
	"shadowrootserializable",
	"sharedstoragewritable"
];
const Properties = /* @__PURE__ */ new Set([
	"className",
	"value",
	"readOnly",
	"noValidate",
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"adAuctionHeaders",
	"allowFullscreen",
	"browsingTopics",
	"defaultChecked",
	"defaultMuted",
	"defaultSelected",
	"disablePictureInPicture",
	"disableRemotePlayback",
	"preservesPitch",
	"shadowRootClonable",
	"shadowRootCustomElementRegistry",
	"shadowRootDelegatesFocus",
	"shadowRootSerializable",
	"sharedStorageWritable",
	...booleans
]);
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
const ES2017FLAG = R.AggregateError | R.BigIntTypedArray;
const GLOBAL_IDENTIFIER = "_$HY.r";
function createSerializer({ onData, onDone, scopeId, onError, plugins: customPlugins }) {
	const defaultPlugins = [
		C,
		H,
		_,
		Y,
		K,
		l,
		u,
		ne,
		ie,
		me,
		ue
	];
	return new De({
		scopeId,
		plugins: customPlugins ? [...customPlugins, ...defaultPlugins] : defaultPlugins,
		globalIdentifier: GLOBAL_IDENTIFIER,
		disabledFeatures: ES2017FLAG,
		onData,
		onDone,
		onError
	});
}
function getLocalHeaderScript(id) {
	return xr(id) + ";";
}
function renderToString(code, options = {}) {
	const { renderId } = options;
	let scripts = "";
	const serializer = createSerializer({
		scopeId: renderId,
		plugins: options.plugins,
		onData(script) {
			if (!scripts) scripts = getLocalHeaderScript(renderId);
			scripts += script + ";";
		},
		onError: options.onError
	});
	sharedConfig.context = {
		id: renderId || "",
		count: 0,
		suspense: {},
		lazy: {},
		assets: [],
		nonce: options.nonce,
		serialize(id, p$1) {
			!sharedConfig.context.noHydrate && serializer.write(id, p$1);
		},
		roots: 0,
		nextRoot() {
			return this.renderId + "i-" + this.roots++;
		}
	};
	let html = createRoot((d$1) => {
		setTimeout(d$1);
		return resolveSSRNode(escape(code()));
	});
	sharedConfig.context.noHydrate = true;
	serializer.close();
	html = injectAssets(sharedConfig.context.assets, html);
	if (scripts.length) html = injectScripts(html, scripts, options.nonce);
	return html;
}
function ssr(t, ...nodes) {
	if (nodes.length) {
		let result = "";
		for (let i$1 = 0; i$1 < nodes.length; i$1++) {
			result += t[i$1];
			const node = nodes[i$1];
			if (node !== void 0) result += resolveSSRNode(node);
		}
		t = result + t[nodes.length];
	}
	return { t };
}
function escape(s$2, attr) {
	const t = typeof s$2;
	if (t !== "string") {
		if (!attr && t === "function") return escape(s$2());
		if (!attr && Array.isArray(s$2)) {
			s$2 = s$2.slice();
			for (let i$1 = 0; i$1 < s$2.length; i$1++) s$2[i$1] = escape(s$2[i$1]);
			return s$2;
		}
		if (attr && t === "boolean") return String(s$2);
		return s$2;
	}
	const delim = attr ? "\\"" : "<";
	const escDelim = attr ? "&quot;" : "&lt;";
	let iDelim = s$2.indexOf(delim);
	let iAmp = s$2.indexOf("&");
	if (iDelim < 0 && iAmp < 0) return s$2;
	let left = 0, out = "";
	while (iDelim >= 0 && iAmp >= 0) if (iDelim < iAmp) {
		if (left < iDelim) out += s$2.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s$2.indexOf(delim, left);
	} else {
		if (left < iAmp) out += s$2.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s$2.indexOf("&", left);
	}
	if (iDelim >= 0) do {
		if (left < iDelim) out += s$2.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s$2.indexOf(delim, left);
	} while (iDelim >= 0);
	else while (iAmp >= 0) {
		if (left < iAmp) out += s$2.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s$2.indexOf("&", left);
	}
	return left < s$2.length ? out + s$2.substring(left) : out;
}
function resolveSSRNode(node, top) {
	const t = typeof node;
	if (t === "string") return node;
	if (node == null || t === "boolean") return "";
	if (Array.isArray(node)) {
		let prev = {};
		let mapped = "";
		for (let i$1 = 0, len = node.length; i$1 < len; i$1++) {
			if (!top && typeof prev !== "object" && typeof node[i$1] !== "object") mapped += \`<!--!$-->\`;
			mapped += resolveSSRNode(prev = node[i$1]);
		}
		return mapped;
	}
	if (t === "object") return node.t;
	if (t === "function") return resolveSSRNode(node());
	return String(node);
}
function injectAssets(assets, html) {
	if (!assets || !assets.length) return html;
	let out = "";
	for (let i$1 = 0, len = assets.length; i$1 < len; i$1++) out += assets[i$1]();
	const index = html.indexOf("</head>");
	if (index === -1) return html;
	return html.slice(0, index) + out + html.slice(index);
}
function injectScripts(html, scripts, nonce) {
	const tag = \`<script\${nonce ? \` nonce="\${nonce}"\` : ""}>\${scripts}<\\/script>\`;
	const index = html.indexOf("<!--xs-->");
	if (index > -1) return html.slice(0, index) + tag + html.slice(index);
	return html + tag;
}

//#endregion
//#region tests/fixtures/ssr.tsx
var _tmpl$ = ["<button type=\\"button\\">", "</button>"];
const App = () => {
	const [count, setCount] = createSignal(0);
	return ssr(_tmpl$, escape(count()));
};
var ssr_default = renderToString(App);

//#endregion
export { ssr_default as default };"
`;

exports[`rolldown-plugin-solid should transform with hydratable option 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
	sharedConfig.context = context;
}
function nextHydrateContext() {
	return {
		...sharedConfig.context,
		id: sharedConfig.getNextContextId(),
		count: 0
	};
}
const equalFn = (a, b) => a === b;
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
	const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
		owned: null,
		cleanups: null,
		context: current ? current.context : null,
		owner: current
	}, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
	Owner = root;
	Listener = null;
	try {
		return runUpdates(updateFn, true);
	} finally {
		Listener = listener;
		Owner = owner;
	}
}
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}
let hydrationEnabled = false;
function createComponent(Comp, props) {
	if (hydrationEnabled) {
		if (sharedConfig.context) {
			const c = sharedConfig.context;
			setHydrateContext(nextHydrateContext());
			const r = untrack(() => Comp(props || {}));
			setHydrateContext(c);
			return r;
		}
	}
	return untrack(() => Comp(props || {}));
}

//#endregion
//#region node_modules/solid-js/web/dist/web.js
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
function reconcileArrays(parentNode, a, b) {
	let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
	while (aStart < aEnd || bStart < bEnd) {
		if (a[aStart] === b[bStart]) {
			aStart++;
			bStart++;
			continue;
		}
		while (a[aEnd - 1] === b[bEnd - 1]) {
			aEnd--;
			bEnd--;
		}
		if (aEnd === aStart) {
			const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
			while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
		} else if (bEnd === bStart) while (aStart < aEnd) {
			if (!map || !map.has(a[aStart])) a[aStart].remove();
			aStart++;
		}
		else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
			const node = a[--aEnd].nextSibling;
			parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
			parentNode.insertBefore(b[--bEnd], node);
			a[aEnd] = b[bEnd];
		} else {
			if (!map) {
				map = /* @__PURE__ */ new Map();
				let i = bStart;
				while (i < bEnd) map.set(b[i], i++);
			}
			const index = map.get(a[aStart]);
			if (index != null) if (bStart < index && index < bEnd) {
				let i = aStart, sequence = 1, t;
				while (++i < aEnd && i < bEnd) {
					if ((t = map.get(a[i])) == null || t !== index + sequence) break;
					sequence++;
				}
				if (sequence > index - bStart) {
					const node = a[aStart];
					while (bStart < index) parentNode.insertBefore(b[bStart++], node);
				} else parentNode.replaceChild(b[bStart++], a[aStart++]);
			} else aStart++;
			else a[aStart++].remove();
		}
	}
}
const $$EVENTS = "_$DX_DELEGATE";
function render(code, element, init, options = {}) {
	let disposer;
	createRoot((dispose) => {
		disposer = dispose;
		element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
	}, options.owner);
	return () => {
		disposer();
		element.textContent = "";
	};
}
function template(html, isImportNode, isSVG, isMathML) {
	let node;
	const create = () => {
		const t = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
		t.innerHTML = html;
		return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;
	};
	const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
	fn.cloneNode = fn;
	return fn;
}
function delegateEvents(eventNames, document$1 = window.document) {
	const e = document$1[$$EVENTS] || (document$1[$$EVENTS] = /* @__PURE__ */ new Set());
	for (let i = 0, l = eventNames.length; i < l; i++) {
		const name = eventNames[i];
		if (!e.has(name)) {
			e.add(name);
			document$1.addEventListener(name, eventHandler);
		}
	}
}
function insert(parent, accessor, marker, initial) {
	if (marker !== void 0 && !initial) initial = [];
	if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
	createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function getNextElement(template$1) {
	let node, key;
	if (!isHydrating() || !(node = sharedConfig.registry.get(key = getHydrationKey()))) return template$1();
	if (sharedConfig.completed) sharedConfig.completed.add(node);
	sharedConfig.registry.delete(key);
	return node;
}
function runHydrationEvents() {
	if (sharedConfig.events && !sharedConfig.events.queued) {
		queueMicrotask(() => {
			const { completed, events } = sharedConfig;
			if (!events) return;
			events.queued = false;
			while (events.length) {
				const [el, e] = events[0];
				if (!completed.has(el)) return;
				events.shift();
				eventHandler(e);
			}
			if (sharedConfig.done) {
				sharedConfig.events = _$HY.events = null;
				sharedConfig.completed = _$HY.completed = null;
			}
		});
		sharedConfig.events.queued = true;
	}
}
function isHydrating(node) {
	return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function eventHandler(e) {
	if (sharedConfig.registry && sharedConfig.events) {
		if (sharedConfig.events.find(([el, ev]) => ev === e)) return;
	}
	let node = e.target;
	const key = \`$$\${e.type}\`;
	const oriTarget = e.target;
	const oriCurrentTarget = e.currentTarget;
	const retarget = (value) => Object.defineProperty(e, "target", {
		configurable: true,
		value
	});
	const handleNode = () => {
		const handler = node[key];
		if (handler && !node.disabled) {
			const data = node[\`\${key}Data\`];
			data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
			if (e.cancelBubble) return;
		}
		node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
		return true;
	};
	const walkUpTree = () => {
		while (handleNode() && (node = node._$host || node.parentNode || node.host));
	};
	Object.defineProperty(e, "currentTarget", {
		configurable: true,
		get() {
			return node || document;
		}
	});
	if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
	if (e.composedPath) {
		const path = e.composedPath();
		retarget(path[0]);
		for (let i = 0; i < path.length - 2; i++) {
			node = path[i];
			if (!handleNode()) break;
			if (node._$host) {
				node = node._$host;
				walkUpTree();
				break;
			}
			if (node.parentNode === oriCurrentTarget) break;
		}
	} else walkUpTree();
	retarget(oriTarget);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
	const hydrating = isHydrating(parent);
	if (hydrating) {
		!current && (current = [...parent.childNodes]);
		let cleaned = [];
		for (let i = 0; i < current.length; i++) {
			const node = current[i];
			if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
			else cleaned.push(node);
		}
		current = cleaned;
	}
	while (typeof current === "function") current = current();
	if (value === current) return current;
	const t = typeof value, multi = marker !== void 0;
	parent = multi && current[0] && current[0].parentNode || parent;
	if (t === "string" || t === "number") {
		if (hydrating) return current;
		if (t === "number") {
			value = value.toString();
			if (value === current) return current;
		}
		if (multi) {
			let node = current[0];
			if (node && node.nodeType === 3) node.data !== value && (node.data = value);
			else node = document.createTextNode(value);
			current = cleanChildren(parent, current, marker, node);
		} else if (current !== "" && typeof current === "string") current = parent.firstChild.data = value;
		else current = parent.textContent = value;
	} else if (value == null || t === "boolean") {
		if (hydrating) return current;
		current = cleanChildren(parent, current, marker);
	} else if (t === "function") {
		createRenderEffect(() => {
			let v = value();
			while (typeof v === "function") v = v();
			current = insertExpression(parent, v, current, marker);
		});
		return () => current;
	} else if (Array.isArray(value)) {
		const array = [];
		const currentArray = current && Array.isArray(current);
		if (normalizeIncomingArray(array, value, current, unwrapArray)) {
			createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
			return () => current;
		}
		if (hydrating) {
			if (!array.length) return current;
			if (marker === void 0) return current = [...parent.childNodes];
			let node = array[0];
			if (node.parentNode !== parent) return current;
			const nodes = [node];
			while ((node = node.nextSibling) !== marker) nodes.push(node);
			return current = nodes;
		}
		if (array.length === 0) {
			current = cleanChildren(parent, current, marker);
			if (multi) return current;
		} else if (currentArray) if (current.length === 0) appendNodes(parent, array, marker);
		else reconcileArrays(parent, current, array);
		else {
			current && cleanChildren(parent);
			appendNodes(parent, array);
		}
		current = array;
	} else if (value.nodeType) {
		if (hydrating && value.parentNode) return current = multi ? [value] : value;
		if (Array.isArray(current)) {
			if (multi) return current = cleanChildren(parent, current, marker, value);
			cleanChildren(parent, current, null, value);
		} else if (current == null || current === "" || !parent.firstChild) parent.appendChild(value);
		else parent.replaceChild(value, parent.firstChild);
		current = value;
	}
	return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
	let dynamic = false;
	for (let i = 0, len = array.length; i < len; i++) {
		let item = array[i], prev = current && current[normalized.length], t;
		if (item == null || item === true || item === false);
		else if ((t = typeof item) === "object" && item.nodeType) normalized.push(item);
		else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
		else if (t === "function") if (unwrap) {
			while (typeof item === "function") item = item();
			dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
		} else {
			normalized.push(item);
			dynamic = true;
		}
		else {
			const value = String(item);
			if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
			else normalized.push(document.createTextNode(value));
		}
	}
	return dynamic;
}
function appendNodes(parent, array, marker = null) {
	for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
	if (marker === void 0) return parent.textContent = "";
	const node = replacement || document.createTextNode("");
	if (current.length) {
		let inserted = false;
		for (let i = current.length - 1; i >= 0; i--) {
			const el = current[i];
			if (node !== el) {
				const isParent = el.parentNode === parent;
				if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
				else isParent && el.remove();
			} else inserted = true;
		}
	} else parent.insertBefore(node, marker);
	return [node];
}
function getHydrationKey() {
	return sharedConfig.getNextContextId();
}

//#endregion
//#region tests/fixtures/basic.tsx
var _tmpl$ = /* @__PURE__ */ template(\`<button type=button>\`);
const App = () => {
	const [count, setCount] = createSignal(0);
	const inc = (by = 1) => setCount(count() + by);
	return (() => {
		var _el$ = getNextElement(_tmpl$);
		_el$.$$click = () => inc(1);
		insert(_el$, count);
		runHydrationEvents();
		return _el$;
	})();
};
render(() => createComponent(App, {}), document.getElementById("app"));
delegateEvents(["click"]);

//#endregion"
`;

exports[`rolldown-plugin-solid should transform SSR with hydratable option 1`] = `
"//#region node_modules/solid-js/dist/server.js
const ERROR = Symbol("error");
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function handleError(err, owner = Owner) {
	const fns = owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	try {
		for (const f$2 of fns) f$2(error);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
const UNOWNED = {
	context: null,
	owner: null,
	owned: null,
	cleanups: null
};
let Owner = null;
function createOwner() {
	const o$1 = {
		owner: Owner,
		context: Owner ? Owner.context : null,
		owned: null,
		cleanups: null
	};
	if (Owner) if (!Owner.owned) Owner.owned = [o$1];
	else Owner.owned.push(o$1);
	return o$1;
}
function createRoot(fn, detachedOwner) {
	const owner = Owner, current = detachedOwner === void 0 ? owner : detachedOwner, root = fn.length === 0 ? UNOWNED : {
		context: current ? current.context : null,
		owner: current,
		owned: null,
		cleanups: null
	};
	Owner = root;
	let result;
	try {
		result = fn(fn.length === 0 ? () => {} : () => cleanNode(root));
	} catch (err) {
		handleError(err);
	} finally {
		Owner = owner;
	}
	return result;
}
function createSignal(value, options) {
	return [() => value, (v$1) => {
		return value = typeof v$1 === "function" ? v$1(value) : v$1;
	}];
}
function createMemo(fn, value) {
	Owner = createOwner();
	let v$1;
	try {
		v$1 = fn(value);
	} catch (err) {
		handleError(err);
	} finally {
		Owner = Owner.owner;
	}
	return () => v$1;
}
function cleanNode(node) {
	if (node.owned) {
		for (let i$1 = 0; i$1 < node.owned.length; i$1++) cleanNode(node.owned[i$1]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (let i$1 = 0; i$1 < node.cleanups.length; i$1++) node.cleanups[i$1]();
		node.cleanups = null;
	}
}
function createContext(defaultValue) {
	const id = Symbol("context");
	return {
		id,
		Provider: createProvider(id),
		defaultValue
	};
}
function children(fn) {
	const memo = createMemo(() => resolveChildren(fn()));
	memo.toArray = () => {
		const c$1 = memo();
		return Array.isArray(c$1) ? c$1 : c$1 != null ? [c$1] : [];
	};
	return memo;
}
function resolveChildren(children$1) {
	if (typeof children$1 === "function" && !children$1.length) return resolveChildren(children$1());
	if (Array.isArray(children$1)) {
		const results = [];
		for (let i$1 = 0; i$1 < children$1.length; i$1++) {
			const result = resolveChildren(children$1[i$1]);
			Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
		}
		return results;
	}
	return children$1;
}
function createProvider(id) {
	return function provider(props) {
		return createMemo(() => {
			Owner.context = {
				...Owner.context,
				[id]: props.value
			};
			return children(() => props.children);
		});
	};
}
const sharedConfig = {
	context: void 0,
	getContextId() {
		if (!this.context) throw new Error(\`getContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count);
	},
	getNextContextId() {
		if (!this.context) throw new Error(\`getNextContextId cannot be used under non-hydrating context\`);
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
const SuspenseContext = createContext();

//#endregion
//#region node_modules/seroval/dist/esm/production/index.mjs
var R = ((a) => (a[a.AggregateError = 1] = "AggregateError", a[a.ArrowFunction = 2] = "ArrowFunction", a[a.ErrorPrototypeStack = 4] = "ErrorPrototypeStack", a[a.ObjectAssign = 8] = "ObjectAssign", a[a.BigIntTypedArray = 16] = "BigIntTypedArray", a))(R || {});
function Nr(o$1) {
	switch (o$1) {
		case "\\"": return "\\\\\\"";
		case "\\\\": return "\\\\\\\\";
		case \`
\`: return "\\\\n";
		case "\\r": return "\\\\r";
		case "\\b": return "\\\\b";
		case "	": return "\\\\t";
		case "\\f": return "\\\\f";
		case "<": return "\\\\x3C";
		case "\\u2028": return "\\\\u2028";
		case "\\u2029": return "\\\\u2029";
		default: return;
	}
}
function d(o$1) {
	let e = "", r = 0, t;
	for (let n = 0, a = o$1.length; n < a; n++) t = Nr(o$1[n]), t && (e += o$1.slice(r, n) + t, r = n + 1);
	return r === 0 ? e = o$1 : e += o$1.slice(r), e;
}
var O$1 = "__SEROVAL_REFS__", Q = "$R", ae = \`self.\${Q}\`;
function xr(o$1) {
	return o$1 == null ? \`\${ae}=\${ae}||[]\` : \`(\${ae}=\${ae}||{})["\${d(o$1)}"]=[]\`;
}
function f$1(o$1, e) {
	if (!o$1) throw e;
}
var Be = /* @__PURE__ */ new Map(), C$1 = /* @__PURE__ */ new Map();
function je(o$1) {
	return Be.has(o$1);
}
function Ke(o$1) {
	return f$1(je(o$1), new ie$1(o$1)), Be.get(o$1);
}
typeof globalThis != "undefined" ? Object.defineProperty(globalThis, O$1, {
	value: C$1,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof window != "undefined" ? Object.defineProperty(window, O$1, {
	value: C$1,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof self != "undefined" ? Object.defineProperty(self, O$1, {
	value: C$1,
	configurable: !0,
	writable: !1,
	enumerable: !1
}) : typeof global != "undefined" && Object.defineProperty(global, O$1, {
	value: C$1,
	configurable: !0,
	writable: !1,
	enumerable: !1
});
function Hr(o$1) {
	return o$1;
}
function Ye(o$1, e) {
	for (let r = 0, t = e.length; r < t; r++) {
		let n = e[r];
		o$1.has(n) || (o$1.add(n), n.extends && Ye(o$1, n.extends));
	}
}
function m$1(o$1) {
	if (o$1) {
		let e = /* @__PURE__ */ new Set();
		return Ye(e, o$1), [...e];
	}
}
var $e = {
	0: "Symbol.asyncIterator",
	1: "Symbol.hasInstance",
	2: "Symbol.isConcatSpreadable",
	3: "Symbol.iterator",
	4: "Symbol.match",
	5: "Symbol.matchAll",
	6: "Symbol.replace",
	7: "Symbol.search",
	8: "Symbol.species",
	9: "Symbol.split",
	10: "Symbol.toPrimitive",
	11: "Symbol.toStringTag",
	12: "Symbol.unscopables"
}, ce = {
	[Symbol.asyncIterator]: 0,
	[Symbol.hasInstance]: 1,
	[Symbol.isConcatSpreadable]: 2,
	[Symbol.iterator]: 3,
	[Symbol.match]: 4,
	[Symbol.matchAll]: 5,
	[Symbol.replace]: 6,
	[Symbol.search]: 7,
	[Symbol.species]: 8,
	[Symbol.split]: 9,
	[Symbol.toPrimitive]: 10,
	[Symbol.toStringTag]: 11,
	[Symbol.unscopables]: 12
}, Ge = {
	0: Symbol.asyncIterator,
	1: Symbol.hasInstance,
	2: Symbol.isConcatSpreadable,
	3: Symbol.iterator,
	4: Symbol.match,
	5: Symbol.matchAll,
	6: Symbol.replace,
	7: Symbol.search,
	8: Symbol.species,
	9: Symbol.split,
	10: Symbol.toPrimitive,
	11: Symbol.toStringTag,
	12: Symbol.unscopables
}, qe = {
	2: "!0",
	3: "!1",
	1: "void 0",
	0: "null",
	4: "-0",
	5: "1/0",
	6: "-1/0",
	7: "0/0"
}, He = {
	2: !0,
	3: !1,
	1: void 0,
	0: null,
	4: -0,
	5: Number.POSITIVE_INFINITY,
	6: Number.NEGATIVE_INFINITY,
	7: NaN
};
var ue$1 = {
	0: "Error",
	1: "EvalError",
	2: "RangeError",
	3: "ReferenceError",
	4: "SyntaxError",
	5: "TypeError",
	6: "URIError"
}, Ze = {
	0: Error,
	1: EvalError,
	2: RangeError,
	3: ReferenceError,
	4: SyntaxError,
	5: TypeError,
	6: URIError
}, s$1 = void 0;
function u$1(o$1, e, r, t, n, a, i$1, l$1, c$1, p$1, h$1, X) {
	return {
		t: o$1,
		i: e,
		s: r,
		l: t,
		c: n,
		m: a,
		p: i$1,
		e: l$1,
		a: c$1,
		f: p$1,
		b: h$1,
		o: X
	};
}
function x$1(o$1) {
	return u$1(2, s$1, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
var I = x$1(2), A$1 = x$1(3), pe = x$1(1), de = x$1(0), Xe = x$1(4), Qe = x$1(5), er = x$1(6), rr = x$1(7);
function me$1(o$1) {
	return o$1 instanceof EvalError ? 1 : o$1 instanceof RangeError ? 2 : o$1 instanceof ReferenceError ? 3 : o$1 instanceof SyntaxError ? 4 : o$1 instanceof TypeError ? 5 : o$1 instanceof URIError ? 6 : 0;
}
function wr(o$1) {
	let e = ue$1[me$1(o$1)];
	return o$1.name !== e ? { name: o$1.name } : o$1.constructor.name !== e ? { name: o$1.constructor.name } : {};
}
function j(o$1, e) {
	let r = wr(o$1), t = Object.getOwnPropertyNames(o$1);
	for (let n = 0, a = t.length, i$1; n < a; n++) i$1 = t[n], i$1 !== "name" && i$1 !== "message" && (i$1 === "stack" ? e & 4 && (r = r || {}, r[i$1] = o$1[i$1]) : (r = r || {}, r[i$1] = o$1[i$1]));
	return r;
}
function fe(o$1) {
	return Object.isFrozen(o$1) ? 3 : Object.isSealed(o$1) ? 2 : Object.isExtensible(o$1) ? 0 : 1;
}
function ge(o$1) {
	switch (o$1) {
		case Number.POSITIVE_INFINITY: return Qe;
		case Number.NEGATIVE_INFINITY: return er;
	}
	return o$1 !== o$1 ? rr : Object.is(o$1, -0) ? Xe : u$1(0, s$1, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function w$1(o$1) {
	return u$1(1, s$1, d(o$1), s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function Se(o$1) {
	return u$1(3, s$1, "" + o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function sr(o$1) {
	return u$1(4, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function he(o$1, e) {
	let r = e.valueOf();
	return u$1(5, o$1, r !== r ? "" : e.toISOString(), s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function ye(o$1, e) {
	return u$1(6, o$1, s$1, s$1, d(e.source), e.flags, s$1, s$1, s$1, s$1, s$1, s$1);
}
function ve(o$1, e) {
	let r = new Uint8Array(e), t = r.length, n = new Array(t);
	for (let a = 0; a < t; a++) n[a] = r[a];
	return u$1(19, o$1, n, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function or(o$1, e) {
	return u$1(17, o$1, ce[e], s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function nr(o$1, e) {
	return u$1(18, o$1, d(Ke(e)), s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function _$1(o$1, e, r) {
	return u$1(25, o$1, r, s$1, d(e), s$1, s$1, s$1, s$1, s$1, s$1, s$1);
}
function Ne(o$1, e, r) {
	return u$1(9, o$1, s$1, e.length, s$1, s$1, s$1, s$1, r, s$1, s$1, fe(e));
}
function be(o$1, e) {
	return u$1(21, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, e, s$1, s$1);
}
function xe(o$1, e, r) {
	return u$1(15, o$1, s$1, e.length, e.constructor.name, s$1, s$1, s$1, s$1, r, e.byteOffset, s$1);
}
function Ie(o$1, e, r) {
	return u$1(16, o$1, s$1, e.length, e.constructor.name, s$1, s$1, s$1, s$1, r, e.byteOffset, s$1);
}
function Ae(o$1, e, r) {
	return u$1(20, o$1, s$1, e.byteLength, s$1, s$1, s$1, s$1, s$1, r, e.byteOffset, s$1);
}
function we(o$1, e, r) {
	return u$1(13, o$1, me$1(e), s$1, s$1, d(e.message), r, s$1, s$1, s$1, s$1, s$1);
}
function Ee(o$1, e, r) {
	return u$1(14, o$1, me$1(e), s$1, s$1, d(e.message), r, s$1, s$1, s$1, s$1, s$1);
}
function Pe(o$1, e, r) {
	return u$1(7, o$1, s$1, e, s$1, s$1, s$1, s$1, r, s$1, s$1, s$1);
}
function M(o$1, e) {
	return u$1(28, s$1, s$1, s$1, s$1, s$1, s$1, s$1, [o$1, e], s$1, s$1, s$1);
}
function U(o$1, e) {
	return u$1(30, s$1, s$1, s$1, s$1, s$1, s$1, s$1, [o$1, e], s$1, s$1, s$1);
}
function L(o$1, e, r) {
	return u$1(31, o$1, s$1, s$1, s$1, s$1, s$1, s$1, r, e, s$1, s$1);
}
function Re(o$1, e) {
	return u$1(32, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, e, s$1, s$1);
}
function Oe(o$1, e) {
	return u$1(33, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, e, s$1, s$1);
}
function Ce(o$1, e) {
	return u$1(34, o$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, e, s$1, s$1);
}
var { toString: _e } = Object.prototype;
function Er(o$1, e) {
	return e instanceof Error ? \`Seroval caught an error during the \${o$1} process.
  
\${e.name}
\${e.message}

- For more information, please check the "cause" property of this error.
- If you believe this is an error in Seroval, please submit an issue at https://github.com/lxsmnsyc/seroval/issues/new\` : \`Seroval caught an error during the \${o$1} process.

"\${_e.call(e)}"

For more information, please check the "cause" property of this error.\`;
}
var ee$1 = class extends Error {
	constructor(r, t) {
		super(Er(r, t));
		this.cause = t;
	}
}, E$1 = class extends ee$1 {
	constructor(e) {
		super("parsing", e);
	}
}, Te = class extends ee$1 {
	constructor(e) {
		super("serialization", e);
	}
}, ze = class extends ee$1 {
	constructor(e) {
		super("deserialization", e);
	}
}, g$1 = class extends Error {
	constructor(r) {
		super(\`The value \${_e.call(r)} of type "\${typeof r}" cannot be parsed/serialized.
      
There are few workarounds for this problem:
- Transform the value in a way that it can be serialized.
- If the reference is present on multiple runtimes (isomorphic), you can use the Reference API to map the references.\`);
		this.value = r;
	}
}, y$1 = class extends Error {
	constructor(e) {
		super("Unsupported node type \\"" + e.t + "\\".");
	}
}, W = class extends Error {
	constructor(e) {
		super("Missing plugin for tag \\"" + e + "\\".");
	}
}, P$1 = class extends Error {
	constructor(e) {
		super("Missing \\"" + e + "\\" instance.");
	}
}, ie$1 = class extends Error {
	constructor(r) {
		super("Missing reference for the value \\"" + _e.call(r) + "\\" of type \\"" + typeof r + "\\"");
		this.value = r;
	}
}, le = class extends Error {
	constructor(e) {
		super("Missing reference for id \\"" + d(e) + "\\"");
	}
}, ke = class extends Error {
	constructor(e) {
		super("Unknown TypedArray \\"" + e + "\\"");
	}
};
var T = class {
	constructor(e, r) {
		this.value = e;
		this.replacement = r;
	}
};
function z(o$1, e, r) {
	return o$1 & 2 ? (e.length === 1 ? e[0] : "(" + e.join(",") + ")") + "=>" + (r.startsWith("{") ? "(" + r + ")" : r) : "function(" + e.join(",") + "){return " + r + "}";
}
function S(o$1, e, r) {
	return o$1 & 2 ? (e.length === 1 ? e[0] : "(" + e.join(",") + ")") + "=>{" + r + "}" : "function(" + e.join(",") + "){" + r + "}";
}
var ar = {}, ir = {};
var lr = {
	0: {},
	1: {},
	2: {},
	3: {},
	4: {}
};
function Pr(o$1) {
	return z(o$1, ["r"], "(r.p=new Promise(" + S(o$1, ["s", "f"], "r.s=s,r.f=f") + "))");
}
function Rr(o$1) {
	return S(o$1, ["r", "d"], "r.s(d),r.p.s=1,r.p.v=d");
}
function Or(o$1) {
	return S(o$1, ["r", "d"], "r.f(d),r.p.s=2,r.p.v=d");
}
function Cr(o$1) {
	return z(o$1, [
		"b",
		"a",
		"s",
		"l",
		"p",
		"f",
		"e",
		"n"
	], "(b=[],a=!0,s=!1,l=[],p=0,f=" + S(o$1, [
		"v",
		"m",
		"x"
	], "for(x=0;x<p;x++)l[x]&&l[x][m](v)") + ",n=" + S(o$1, [
		"o",
		"x",
		"z",
		"c"
	], "for(x=0,z=b.length;x<z;x++)(c=b[x],(!a&&x===z-1)?o[s?\\"return\\":\\"throw\\"](c):o.next(c))") + ",e=" + z(o$1, ["o", "t"], "(a&&(l[t=p++]=o),n(o)," + S(o$1, [], "a&&(l[t]=void 0)") + ")") + ",{__SEROVAL_STREAM__:!0,on:" + z(o$1, ["o"], "e(o)") + ",next:" + S(o$1, ["v"], "a&&(b.push(v),f(v,\\"next\\"))") + ",throw:" + S(o$1, ["v"], "a&&(b.push(v),f(v,\\"throw\\"),a=s=!1,l.length=0)") + ",return:" + S(o$1, ["v"], "a&&(b.push(v),f(v,\\"return\\"),a=!1,s=!0,l.length=0)") + "})");
}
function cr(o$1, e) {
	switch (e) {
		case 0: return "[]";
		case 1: return Pr(o$1);
		case 2: return Rr(o$1);
		case 3: return Or(o$1);
		case 4: return Cr(o$1);
		default: return "";
	}
}
function Fe(o$1) {
	return "__SEROVAL_STREAM__" in o$1;
}
function K$1() {
	let o$1 = /* @__PURE__ */ new Set(), e = [], r = !0, t = !0;
	function n(l$1) {
		for (let c$1 of o$1.keys()) c$1.next(l$1);
	}
	function a(l$1) {
		for (let c$1 of o$1.keys()) c$1.throw(l$1);
	}
	function i$1(l$1) {
		for (let c$1 of o$1.keys()) c$1.return(l$1);
	}
	return {
		__SEROVAL_STREAM__: !0,
		on(l$1) {
			r && o$1.add(l$1);
			for (let c$1 = 0, p$1 = e.length; c$1 < p$1; c$1++) {
				let h$1 = e[c$1];
				c$1 === p$1 - 1 && !r ? t ? l$1.return(h$1) : l$1.throw(h$1) : l$1.next(h$1);
			}
			return () => {
				r && o$1.delete(l$1);
			};
		},
		next(l$1) {
			r && (e.push(l$1), n(l$1));
		},
		throw(l$1) {
			r && (e.push(l$1), a(l$1), r = !1, t = !1, o$1.clear());
		},
		return(l$1) {
			r && (e.push(l$1), i$1(l$1), r = !1, t = !0, o$1.clear());
		}
	};
}
function Ve(o$1) {
	let e = K$1(), r = o$1[Symbol.asyncIterator]();
	async function t() {
		try {
			let n = await r.next();
			n.done ? e.return(n.value) : (e.next(n.value), await t());
		} catch (n) {
			e.throw(n);
		}
	}
	return t().catch(() => {}), e;
}
function J(o$1) {
	let e = [], r = -1, t = -1, n = o$1[Symbol.iterator]();
	for (;;) try {
		let a = n.next();
		if (e.push(a.value), a.done) {
			t = e.length - 1;
			break;
		}
	} catch (a) {
		r = e.length, e.push(a);
	}
	return {
		v: e,
		t: r,
		d: t
	};
}
var Y$1 = class {
	constructor(e) {
		this.marked = /* @__PURE__ */ new Set();
		this.plugins = e.plugins, this.features = 31 ^ (e.disabledFeatures || 0), this.refs = e.refs || /* @__PURE__ */ new Map();
	}
	markRef(e) {
		this.marked.add(e);
	}
	isMarked(e) {
		return this.marked.has(e);
	}
	createIndex(e) {
		let r = this.refs.size;
		return this.refs.set(e, r), r;
	}
	getIndexedValue(e) {
		let r = this.refs.get(e);
		return r != null ? (this.markRef(r), {
			type: 1,
			value: sr(r)
		}) : {
			type: 0,
			value: this.createIndex(e)
		};
	}
	getReference(e) {
		let r = this.getIndexedValue(e);
		return r.type === 1 ? r : je(e) ? {
			type: 2,
			value: nr(r.value, e)
		} : r;
	}
	parseWellKnownSymbol(e) {
		let r = this.getReference(e);
		return r.type !== 0 ? r.value : (f$1(e in ce, new g$1(e)), or(r.value, e));
	}
	parseSpecialReference(e) {
		let r = this.getIndexedValue(lr[e]);
		return r.type === 1 ? r.value : u$1(26, r.value, e, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1, s$1);
	}
	parseIteratorFactory() {
		let e = this.getIndexedValue(ar);
		return e.type === 1 ? e.value : u$1(27, e.value, s$1, s$1, s$1, s$1, s$1, s$1, s$1, this.parseWellKnownSymbol(Symbol.iterator), s$1, s$1);
	}
	parseAsyncIteratorFactory() {
		let e = this.getIndexedValue(ir);
		return e.type === 1 ? e.value : u$1(29, e.value, s$1, s$1, s$1, s$1, s$1, s$1, [this.parseSpecialReference(1), this.parseWellKnownSymbol(Symbol.asyncIterator)], s$1, s$1, s$1);
	}
	createObjectNode(e, r, t, n) {
		return u$1(t ? 11 : 10, e, s$1, s$1, s$1, s$1, n, s$1, s$1, s$1, s$1, fe(r));
	}
	createMapNode(e, r, t, n) {
		return u$1(8, e, s$1, s$1, s$1, s$1, s$1, {
			k: r,
			v: t,
			s: n
		}, s$1, this.parseSpecialReference(0), s$1, s$1);
	}
	createPromiseConstructorNode(e, r) {
		return u$1(22, e, r, s$1, s$1, s$1, s$1, s$1, s$1, this.parseSpecialReference(1), s$1, s$1);
	}
};
var kr = /^[$A-Z_][0-9A-Z_$]*$/i;
function Le(o$1) {
	let e = o$1[0];
	return (e === "$" || e === "_" || e >= "A" && e <= "Z" || e >= "a" && e <= "z") && kr.test(o$1);
}
function se(o$1) {
	switch (o$1.t) {
		case 0: return o$1.s + "=" + o$1.v;
		case 2: return o$1.s + ".set(" + o$1.k + "," + o$1.v + ")";
		case 1: return o$1.s + ".add(" + o$1.v + ")";
		case 3: return o$1.s + ".delete(" + o$1.k + ")";
	}
}
function Fr(o$1) {
	let e = [], r = o$1[0];
	for (let t = 1, n = o$1.length, a, i$1 = r; t < n; t++) a = o$1[t], a.t === 0 && a.v === i$1.v ? r = {
		t: 0,
		s: a.s,
		k: s$1,
		v: se(r)
	} : a.t === 2 && a.s === i$1.s ? r = {
		t: 2,
		s: se(r),
		k: a.k,
		v: a.v
	} : a.t === 1 && a.s === i$1.s ? r = {
		t: 1,
		s: se(r),
		k: s$1,
		v: a.v
	} : a.t === 3 && a.s === i$1.s ? r = {
		t: 3,
		s: se(r),
		k: a.k,
		v: s$1
	} : (e.push(r), r = a), i$1 = a;
	return e.push(r), e;
}
function fr(o$1) {
	if (o$1.length) {
		let e = "", r = Fr(o$1);
		for (let t = 0, n = r.length; t < n; t++) e += se(r[t]) + ",";
		return e;
	}
	return s$1;
}
var Vr = "Object.create(null)", Dr = "new Set", Br = "new Map", jr = "Promise.resolve", _r = "Promise.reject", Mr = {
	3: "Object.freeze",
	2: "Object.seal",
	1: "Object.preventExtensions",
	0: s$1
}, V = class {
	constructor(e) {
		this.stack = [];
		this.flags = [];
		this.assignments = [];
		this.plugins = e.plugins, this.features = e.features, this.marked = new Set(e.markedRefs);
	}
	createFunction(e, r) {
		return z(this.features, e, r);
	}
	createEffectfulFunction(e, r) {
		return S(this.features, e, r);
	}
	markRef(e) {
		this.marked.add(e);
	}
	isMarked(e) {
		return this.marked.has(e);
	}
	pushObjectFlag(e, r) {
		e !== 0 && (this.markRef(r), this.flags.push({
			type: e,
			value: this.getRefParam(r)
		}));
	}
	resolveFlags() {
		let e = "";
		for (let r = 0, t = this.flags, n = t.length; r < n; r++) {
			let a = t[r];
			e += Mr[a.type] + "(" + a.value + "),";
		}
		return e;
	}
	resolvePatches() {
		let e = fr(this.assignments), r = this.resolveFlags();
		return e ? r ? e + r : e : r;
	}
	createAssignment(e, r) {
		this.assignments.push({
			t: 0,
			s: e,
			k: s$1,
			v: r
		});
	}
	createAddAssignment(e, r) {
		this.assignments.push({
			t: 1,
			s: this.getRefParam(e),
			k: s$1,
			v: r
		});
	}
	createSetAssignment(e, r, t) {
		this.assignments.push({
			t: 2,
			s: this.getRefParam(e),
			k: r,
			v: t
		});
	}
	createDeleteAssignment(e, r) {
		this.assignments.push({
			t: 3,
			s: this.getRefParam(e),
			k: r,
			v: s$1
		});
	}
	createArrayAssign(e, r, t) {
		this.createAssignment(this.getRefParam(e) + "[" + r + "]", t);
	}
	createObjectAssign(e, r, t) {
		this.createAssignment(this.getRefParam(e) + "." + r, t);
	}
	isIndexedValueInStack(e) {
		return e.t === 4 && this.stack.includes(e.i);
	}
	serializeReference(e) {
		return this.assignIndexedValue(e.i, O$1 + ".get(\\"" + e.s + "\\")");
	}
	serializeArrayItem(e, r, t) {
		return r ? this.isIndexedValueInStack(r) ? (this.markRef(e), this.createArrayAssign(e, t, this.getRefParam(r.i)), "") : this.serialize(r) : "";
	}
	serializeArray(e) {
		let r = e.i;
		if (e.l) {
			this.stack.push(r);
			let t = e.a, n = this.serializeArrayItem(r, t[0], 0), a = n === "";
			for (let i$1 = 1, l$1 = e.l, c$1; i$1 < l$1; i$1++) c$1 = this.serializeArrayItem(r, t[i$1], i$1), n += "," + c$1, a = c$1 === "";
			return this.stack.pop(), this.pushObjectFlag(e.o, e.i), this.assignIndexedValue(r, "[" + n + (a ? ",]" : "]"));
		}
		return this.assignIndexedValue(r, "[]");
	}
	serializeProperty(e, r, t) {
		if (typeof r == "string") {
			let n = Number(r), a = n >= 0 && n.toString() === r || Le(r);
			if (this.isIndexedValueInStack(t)) {
				let i$1 = this.getRefParam(t.i);
				return this.markRef(e.i), a && n !== n ? this.createObjectAssign(e.i, r, i$1) : this.createArrayAssign(e.i, a ? r : "\\"" + r + "\\"", i$1), "";
			}
			return (a ? r : "\\"" + r + "\\"") + ":" + this.serialize(t);
		}
		return "[" + this.serialize(r) + "]:" + this.serialize(t);
	}
	serializeProperties(e, r) {
		let t = r.s;
		if (t) {
			let n = r.k, a = r.v;
			this.stack.push(e.i);
			let i$1 = this.serializeProperty(e, n[0], a[0]);
			for (let l$1 = 1, c$1 = i$1; l$1 < t; l$1++) c$1 = this.serializeProperty(e, n[l$1], a[l$1]), i$1 += (c$1 && i$1 && ",") + c$1;
			return this.stack.pop(), "{" + i$1 + "}";
		}
		return "{}";
	}
	serializeObject(e) {
		return this.pushObjectFlag(e.o, e.i), this.assignIndexedValue(e.i, this.serializeProperties(e, e.p));
	}
	serializeWithObjectAssign(e, r, t) {
		let n = this.serializeProperties(e, r);
		return n !== "{}" ? "Object.assign(" + t + "," + n + ")" : t;
	}
	serializeStringKeyAssignment(e, r, t, n) {
		let a = this.serialize(n), i$1 = Number(t), l$1 = i$1 >= 0 && i$1.toString() === t || Le(t);
		if (this.isIndexedValueInStack(n)) l$1 && i$1 !== i$1 ? this.createObjectAssign(e.i, t, a) : this.createArrayAssign(e.i, l$1 ? t : "\\"" + t + "\\"", a);
		else {
			let c$1 = this.assignments;
			this.assignments = r, l$1 && i$1 !== i$1 ? this.createObjectAssign(e.i, t, a) : this.createArrayAssign(e.i, l$1 ? t : "\\"" + t + "\\"", a), this.assignments = c$1;
		}
	}
	serializeAssignment(e, r, t, n) {
		if (typeof t == "string") this.serializeStringKeyAssignment(e, r, t, n);
		else {
			let a = this.stack;
			this.stack = [];
			let i$1 = this.serialize(n);
			this.stack = a;
			let l$1 = this.assignments;
			this.assignments = r, this.createArrayAssign(e.i, this.serialize(t), i$1), this.assignments = l$1;
		}
	}
	serializeAssignments(e, r) {
		let t = r.s;
		if (t) {
			let n = [], a = r.k, i$1 = r.v;
			this.stack.push(e.i);
			for (let l$1 = 0; l$1 < t; l$1++) this.serializeAssignment(e, n, a[l$1], i$1[l$1]);
			return this.stack.pop(), fr(n);
		}
		return s$1;
	}
	serializeDictionary(e, r) {
		if (e.p) if (this.features & 8) r = this.serializeWithObjectAssign(e, e.p, r);
		else {
			this.markRef(e.i);
			let t = this.serializeAssignments(e, e.p);
			if (t) return "(" + this.assignIndexedValue(e.i, r) + "," + t + this.getRefParam(e.i) + ")";
		}
		return this.assignIndexedValue(e.i, r);
	}
	serializeNullConstructor(e) {
		return this.pushObjectFlag(e.o, e.i), this.serializeDictionary(e, Vr);
	}
	serializeDate(e) {
		return this.assignIndexedValue(e.i, "new Date(\\"" + e.s + "\\")");
	}
	serializeRegExp(e) {
		return this.assignIndexedValue(e.i, "/" + e.c + "/" + e.m);
	}
	serializeSetItem(e, r) {
		return this.isIndexedValueInStack(r) ? (this.markRef(e), this.createAddAssignment(e, this.getRefParam(r.i)), "") : this.serialize(r);
	}
	serializeSet(e) {
		let r = Dr, t = e.l, n = e.i;
		if (t) {
			let a = e.a;
			this.stack.push(n);
			let i$1 = this.serializeSetItem(n, a[0]);
			for (let l$1 = 1, c$1 = i$1; l$1 < t; l$1++) c$1 = this.serializeSetItem(n, a[l$1]), i$1 += (c$1 && i$1 && ",") + c$1;
			this.stack.pop(), i$1 && (r += "([" + i$1 + "])");
		}
		return this.assignIndexedValue(n, r);
	}
	serializeMapEntry(e, r, t, n) {
		if (this.isIndexedValueInStack(r)) {
			let a = this.getRefParam(r.i);
			if (this.markRef(e), this.isIndexedValueInStack(t)) {
				let l$1 = this.getRefParam(t.i);
				return this.createSetAssignment(e, a, l$1), "";
			}
			if (t.t !== 4 && t.i != null && this.isMarked(t.i)) {
				let l$1 = "(" + this.serialize(t) + ",[" + n + "," + n + "])";
				return this.createSetAssignment(e, a, this.getRefParam(t.i)), this.createDeleteAssignment(e, n), l$1;
			}
			let i$1 = this.stack;
			return this.stack = [], this.createSetAssignment(e, a, this.serialize(t)), this.stack = i$1, "";
		}
		if (this.isIndexedValueInStack(t)) {
			let a = this.getRefParam(t.i);
			if (this.markRef(e), r.t !== 4 && r.i != null && this.isMarked(r.i)) {
				let l$1 = "(" + this.serialize(r) + ",[" + n + "," + n + "])";
				return this.createSetAssignment(e, this.getRefParam(r.i), a), this.createDeleteAssignment(e, n), l$1;
			}
			let i$1 = this.stack;
			return this.stack = [], this.createSetAssignment(e, this.serialize(r), a), this.stack = i$1, "";
		}
		return "[" + this.serialize(r) + "," + this.serialize(t) + "]";
	}
	serializeMap(e) {
		let r = Br, t = e.e.s, n = e.i, a = e.f, i$1 = this.getRefParam(a.i);
		if (t) {
			let l$1 = e.e.k, c$1 = e.e.v;
			this.stack.push(n);
			let p$1 = this.serializeMapEntry(n, l$1[0], c$1[0], i$1);
			for (let h$1 = 1, X = p$1; h$1 < t; h$1++) X = this.serializeMapEntry(n, l$1[h$1], c$1[h$1], i$1), p$1 += (X && p$1 && ",") + X;
			this.stack.pop(), p$1 && (r += "([" + p$1 + "])");
		}
		return a.t === 26 && (this.markRef(a.i), r = "(" + this.serialize(a) + "," + r + ")"), this.assignIndexedValue(n, r);
	}
	serializeArrayBuffer(e) {
		let r = "new Uint8Array(", t = e.s, n = t.length;
		if (n) {
			r += "[" + t[0];
			for (let a = 1; a < n; a++) r += "," + t[a];
			r += "]";
		}
		return this.assignIndexedValue(e.i, r + ").buffer");
	}
	serializeTypedArray(e) {
		return this.assignIndexedValue(e.i, "new " + e.c + "(" + this.serialize(e.f) + "," + e.b + "," + e.l + ")");
	}
	serializeDataView(e) {
		return this.assignIndexedValue(e.i, "new DataView(" + this.serialize(e.f) + "," + e.b + "," + e.l + ")");
	}
	serializeAggregateError(e) {
		let r = e.i;
		this.stack.push(r);
		let t = this.serializeDictionary(e, "new AggregateError([],\\"" + e.m + "\\")");
		return this.stack.pop(), t;
	}
	serializeError(e) {
		return this.serializeDictionary(e, "new " + ue$1[e.s] + "(\\"" + e.m + "\\")");
	}
	serializePromise(e) {
		let r, t = e.f, n = e.i, a = e.s ? jr : _r;
		if (this.isIndexedValueInStack(t)) {
			let i$1 = this.getRefParam(t.i);
			r = a + (e.s ? "().then(" + this.createFunction([], i$1) + ")" : "().catch(" + this.createEffectfulFunction([], "throw " + i$1) + ")");
		} else {
			this.stack.push(n);
			let i$1 = this.serialize(t);
			this.stack.pop(), r = a + "(" + i$1 + ")";
		}
		return this.assignIndexedValue(n, r);
	}
	serializeWellKnownSymbol(e) {
		return this.assignIndexedValue(e.i, $e[e.s]);
	}
	serializeBoxed(e) {
		return this.assignIndexedValue(e.i, "Object(" + this.serialize(e.f) + ")");
	}
	serializePlugin(e) {
		let r = this.plugins;
		if (r) for (let t = 0, n = r.length; t < n; t++) {
			let a = r[t];
			if (a.tag === e.c) return this.assignIndexedValue(e.i, a.serialize(e.s, this, { id: e.i }));
		}
		throw new W(e.c);
	}
	getConstructor(e) {
		let r = this.serialize(e);
		return r === this.getRefParam(e.i) ? r : "(" + r + ")";
	}
	serializePromiseConstructor(e) {
		let r = this.assignIndexedValue(e.s, "{p:0,s:0,f:0}");
		return this.assignIndexedValue(e.i, this.getConstructor(e.f) + "(" + r + ")");
	}
	serializePromiseResolve(e) {
		return this.getConstructor(e.a[0]) + "(" + this.getRefParam(e.i) + "," + this.serialize(e.a[1]) + ")";
	}
	serializePromiseReject(e) {
		return this.getConstructor(e.a[0]) + "(" + this.getRefParam(e.i) + "," + this.serialize(e.a[1]) + ")";
	}
	serializeSpecialReference(e) {
		return this.assignIndexedValue(e.i, cr(this.features, e.s));
	}
	serializeIteratorFactory(e) {
		let r = "", t = !1;
		return e.f.t !== 4 && (this.markRef(e.f.i), r = "(" + this.serialize(e.f) + ",", t = !0), r += this.assignIndexedValue(e.i, this.createFunction(["s"], this.createFunction([
			"i",
			"c",
			"d",
			"t"
		], "(i=0,t={[" + this.getRefParam(e.f.i) + "]:" + this.createFunction([], "t") + ",next:" + this.createEffectfulFunction([], "if(i>s.d)return{done:!0,value:void 0};if(d=s.v[c=i++],c===s.t)throw d;return{done:c===s.d,value:d}") + "})"))), t && (r += ")"), r;
	}
	serializeIteratorFactoryInstance(e) {
		return this.getConstructor(e.a[0]) + "(" + this.serialize(e.a[1]) + ")";
	}
	serializeAsyncIteratorFactory(e) {
		let r = e.a[0], t = e.a[1], n = "";
		r.t !== 4 && (this.markRef(r.i), n += "(" + this.serialize(r)), t.t !== 4 && (this.markRef(t.i), n += (n ? "," : "(") + this.serialize(t)), n && (n += ",");
		let a = this.assignIndexedValue(e.i, this.createFunction(["s"], this.createFunction([
			"b",
			"c",
			"p",
			"d",
			"e",
			"t",
			"f"
		], "(b=[],c=0,p=[],d=-1,e=!1,f=" + this.createEffectfulFunction(["i", "l"], "for(i=0,l=p.length;i<l;i++)p[i].s({done:!0,value:void 0})") + ",s.on({next:" + this.createEffectfulFunction(["v", "t"], "if(t=p.shift())t.s({done:!1,value:v});b.push(v)") + ",throw:" + this.createEffectfulFunction(["v", "t"], "if(t=p.shift())t.f(v);f(),d=b.length,e=!0,b.push(v)") + ",return:" + this.createEffectfulFunction(["v", "t"], "if(t=p.shift())t.s({done:!0,value:v});f(),d=b.length,b.push(v)") + "}),t={[" + this.getRefParam(t.i) + "]:" + this.createFunction([], "t.p") + ",next:" + this.createEffectfulFunction([
			"i",
			"t",
			"v"
		], "if(d===-1){return((i=c++)>=b.length)?(" + this.getRefParam(r.i) + "(t={p:0,s:0,f:0}),p.push(t),t.p):{done:!1,value:b[i]}}if(c>d)return{done:!0,value:void 0};if(v=b[i=c++],i!==d)return{done:!1,value:v};if(e)throw v;return{done:!0,value:v}") + "})")));
		return n ? n + a + ")" : a;
	}
	serializeAsyncIteratorFactoryInstance(e) {
		return this.getConstructor(e.a[0]) + "(" + this.serialize(e.a[1]) + ")";
	}
	serializeStreamConstructor(e) {
		let r = this.assignIndexedValue(e.i, this.getConstructor(e.f) + "()"), t = e.a.length;
		if (t) {
			let n = this.serialize(e.a[0]);
			for (let a = 1; a < t; a++) n += "," + this.serialize(e.a[a]);
			return "(" + r + "," + n + "," + this.getRefParam(e.i) + ")";
		}
		return r;
	}
	serializeStreamNext(e) {
		return this.getRefParam(e.i) + ".next(" + this.serialize(e.f) + ")";
	}
	serializeStreamThrow(e) {
		return this.getRefParam(e.i) + ".throw(" + this.serialize(e.f) + ")";
	}
	serializeStreamReturn(e) {
		return this.getRefParam(e.i) + ".return(" + this.serialize(e.f) + ")";
	}
	serialize(e) {
		try {
			switch (e.t) {
				case 2: return qe[e.s];
				case 0: return "" + e.s;
				case 1: return "\\"" + e.s + "\\"";
				case 3: return e.s + "n";
				case 4: return this.getRefParam(e.i);
				case 18: return this.serializeReference(e);
				case 9: return this.serializeArray(e);
				case 10: return this.serializeObject(e);
				case 11: return this.serializeNullConstructor(e);
				case 5: return this.serializeDate(e);
				case 6: return this.serializeRegExp(e);
				case 7: return this.serializeSet(e);
				case 8: return this.serializeMap(e);
				case 19: return this.serializeArrayBuffer(e);
				case 16:
				case 15: return this.serializeTypedArray(e);
				case 20: return this.serializeDataView(e);
				case 14: return this.serializeAggregateError(e);
				case 13: return this.serializeError(e);
				case 12: return this.serializePromise(e);
				case 17: return this.serializeWellKnownSymbol(e);
				case 21: return this.serializeBoxed(e);
				case 22: return this.serializePromiseConstructor(e);
				case 23: return this.serializePromiseResolve(e);
				case 24: return this.serializePromiseReject(e);
				case 25: return this.serializePlugin(e);
				case 26: return this.serializeSpecialReference(e);
				case 27: return this.serializeIteratorFactory(e);
				case 28: return this.serializeIteratorFactoryInstance(e);
				case 29: return this.serializeAsyncIteratorFactory(e);
				case 30: return this.serializeAsyncIteratorFactoryInstance(e);
				case 31: return this.serializeStreamConstructor(e);
				case 32: return this.serializeStreamNext(e);
				case 33: return this.serializeStreamThrow(e);
				case 34: return this.serializeStreamReturn(e);
				default: throw new y$1(e);
			}
		} catch (r) {
			throw new Te(r);
		}
	}
};
var D = class extends V {
	constructor(r) {
		super(r);
		this.mode = "cross";
		this.scopeId = r.scopeId;
	}
	getRefParam(r) {
		return Q + "[" + r + "]";
	}
	assignIndexedValue(r, t) {
		return this.getRefParam(r) + "=" + t;
	}
	serializeTop(r) {
		let t = this.serialize(r), n = r.i;
		if (n == null) return t;
		let a = this.resolvePatches(), i$1 = this.getRefParam(n), l$1 = this.scopeId == null ? "" : Q, c$1 = a ? "(" + t + "," + a + i$1 + ")" : t;
		if (l$1 === "") return r.t === 10 && !a ? "(" + c$1 + ")" : c$1;
		let p$1 = this.scopeId == null ? "()" : "(" + Q + "[\\"" + d(this.scopeId) + "\\"])";
		return "(" + this.createFunction([l$1], c$1) + ")" + p$1;
	}
};
var v = class extends Y$1 {
	parseItems(e) {
		let r = [];
		for (let t = 0, n = e.length; t < n; t++) t in e && (r[t] = this.parse(e[t]));
		return r;
	}
	parseArray(e, r) {
		return Ne(e, r, this.parseItems(r));
	}
	parseProperties(e) {
		let r = Object.entries(e), t = [], n = [];
		for (let i$1 = 0, l$1 = r.length; i$1 < l$1; i$1++) t.push(d(r[i$1][0])), n.push(this.parse(r[i$1][1]));
		let a = Symbol.iterator;
		return a in e && (t.push(this.parseWellKnownSymbol(a)), n.push(M(this.parseIteratorFactory(), this.parse(J(e))))), a = Symbol.asyncIterator, a in e && (t.push(this.parseWellKnownSymbol(a)), n.push(U(this.parseAsyncIteratorFactory(), this.parse(K$1())))), a = Symbol.toStringTag, a in e && (t.push(this.parseWellKnownSymbol(a)), n.push(w$1(e[a]))), a = Symbol.isConcatSpreadable, a in e && (t.push(this.parseWellKnownSymbol(a)), n.push(e[a] ? I : A$1)), {
			k: t,
			v: n,
			s: t.length
		};
	}
	parsePlainObject(e, r, t) {
		return this.createObjectNode(e, r, t, this.parseProperties(r));
	}
	parseBoxed(e, r) {
		return be(e, this.parse(r.valueOf()));
	}
	parseTypedArray(e, r) {
		return xe(e, r, this.parse(r.buffer));
	}
	parseBigIntTypedArray(e, r) {
		return Ie(e, r, this.parse(r.buffer));
	}
	parseDataView(e, r) {
		return Ae(e, r, this.parse(r.buffer));
	}
	parseError(e, r) {
		let t = j(r, this.features);
		return we(e, r, t ? this.parseProperties(t) : s$1);
	}
	parseAggregateError(e, r) {
		let t = j(r, this.features);
		return Ee(e, r, t ? this.parseProperties(t) : s$1);
	}
	parseMap(e, r) {
		let t = [], n = [];
		for (let [a, i$1] of r.entries()) t.push(this.parse(a)), n.push(this.parse(i$1));
		return this.createMapNode(e, t, n, r.size);
	}
	parseSet(e, r) {
		let t = [];
		for (let n of r.keys()) t.push(this.parse(n));
		return Pe(e, r.size, t);
	}
	parsePlugin(e, r) {
		let t = this.plugins;
		if (t) for (let n = 0, a = t.length; n < a; n++) {
			let i$1 = t[n];
			if (i$1.parse.sync && i$1.test(r)) return _$1(e, i$1.tag, i$1.parse.sync(r, this, { id: e }));
		}
	}
	parseStream(e, r) {
		return L(e, this.parseSpecialReference(4), []);
	}
	parsePromise(e, r) {
		return this.createPromiseConstructorNode(e, this.createIndex({}));
	}
	parseObject(e, r) {
		if (Array.isArray(r)) return this.parseArray(e, r);
		if (Fe(r)) return this.parseStream(e, r);
		let t = r.constructor;
		if (t === T) return this.parse(r.replacement);
		let n = this.parsePlugin(e, r);
		if (n) return n;
		switch (t) {
			case Object: return this.parsePlainObject(e, r, !1);
			case void 0: return this.parsePlainObject(e, r, !0);
			case Date: return he(e, r);
			case RegExp: return ye(e, r);
			case Error:
			case EvalError:
			case RangeError:
			case ReferenceError:
			case SyntaxError:
			case TypeError:
			case URIError: return this.parseError(e, r);
			case Number:
			case Boolean:
			case String:
			case BigInt: return this.parseBoxed(e, r);
			case ArrayBuffer: return ve(e, r);
			case Int8Array:
			case Int16Array:
			case Int32Array:
			case Uint8Array:
			case Uint16Array:
			case Uint32Array:
			case Uint8ClampedArray:
			case Float32Array:
			case Float64Array: return this.parseTypedArray(e, r);
			case DataView: return this.parseDataView(e, r);
			case Map: return this.parseMap(e, r);
			case Set: return this.parseSet(e, r);
			default: break;
		}
		if (t === Promise || r instanceof Promise) return this.parsePromise(e, r);
		let a = this.features;
		if (a & 16) switch (t) {
			case BigInt64Array:
			case BigUint64Array: return this.parseBigIntTypedArray(e, r);
			default: break;
		}
		if (a & 1 && typeof AggregateError != "undefined" && (t === AggregateError || r instanceof AggregateError)) return this.parseAggregateError(e, r);
		if (r instanceof Error) return this.parseError(e, r);
		if (Symbol.iterator in r || Symbol.asyncIterator in r) return this.parsePlainObject(e, r, !!t);
		throw new g$1(r);
	}
	parseFunction(e) {
		let r = this.getReference(e);
		if (r.type !== 0) return r.value;
		let t = this.parsePlugin(r.value, e);
		if (t) return t;
		throw new g$1(e);
	}
	parse(e) {
		switch (typeof e) {
			case "boolean": return e ? I : A$1;
			case "undefined": return pe;
			case "string": return w$1(e);
			case "number": return ge(e);
			case "bigint": return Se(e);
			case "object":
				if (e) {
					let r = this.getReference(e);
					return r.type === 0 ? this.parseObject(r.value, e) : r.value;
				}
				return de;
			case "symbol": return this.parseWellKnownSymbol(e);
			case "function": return this.parseFunction(e);
			default: throw new g$1(e);
		}
	}
	parseTop(e) {
		try {
			return this.parse(e);
		} catch (r) {
			throw r instanceof E$1 ? r : new E$1(r);
		}
	}
};
var oe = class extends v {
	constructor(r) {
		super(r);
		this.alive = !0;
		this.pending = 0;
		this.initial = !0;
		this.buffer = [];
		this.onParseCallback = r.onParse, this.onErrorCallback = r.onError, this.onDoneCallback = r.onDone;
	}
	onParseInternal(r, t) {
		try {
			this.onParseCallback(r, t);
		} catch (n) {
			this.onError(n);
		}
	}
	flush() {
		for (let r = 0, t = this.buffer.length; r < t; r++) this.onParseInternal(this.buffer[r], !1);
	}
	onParse(r) {
		this.initial ? this.buffer.push(r) : this.onParseInternal(r, !1);
	}
	onError(r) {
		if (this.onErrorCallback) this.onErrorCallback(r);
		else throw r;
	}
	onDone() {
		this.onDoneCallback && this.onDoneCallback();
	}
	pushPendingState() {
		this.pending++;
	}
	popPendingState() {
		--this.pending <= 0 && this.onDone();
	}
	parseProperties(r) {
		let t = Object.entries(r), n = [], a = [];
		for (let l$1 = 0, c$1 = t.length; l$1 < c$1; l$1++) n.push(d(t[l$1][0])), a.push(this.parse(t[l$1][1]));
		let i$1 = Symbol.iterator;
		return i$1 in r && (n.push(this.parseWellKnownSymbol(i$1)), a.push(M(this.parseIteratorFactory(), this.parse(J(r))))), i$1 = Symbol.asyncIterator, i$1 in r && (n.push(this.parseWellKnownSymbol(i$1)), a.push(U(this.parseAsyncIteratorFactory(), this.parse(Ve(r))))), i$1 = Symbol.toStringTag, i$1 in r && (n.push(this.parseWellKnownSymbol(i$1)), a.push(w$1(r[i$1]))), i$1 = Symbol.isConcatSpreadable, i$1 in r && (n.push(this.parseWellKnownSymbol(i$1)), a.push(r[i$1] ? I : A$1)), {
			k: n,
			v: a,
			s: n.length
		};
	}
	handlePromiseSuccess(r, t) {
		let n = this.parseWithError(t);
		n && this.onParse(u$1(23, r, s$1, s$1, s$1, s$1, s$1, s$1, [this.parseSpecialReference(2), n], s$1, s$1, s$1)), this.popPendingState();
	}
	handlePromiseFailure(r, t) {
		if (this.alive) {
			let n = this.parseWithError(t);
			n && this.onParse(u$1(24, r, s$1, s$1, s$1, s$1, s$1, s$1, [this.parseSpecialReference(3), n], s$1, s$1, s$1));
		}
		this.popPendingState();
	}
	parsePromise(r, t) {
		let n = this.createIndex({});
		return t.then(this.handlePromiseSuccess.bind(this, n), this.handlePromiseFailure.bind(this, n)), this.pushPendingState(), this.createPromiseConstructorNode(r, n);
	}
	parsePlugin(r, t) {
		let n = this.plugins;
		if (n) for (let a = 0, i$1 = n.length; a < i$1; a++) {
			let l$1 = n[a];
			if (l$1.parse.stream && l$1.test(t)) return _$1(r, l$1.tag, l$1.parse.stream(t, this, { id: r }));
		}
		return s$1;
	}
	parseStream(r, t) {
		let n = L(r, this.parseSpecialReference(4), []);
		return this.pushPendingState(), t.on({
			next: (a) => {
				if (this.alive) {
					let i$1 = this.parseWithError(a);
					i$1 && this.onParse(Re(r, i$1));
				}
			},
			throw: (a) => {
				if (this.alive) {
					let i$1 = this.parseWithError(a);
					i$1 && this.onParse(Oe(r, i$1));
				}
				this.popPendingState();
			},
			return: (a) => {
				if (this.alive) {
					let i$1 = this.parseWithError(a);
					i$1 && this.onParse(Ce(r, i$1));
				}
				this.popPendingState();
			}
		}), n;
	}
	parseWithError(r) {
		try {
			return this.parse(r);
		} catch (t) {
			return this.onError(t), s$1;
		}
	}
	start(r) {
		let t = this.parseWithError(r);
		t && (this.onParseInternal(t, !0), this.initial = !1, this.flush(), this.pending <= 0 && this.destroy());
	}
	destroy() {
		this.alive && (this.onDone(), this.alive = !1);
	}
	isAlive() {
		return this.alive;
	}
};
var G = class extends oe {
	constructor() {
		super(...arguments);
		this.mode = "cross";
	}
};
function gr(o$1, e) {
	let r = m$1(e.plugins), t = new G({
		plugins: r,
		refs: e.refs,
		disabledFeatures: e.disabledFeatures,
		onParse(n, a) {
			let i$1 = new D({
				plugins: r,
				features: t.features,
				scopeId: e.scopeId,
				markedRefs: t.marked
			}), l$1;
			try {
				l$1 = i$1.serializeTop(n);
			} catch (c$1) {
				e.onError && e.onError(c$1);
				return;
			}
			e.onSerialize(l$1, a);
		},
		onError: e.onError,
		onDone: e.onDone
	});
	return t.start(o$1), t.destroy.bind(t);
}
var yr = "hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_", Sr = yr.length, vr = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_", hr = vr.length;
var De = class {
	constructor(e) {
		this.options = e;
		this.alive = !0;
		this.flushed = !1;
		this.done = !1;
		this.pending = 0;
		this.cleanups = [];
		this.refs = /* @__PURE__ */ new Map();
		this.keys = /* @__PURE__ */ new Set();
		this.ids = 0;
		this.plugins = m$1(e.plugins);
	}
	write(e, r) {
		this.alive && !this.flushed && (this.pending++, this.keys.add(e), this.cleanups.push(gr(r, {
			plugins: this.plugins,
			scopeId: this.options.scopeId,
			refs: this.refs,
			disabledFeatures: this.options.disabledFeatures,
			onError: this.options.onError,
			onSerialize: (t, n) => {
				this.alive && this.options.onData(n ? this.options.globalIdentifier + "[\\"" + d(e) + "\\"]=" + t : t);
			},
			onDone: () => {
				this.alive && (this.pending--, this.pending <= 0 && this.flushed && !this.done && this.options.onDone && (this.options.onDone(), this.done = !0));
			}
		})));
	}
	getNextID() {
		for (; this.keys.has("" + this.ids);) this.ids++;
		return "" + this.ids;
	}
	push(e) {
		let r = this.getNextID();
		return this.write(r, e), r;
	}
	flush() {
		this.alive && (this.flushed = !0, this.pending <= 0 && !this.done && this.options.onDone && (this.options.onDone(), this.done = !0));
	}
	close() {
		if (this.alive) {
			for (let e = 0, r = this.cleanups.length; e < r; e++) this.cleanups[e]();
			!this.done && this.options.onDone && (this.options.onDone(), this.done = !0), this.alive = !1;
		}
	}
};

//#endregion
//#region node_modules/seroval-plugins/dist/esm/production/web.mjs
function h(e) {
	e(this.reason);
}
function A(e) {
	this.addEventListener("abort", h.bind(this, e), { once: !0 });
}
function E(e) {
	return new Promise(A.bind(e));
}
var o = class {
	constructor() {
		this.controller = new AbortController();
	}
}, F = Hr({
	tag: "seroval-plugins/web/AbortSignalController",
	test(e) {
		return e instanceof o;
	},
	parse: { stream() {} },
	serialize(e) {
		return "new AbortController";
	},
	deserialize(e) {
		return new o();
	}
}), s = class {
	constructor(r, a) {
		this.controller = r;
		this.reason = a;
	}
};
var C = Hr({
	tag: "seroval-plugins/web/AbortSignal",
	extends: [Hr({
		extends: [F],
		tag: "seroval-plugins/web/AbortSignalAbort",
		test(e) {
			return e instanceof s;
		},
		parse: { stream(e, r) {
			return {
				controller: r.parse(e.controller),
				reason: r.parse(e.reason)
			};
		} },
		serialize(e, r) {
			return r.serialize(e.controller) + ".abort(" + r.serialize(e.reason) + ")";
		},
		deserialize(e, r) {
			let a = r.deserialize(e.controller), t = r.deserialize(e.reason);
			return a.controller.abort(t), new s(a, t);
		}
	})],
	test(e) {
		return typeof AbortSignal == "undefined" ? !1 : e instanceof AbortSignal;
	},
	parse: {
		sync(e, r) {
			return e.aborted ? {
				type: 1,
				reason: r.parse(e.reason)
			} : { type: 0 };
		},
		async async(e, r) {
			if (e.aborted) return {
				type: 1,
				reason: await r.parse(e.reason)
			};
			let a = await E(e);
			return {
				type: 1,
				reason: await r.parse(a)
			};
		},
		stream(e, r) {
			if (e.aborted) return {
				type: 1,
				reason: r.parse(e.reason)
			};
			let a = new o();
			return r.pushPendingState(), e.addEventListener("abort", () => {
				let t = r.parseWithError(new s(a, e.reason));
				t && r.onParse(t), r.popPendingState();
			}, { once: !0 }), {
				type: 2,
				controller: r.parse(a)
			};
		}
	},
	serialize(e, r) {
		return e.type === 0 ? "(new AbortController).signal" : e.type === 1 ? "AbortSignal.abort(" + r.serialize(e.reason) + ")" : "(" + r.serialize(e.controller) + ").signal";
	},
	deserialize(e, r) {
		return e.type === 0 ? new AbortController().signal : e.type === 1 ? AbortSignal.abort(r.deserialize(e.reason)) : r.deserialize(e.controller).controller.signal;
	}
});
var O = Hr({
	tag: "seroval-plugins/web/Blob",
	test(e) {
		return typeof Blob == "undefined" ? !1 : e instanceof Blob;
	},
	parse: { async async(e, r) {
		return {
			type: await r.parse(e.type),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new Blob([" + r.serialize(e.buffer) + "],{type:" + r.serialize(e.type) + "})";
	},
	deserialize(e, r) {
		return new Blob([r.deserialize(e.buffer)], { type: r.deserialize(e.type) });
	}
});
function f(e) {
	return {
		detail: e.detail,
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var H = Hr({
	tag: "seroval-plugins/web/CustomEvent",
	test(e) {
		return typeof CustomEvent == "undefined" ? !1 : e instanceof CustomEvent;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(f(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(f(e))
			};
		}
	},
	serialize(e, r) {
		return "new CustomEvent(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new CustomEvent(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var _ = Hr({
	tag: "seroval-plugins/web/DOMException",
	test(e) {
		return typeof DOMException == "undefined" ? !1 : e instanceof DOMException;
	},
	parse: {
		sync(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		},
		async async(e, r) {
			return {
				name: await r.parse(e.name),
				message: await r.parse(e.message)
			};
		},
		stream(e, r) {
			return {
				name: r.parse(e.name),
				message: r.parse(e.message)
			};
		}
	},
	serialize(e, r) {
		return "new DOMException(" + r.serialize(e.message) + "," + r.serialize(e.name) + ")";
	},
	deserialize(e, r) {
		return new DOMException(r.deserialize(e.message), r.deserialize(e.name));
	}
});
function m(e) {
	return {
		bubbles: e.bubbles,
		cancelable: e.cancelable,
		composed: e.composed
	};
}
var Y = Hr({
	tag: "seroval-plugins/web/Event",
	test(e) {
		return typeof Event == "undefined" ? !1 : e instanceof Event;
	},
	parse: {
		sync(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(m(e))
			};
		},
		async async(e, r) {
			return {
				type: await r.parse(e.type),
				options: await r.parse(m(e))
			};
		},
		stream(e, r) {
			return {
				type: r.parse(e.type),
				options: r.parse(m(e))
			};
		}
	},
	serialize(e, r) {
		return "new Event(" + r.serialize(e.type) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Event(r.deserialize(e.type), r.deserialize(e.options));
	}
});
var c = Hr({
	tag: "seroval-plugins/web/File",
	test(e) {
		return typeof File == "undefined" ? !1 : e instanceof File;
	},
	parse: { async async(e, r) {
		return {
			name: await r.parse(e.name),
			options: await r.parse({
				type: e.type,
				lastModified: e.lastModified
			}),
			buffer: await r.parse(await e.arrayBuffer())
		};
	} },
	serialize(e, r) {
		return "new File([" + r.serialize(e.buffer) + "]," + r.serialize(e.name) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new File([r.deserialize(e.buffer)], r.deserialize(e.name), r.deserialize(e.options));
	}
});
function g(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var i = {}, K = Hr({
	tag: "seroval-plugins/web/FormData",
	extends: [c, Hr({
		tag: "seroval-plugins/web/FormDataFactory",
		test(e) {
			return e === i;
		},
		parse: {
			sync() {},
			async async() {
				return await Promise.resolve(void 0);
			},
			stream() {}
		},
		serialize(e, r) {
			return r.createEffectfulFunction([
				"e",
				"f",
				"i",
				"s",
				"t"
			], "f=new FormData;for(i=0,s=e.length;i<s;i++)f.append((t=e[i])[0],t[1]);return f");
		},
		deserialize() {
			return i;
		}
	})],
	test(e) {
		return typeof FormData == "undefined" ? !1 : e instanceof FormData;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(i),
				entries: r.parse(g(e))
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(i),
				entries: await r.parse(g(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(i),
				entries: r.parse(g(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.entries) + ")";
	},
	deserialize(e, r) {
		let a = new FormData(), t = r.deserialize(e.entries);
		for (let n = 0, R$1 = t.length; n < R$1; n++) {
			let b = t[n];
			a.append(b[0], b[1]);
		}
		return a;
	}
});
function y(e) {
	let r = [];
	return e.forEach((a, t) => {
		r.push([t, a]);
	}), r;
}
var l = Hr({
	tag: "seroval-plugins/web/Headers",
	test(e) {
		return typeof Headers == "undefined" ? !1 : e instanceof Headers;
	},
	parse: {
		sync(e, r) {
			return r.parse(y(e));
		},
		async async(e, r) {
			return await r.parse(y(e));
		},
		stream(e, r) {
			return r.parse(y(e));
		}
	},
	serialize(e, r) {
		return "new Headers(" + r.serialize(e) + ")";
	},
	deserialize(e, r) {
		return new Headers(r.deserialize(e));
	}
});
var x = Hr({
	tag: "seroval-plugins/web/ImageData",
	test(e) {
		return typeof ImageData == "undefined" ? !1 : e instanceof ImageData;
	},
	parse: {
		sync(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		},
		async async(e, r) {
			return {
				data: await r.parse(e.data),
				width: await r.parse(e.width),
				height: await r.parse(e.height),
				options: await r.parse({ colorSpace: e.colorSpace })
			};
		},
		stream(e, r) {
			return {
				data: r.parse(e.data),
				width: r.parse(e.width),
				height: r.parse(e.height),
				options: r.parse({ colorSpace: e.colorSpace })
			};
		}
	},
	serialize(e, r) {
		return "new ImageData(" + r.serialize(e.data) + "," + r.serialize(e.width) + "," + r.serialize(e.height) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new ImageData(r.deserialize(e.data), r.deserialize(e.width), r.deserialize(e.height), r.deserialize(e.options));
	}
});
var p = {}, ee = Hr({
	tag: "seroval-plugins/web/ReadableStreamFactory",
	test(e) {
		return e === p;
	},
	parse: {
		sync() {},
		async async() {
			return await Promise.resolve(void 0);
		},
		stream() {}
	},
	serialize(e, r) {
		return r.createFunction(["d"], "new ReadableStream({start:" + r.createEffectfulFunction(["c"], "d.on({next:" + r.createEffectfulFunction(["v"], "c.enqueue(v)") + ",throw:" + r.createEffectfulFunction(["v"], "c.error(v)") + ",return:" + r.createEffectfulFunction([], "c.close()") + "})") + "})");
	},
	deserialize() {
		return p;
	}
});
function w(e) {
	let r = K$1(), a = e.getReader();
	async function t() {
		try {
			let n = await a.read();
			n.done ? r.return(n.value) : (r.next(n.value), await t());
		} catch (n) {
			r.throw(n);
		}
	}
	return t().catch(() => {}), r;
}
var u = Hr({
	tag: "seroval/plugins/web/ReadableStream",
	extends: [ee],
	test(e) {
		return typeof ReadableStream == "undefined" ? !1 : e instanceof ReadableStream;
	},
	parse: {
		sync(e, r) {
			return {
				factory: r.parse(p),
				stream: r.parse(K$1())
			};
		},
		async async(e, r) {
			return {
				factory: await r.parse(p),
				stream: await r.parse(w(e))
			};
		},
		stream(e, r) {
			return {
				factory: r.parse(p),
				stream: r.parse(w(e))
			};
		}
	},
	serialize(e, r) {
		return "(" + r.serialize(e.factory) + ")(" + r.serialize(e.stream) + ")";
	},
	deserialize(e, r) {
		let a = r.deserialize(e.stream);
		return new ReadableStream({ start(t) {
			a.on({
				next(n) {
					t.enqueue(n);
				},
				throw(n) {
					t.error(n);
				},
				return() {
					t.close();
				}
			});
		} });
	}
});
function P(e, r) {
	return {
		body: r,
		cache: e.cache,
		credentials: e.credentials,
		headers: e.headers,
		integrity: e.integrity,
		keepalive: e.keepalive,
		method: e.method,
		mode: e.mode,
		redirect: e.redirect,
		referrer: e.referrer,
		referrerPolicy: e.referrerPolicy
	};
}
var ne = Hr({
	tag: "seroval-plugins/web/Request",
	extends: [u, l],
	test(e) {
		return typeof Request == "undefined" ? !1 : e instanceof Request;
	},
	parse: {
		async async(e, r) {
			return {
				url: await r.parse(e.url),
				options: await r.parse(P(e, e.body ? await e.clone().arrayBuffer() : null))
			};
		},
		stream(e, r) {
			return {
				url: r.parse(e.url),
				options: r.parse(P(e, e.clone().body))
			};
		}
	},
	serialize(e, r) {
		return "new Request(" + r.serialize(e.url) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Request(r.deserialize(e.url), r.deserialize(e.options));
	}
});
function N(e) {
	return {
		headers: e.headers,
		status: e.status,
		statusText: e.statusText
	};
}
var ie = Hr({
	tag: "seroval-plugins/web/Response",
	extends: [u, l],
	test(e) {
		return typeof Response == "undefined" ? !1 : e instanceof Response;
	},
	parse: {
		async async(e, r) {
			return {
				body: await r.parse(e.body ? await e.clone().arrayBuffer() : null),
				options: await r.parse(N(e))
			};
		},
		stream(e, r) {
			return {
				body: r.parse(e.clone().body),
				options: r.parse(N(e))
			};
		}
	},
	serialize(e, r) {
		return "new Response(" + r.serialize(e.body) + "," + r.serialize(e.options) + ")";
	},
	deserialize(e, r) {
		return new Response(r.deserialize(e.body), r.deserialize(e.options));
	}
});
var ue = Hr({
	tag: "seroval-plugins/web/URL",
	test(e) {
		return typeof URL == "undefined" ? !1 : e instanceof URL;
	},
	parse: {
		sync(e, r) {
			return r.parse(e.href);
		},
		async async(e, r) {
			return await r.parse(e.href);
		},
		stream(e, r) {
			return r.parse(e.href);
		}
	},
	serialize(e, r) {
		return "new URL(" + r.serialize(e) + ")";
	},
	deserialize(e, r) {
		return new URL(r.deserialize(e));
	}
});
var me = Hr({
	tag: "seroval-plugins/web/URLSearchParams",
	test(e) {
		return typeof URLSearchParams == "undefined" ? !1 : e instanceof URLSearchParams;
	},
	parse: {
		sync(e, r) {
			return r.parse(e.toString());
		},
		async async(e, r) {
			return await r.parse(e.toString());
		},
		stream(e, r) {
			return r.parse(e.toString());
		}
	},
	serialize(e, r) {
		return "new URLSearchParams(" + r.serialize(e) + ")";
	},
	deserialize(e, r) {
		return new URLSearchParams(r.deserialize(e));
	}
});

//#endregion
//#region node_modules/solid-js/web/dist/server.js
const booleans = [
	"allowfullscreen",
	"async",
	"alpha",
	"autofocus",
	"autoplay",
	"checked",
	"controls",
	"default",
	"disabled",
	"formnovalidate",
	"hidden",
	"indeterminate",
	"inert",
	"ismap",
	"loop",
	"multiple",
	"muted",
	"nomodule",
	"novalidate",
	"open",
	"playsinline",
	"readonly",
	"required",
	"reversed",
	"seamless",
	"selected",
	"adauctionheaders",
	"browsingtopics",
	"credentialless",
	"defaultchecked",
	"defaultmuted",
	"defaultselected",
	"defer",
	"disablepictureinpicture",
	"disableremoteplayback",
	"preservespitch",
	"shadowrootclonable",
	"shadowrootcustomelementregistry",
	"shadowrootdelegatesfocus",
	"shadowrootserializable",
	"sharedstoragewritable"
];
const Properties = /* @__PURE__ */ new Set([
	"className",
	"value",
	"readOnly",
	"noValidate",
	"formNoValidate",
	"isMap",
	"noModule",
	"playsInline",
	"adAuctionHeaders",
	"allowFullscreen",
	"browsingTopics",
	"defaultChecked",
	"defaultMuted",
	"defaultSelected",
	"disablePictureInPicture",
	"disableRemotePlayback",
	"preservesPitch",
	"shadowRootClonable",
	"shadowRootCustomElementRegistry",
	"shadowRootDelegatesFocus",
	"shadowRootSerializable",
	"sharedStorageWritable",
	...booleans
]);
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
const ES2017FLAG = R.AggregateError | R.BigIntTypedArray;
const GLOBAL_IDENTIFIER = "_$HY.r";
function createSerializer({ onData, onDone, scopeId, onError, plugins: customPlugins }) {
	const defaultPlugins = [
		C,
		H,
		_,
		Y,
		K,
		l,
		u,
		ne,
		ie,
		me,
		ue
	];
	return new De({
		scopeId,
		plugins: customPlugins ? [...customPlugins, ...defaultPlugins] : defaultPlugins,
		globalIdentifier: GLOBAL_IDENTIFIER,
		disabledFeatures: ES2017FLAG,
		onData,
		onDone,
		onError
	});
}
function getLocalHeaderScript(id) {
	return xr(id) + ";";
}
function renderToString(code, options = {}) {
	const { renderId } = options;
	let scripts = "";
	const serializer = createSerializer({
		scopeId: renderId,
		plugins: options.plugins,
		onData(script) {
			if (!scripts) scripts = getLocalHeaderScript(renderId);
			scripts += script + ";";
		},
		onError: options.onError
	});
	sharedConfig.context = {
		id: renderId || "",
		count: 0,
		suspense: {},
		lazy: {},
		assets: [],
		nonce: options.nonce,
		serialize(id, p$1) {
			!sharedConfig.context.noHydrate && serializer.write(id, p$1);
		},
		roots: 0,
		nextRoot() {
			return this.renderId + "i-" + this.roots++;
		}
	};
	let html = createRoot((d$1) => {
		setTimeout(d$1);
		return resolveSSRNode(escape(code()));
	});
	sharedConfig.context.noHydrate = true;
	serializer.close();
	html = injectAssets(sharedConfig.context.assets, html);
	if (scripts.length) html = injectScripts(html, scripts, options.nonce);
	return html;
}
function ssr(t, ...nodes) {
	if (nodes.length) {
		let result = "";
		for (let i$1 = 0; i$1 < nodes.length; i$1++) {
			result += t[i$1];
			const node = nodes[i$1];
			if (node !== void 0) result += resolveSSRNode(node);
		}
		t = result + t[nodes.length];
	}
	return { t };
}
function ssrHydrationKey() {
	const hk = getHydrationKey();
	return hk ? \` data-hk="\${hk}"\` : "";
}
function escape(s$2, attr) {
	const t = typeof s$2;
	if (t !== "string") {
		if (!attr && t === "function") return escape(s$2());
		if (!attr && Array.isArray(s$2)) {
			s$2 = s$2.slice();
			for (let i$1 = 0; i$1 < s$2.length; i$1++) s$2[i$1] = escape(s$2[i$1]);
			return s$2;
		}
		if (attr && t === "boolean") return String(s$2);
		return s$2;
	}
	const delim = attr ? "\\"" : "<";
	const escDelim = attr ? "&quot;" : "&lt;";
	let iDelim = s$2.indexOf(delim);
	let iAmp = s$2.indexOf("&");
	if (iDelim < 0 && iAmp < 0) return s$2;
	let left = 0, out = "";
	while (iDelim >= 0 && iAmp >= 0) if (iDelim < iAmp) {
		if (left < iDelim) out += s$2.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s$2.indexOf(delim, left);
	} else {
		if (left < iAmp) out += s$2.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s$2.indexOf("&", left);
	}
	if (iDelim >= 0) do {
		if (left < iDelim) out += s$2.substring(left, iDelim);
		out += escDelim;
		left = iDelim + 1;
		iDelim = s$2.indexOf(delim, left);
	} while (iDelim >= 0);
	else while (iAmp >= 0) {
		if (left < iAmp) out += s$2.substring(left, iAmp);
		out += "&amp;";
		left = iAmp + 1;
		iAmp = s$2.indexOf("&", left);
	}
	return left < s$2.length ? out + s$2.substring(left) : out;
}
function resolveSSRNode(node, top) {
	const t = typeof node;
	if (t === "string") return node;
	if (node == null || t === "boolean") return "";
	if (Array.isArray(node)) {
		let prev = {};
		let mapped = "";
		for (let i$1 = 0, len = node.length; i$1 < len; i$1++) {
			if (!top && typeof prev !== "object" && typeof node[i$1] !== "object") mapped += \`<!--!$-->\`;
			mapped += resolveSSRNode(prev = node[i$1]);
		}
		return mapped;
	}
	if (t === "object") return node.t;
	if (t === "function") return resolveSSRNode(node());
	return String(node);
}
function getHydrationKey() {
	const hydrate = sharedConfig.context;
	return hydrate && !hydrate.noHydrate && sharedConfig.getNextContextId();
}
function injectAssets(assets, html) {
	if (!assets || !assets.length) return html;
	let out = "";
	for (let i$1 = 0, len = assets.length; i$1 < len; i$1++) out += assets[i$1]();
	const index = html.indexOf("</head>");
	if (index === -1) return html;
	return html.slice(0, index) + out + html.slice(index);
}
function injectScripts(html, scripts, nonce) {
	const tag = \`<script\${nonce ? \` nonce="\${nonce}"\` : ""}>\${scripts}<\\/script>\`;
	const index = html.indexOf("<!--xs-->");
	if (index > -1) return html.slice(0, index) + tag + html.slice(index);
	return html + tag;
}

//#endregion
//#region tests/fixtures/ssr.tsx
var _tmpl$ = [
	"<button",
	" type=\\"button\\">",
	"</button>"
];
const App = () => {
	const [count, setCount] = createSignal(0);
	return ssr(_tmpl$, ssrHydrationKey(), escape(count()));
};
var ssr_default = renderToString(App);

//#endregion
export { ssr_default as default };"
`;

exports[`rolldown-plugin-solid should transform standalone component 1`] = `
"//#region node_modules/solid-js/dist/solid.js
const sharedConfig = {
	context: void 0,
	registry: void 0,
	effects: void 0,
	done: false,
	getContextId() {
		return getContextId(this.context.count);
	},
	getNextContextId() {
		return getContextId(this.context.count++);
	}
};
function getContextId(count) {
	const num = String(count), len = num.length - 1;
	return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
const equalFn = (a, b) => a === b;
const signalOptions = { equals: equalFn };
let ERROR = null;
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
	owned: null,
	cleanups: null,
	context: null,
	owner: null
};
var Owner = null;
let Transition = null;
let Scheduler = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createSignal(value, options) {
	options = options ? Object.assign({}, signalOptions, options) : signalOptions;
	const s = {
		value,
		observers: null,
		observerSlots: null,
		comparator: options.equals || void 0
	};
	const setter = (value$1) => {
		if (typeof value$1 === "function") if (Transition && Transition.running && Transition.sources.has(s)) value$1 = value$1(s.tValue);
		else value$1 = value$1(s.value);
		return writeSignal(s, value$1);
	};
	return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
	const c = createComputation(fn, value, false, STALE);
	if (Scheduler && Transition && Transition.running) Updates.push(c);
	else updateComputation(c);
}
function untrack(fn) {
	if (!ExternalSourceConfig && Listener === null) return fn();
	const listener = Listener;
	Listener = null;
	try {
		if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
		return fn();
	} finally {
		Listener = listener;
	}
}
function onCleanup(fn) {
	if (Owner === null);
	else if (Owner.cleanups === null) Owner.cleanups = [fn];
	else Owner.cleanups.push(fn);
	return fn;
}
function startTransition(fn) {
	if (Transition && Transition.running) {
		fn();
		return Transition.done;
	}
	const l = Listener;
	const o = Owner;
	return Promise.resolve().then(() => {
		Listener = l;
		Owner = o;
		let t;
		if (Scheduler || SuspenseContext) {
			t = Transition || (Transition = {
				sources: /* @__PURE__ */ new Set(),
				effects: [],
				promises: /* @__PURE__ */ new Set(),
				disposed: /* @__PURE__ */ new Set(),
				queue: /* @__PURE__ */ new Set(),
				running: true
			});
			t.done || (t.done = new Promise((res) => t.resolve = res));
			t.running = true;
		}
		runUpdates(fn, false);
		Listener = Owner = null;
		return t ? t.done : void 0;
	});
}
const [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
let SuspenseContext;
function readSignal() {
	const runningTransition = Transition && Transition.running;
	if (this.sources && (runningTransition ? this.tState : this.state)) if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
	else {
		const updates = Updates;
		Updates = null;
		runUpdates(() => lookUpstream(this), false);
		Updates = updates;
	}
	if (Listener) {
		const sSlot = this.observers ? this.observers.length : 0;
		if (!Listener.sources) {
			Listener.sources = [this];
			Listener.sourceSlots = [sSlot];
		} else {
			Listener.sources.push(this);
			Listener.sourceSlots.push(sSlot);
		}
		if (!this.observers) {
			this.observers = [Listener];
			this.observerSlots = [Listener.sources.length - 1];
		} else {
			this.observers.push(Listener);
			this.observerSlots.push(Listener.sources.length - 1);
		}
	}
	if (runningTransition && Transition.sources.has(this)) return this.tValue;
	return this.value;
}
function writeSignal(node, value, isComp) {
	let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
	if (!node.comparator || !node.comparator(current, value)) {
		if (Transition) {
			const TransitionRunning = Transition.running;
			if (TransitionRunning || !isComp && Transition.sources.has(node)) {
				Transition.sources.add(node);
				node.tValue = value;
			}
			if (!TransitionRunning) node.value = value;
		} else node.value = value;
		if (node.observers && node.observers.length) runUpdates(() => {
			for (let i = 0; i < node.observers.length; i += 1) {
				const o = node.observers[i];
				const TransitionRunning = Transition && Transition.running;
				if (TransitionRunning && Transition.disposed.has(o)) continue;
				if (TransitionRunning ? !o.tState : !o.state) {
					if (o.pure) Updates.push(o);
					else Effects.push(o);
					if (o.observers) markDownstream(o);
				}
				if (!TransitionRunning) o.state = STALE;
				else o.tState = STALE;
			}
			if (Updates.length > 1e6) {
				Updates = [];
				throw new Error();
			}
		}, false);
	}
	return value;
}
function updateComputation(node) {
	if (!node.fn) return;
	cleanNode(node);
	const time = ExecCount;
	runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
	if (Transition && !Transition.running && Transition.sources.has(node)) queueMicrotask(() => {
		runUpdates(() => {
			Transition && (Transition.running = true);
			Listener = Owner = node;
			runComputation(node, node.tValue, time);
			Listener = Owner = null;
		}, false);
	});
}
function runComputation(node, value, time) {
	let nextValue;
	const owner = Owner, listener = Listener;
	Listener = Owner = node;
	try {
		nextValue = node.fn(value);
	} catch (err) {
		if (node.pure) if (Transition && Transition.running) {
			node.tState = STALE;
			node.tOwned && node.tOwned.forEach(cleanNode);
			node.tOwned = void 0;
		} else {
			node.state = STALE;
			node.owned && node.owned.forEach(cleanNode);
			node.owned = null;
		}
		node.updatedAt = time + 1;
		return handleError(err);
	} finally {
		Listener = listener;
		Owner = owner;
	}
	if (!node.updatedAt || node.updatedAt <= time) {
		if (node.updatedAt != null && "observers" in node) writeSignal(node, nextValue, true);
		else if (Transition && Transition.running && node.pure) {
			Transition.sources.add(node);
			node.tValue = nextValue;
		} else node.value = nextValue;
		node.updatedAt = time;
	}
}
function createComputation(fn, init, pure, state = STALE, options) {
	const c = {
		fn,
		state,
		updatedAt: null,
		owned: null,
		sources: null,
		sourceSlots: null,
		cleanups: null,
		value: init,
		owner: Owner,
		context: Owner ? Owner.context : null,
		pure
	};
	if (Transition && Transition.running) {
		c.state = 0;
		c.tState = state;
	}
	if (Owner === null);
	else if (Owner !== UNOWNED) if (Transition && Transition.running && Owner.pure) if (!Owner.tOwned) Owner.tOwned = [c];
	else Owner.tOwned.push(c);
	else if (!Owner.owned) Owner.owned = [c];
	else Owner.owned.push(c);
	if (ExternalSourceConfig && c.fn) {
		const [track, trigger] = createSignal(void 0, { equals: false });
		const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
		onCleanup(() => ordinary.dispose());
		const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
		const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
		c.fn = (x) => {
			track();
			return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
		};
	}
	return c;
}
function runTop(node) {
	const runningTransition = Transition && Transition.running;
	if ((runningTransition ? node.tState : node.state) === 0) return;
	if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
	if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
	const ancestors = [node];
	while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
		if (runningTransition && Transition.disposed.has(node)) return;
		if (runningTransition ? node.tState : node.state) ancestors.push(node);
	}
	for (let i = ancestors.length - 1; i >= 0; i--) {
		node = ancestors[i];
		if (runningTransition) {
			let top = node, prev = ancestors[i + 1];
			while ((top = top.owner) && top !== prev) if (Transition.disposed.has(top)) return;
		}
		if ((runningTransition ? node.tState : node.state) === STALE) updateComputation(node);
		else if ((runningTransition ? node.tState : node.state) === PENDING) {
			const updates = Updates;
			Updates = null;
			runUpdates(() => lookUpstream(node, ancestors[0]), false);
			Updates = updates;
		}
	}
}
function runUpdates(fn, init) {
	if (Updates) return fn();
	let wait = false;
	if (!init) Updates = [];
	if (Effects) wait = true;
	else Effects = [];
	ExecCount++;
	try {
		const res = fn();
		completeUpdates(wait);
		return res;
	} catch (err) {
		if (!wait) Effects = null;
		Updates = null;
		handleError(err);
	}
}
function completeUpdates(wait) {
	if (Updates) {
		if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
		else runQueue(Updates);
		Updates = null;
	}
	if (wait) return;
	let res;
	if (Transition) {
		if (!Transition.promises.size && !Transition.queue.size) {
			const sources = Transition.sources;
			const disposed = Transition.disposed;
			Effects.push.apply(Effects, Transition.effects);
			res = Transition.resolve;
			for (const e$1 of Effects) {
				"tState" in e$1 && (e$1.state = e$1.tState);
				delete e$1.tState;
			}
			Transition = null;
			runUpdates(() => {
				for (const d of disposed) cleanNode(d);
				for (const v of sources) {
					v.value = v.tValue;
					if (v.owned) for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
					if (v.tOwned) v.owned = v.tOwned;
					delete v.tValue;
					delete v.tOwned;
					v.tState = 0;
				}
				setTransPending(false);
			}, false);
		} else if (Transition.running) {
			Transition.running = false;
			Transition.effects.push.apply(Transition.effects, Effects);
			Effects = null;
			setTransPending(true);
			return;
		}
	}
	const e = Effects;
	Effects = null;
	if (e.length) runUpdates(() => runEffects(e), false);
	if (res) res();
}
function runQueue(queue) {
	for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
	for (let i = 0; i < queue.length; i++) {
		const item = queue[i];
		const tasks = Transition.queue;
		if (!tasks.has(item)) {
			tasks.add(item);
			Scheduler(() => {
				tasks.delete(item);
				runUpdates(() => {
					Transition.running = true;
					runTop(item);
				}, false);
				Transition && (Transition.running = false);
			});
		}
	}
}
function lookUpstream(node, ignore) {
	const runningTransition = Transition && Transition.running;
	if (runningTransition) node.tState = 0;
	else node.state = 0;
	for (let i = 0; i < node.sources.length; i += 1) {
		const source = node.sources[i];
		if (source.sources) {
			const state = runningTransition ? source.tState : source.state;
			if (state === STALE) {
				if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
			} else if (state === PENDING) lookUpstream(source, ignore);
		}
	}
}
function markDownstream(node) {
	const runningTransition = Transition && Transition.running;
	for (let i = 0; i < node.observers.length; i += 1) {
		const o = node.observers[i];
		if (runningTransition ? !o.tState : !o.state) {
			if (runningTransition) o.tState = PENDING;
			else o.state = PENDING;
			if (o.pure) Updates.push(o);
			else Effects.push(o);
			o.observers && markDownstream(o);
		}
	}
}
function cleanNode(node) {
	let i;
	if (node.sources) while (node.sources.length) {
		const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
		if (obs && obs.length) {
			const n = obs.pop(), s = source.observerSlots.pop();
			if (index < obs.length) {
				n.sourceSlots[s] = index;
				obs[index] = n;
				source.observerSlots[index] = s;
			}
		}
	}
	if (node.tOwned) {
		for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
		delete node.tOwned;
	}
	if (Transition && Transition.running && node.pure) reset(node, true);
	else if (node.owned) {
		for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
		node.owned = null;
	}
	if (node.cleanups) {
		for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
		node.cleanups = null;
	}
	if (Transition && Transition.running) node.tState = 0;
	else node.state = 0;
}
function reset(node, top) {
	if (!top) {
		node.tState = 0;
		Transition.disposed.add(node);
	}
	if (node.owned) for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
}
function castError(err) {
	if (err instanceof Error) return err;
	return new Error(typeof err === "string" ? err : "Unknown error", { cause: err });
}
function runErrors(err, fns, owner) {
	try {
		for (const f of fns) f(err);
	} catch (e) {
		handleError(e, owner && owner.owner || null);
	}
}
function handleError(err, owner = Owner) {
	const fns = ERROR && owner && owner.context && owner.context[ERROR];
	const error = castError(err);
	if (!fns) throw error;
	if (Effects) Effects.push({
		fn() {
			runErrors(error, fns, owner);
		},
		state: STALE
	});
	else runErrors(error, fns, owner);
}

//#endregion
//#region node_modules/solid-js/web/dist/web.js
const Aliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	className: "class",
	htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(Object.create(null), {
	class: "className",
	novalidate: {
		$: "noValidate",
		FORM: 1
	},
	formnovalidate: {
		$: "formNoValidate",
		BUTTON: 1,
		INPUT: 1
	},
	ismap: {
		$: "isMap",
		IMG: 1
	},
	nomodule: {
		$: "noModule",
		SCRIPT: 1
	},
	playsinline: {
		$: "playsInline",
		VIDEO: 1
	},
	readonly: {
		$: "readOnly",
		INPUT: 1,
		TEXTAREA: 1
	},
	adauctionheaders: {
		$: "adAuctionHeaders",
		IFRAME: 1
	},
	allowfullscreen: {
		$: "allowFullscreen",
		IFRAME: 1
	},
	browsingtopics: {
		$: "browsingTopics",
		IMG: 1
	},
	defaultchecked: {
		$: "defaultChecked",
		INPUT: 1
	},
	defaultmuted: {
		$: "defaultMuted",
		AUDIO: 1,
		VIDEO: 1
	},
	defaultselected: {
		$: "defaultSelected",
		OPTION: 1
	},
	disablepictureinpicture: {
		$: "disablePictureInPicture",
		VIDEO: 1
	},
	disableremoteplayback: {
		$: "disableRemotePlayback",
		AUDIO: 1,
		VIDEO: 1
	},
	preservespitch: {
		$: "preservesPitch",
		AUDIO: 1,
		VIDEO: 1
	},
	shadowrootclonable: {
		$: "shadowRootClonable",
		TEMPLATE: 1
	},
	shadowrootdelegatesfocus: {
		$: "shadowRootDelegatesFocus",
		TEMPLATE: 1
	},
	shadowrootserializable: {
		$: "shadowRootSerializable",
		TEMPLATE: 1
	},
	sharedstoragewritable: {
		$: "sharedStorageWritable",
		IFRAME: 1,
		IMG: 1
	}
});
function reconcileArrays(parentNode, a, b) {
	let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
	while (aStart < aEnd || bStart < bEnd) {
		if (a[aStart] === b[bStart]) {
			aStart++;
			bStart++;
			continue;
		}
		while (a[aEnd - 1] === b[bEnd - 1]) {
			aEnd--;
			bEnd--;
		}
		if (aEnd === aStart) {
			const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
			while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
		} else if (bEnd === bStart) while (aStart < aEnd) {
			if (!map || !map.has(a[aStart])) a[aStart].remove();
			aStart++;
		}
		else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
			const node = a[--aEnd].nextSibling;
			parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
			parentNode.insertBefore(b[--bEnd], node);
			a[aEnd] = b[bEnd];
		} else {
			if (!map) {
				map = /* @__PURE__ */ new Map();
				let i = bStart;
				while (i < bEnd) map.set(b[i], i++);
			}
			const index = map.get(a[aStart]);
			if (index != null) if (bStart < index && index < bEnd) {
				let i = aStart, sequence = 1, t;
				while (++i < aEnd && i < bEnd) {
					if ((t = map.get(a[i])) == null || t !== index + sequence) break;
					sequence++;
				}
				if (sequence > index - bStart) {
					const node = a[aStart];
					while (bStart < index) parentNode.insertBefore(b[bStart++], node);
				} else parentNode.replaceChild(b[bStart++], a[aStart++]);
			} else aStart++;
			else a[aStart++].remove();
		}
	}
}
const $$EVENTS = "_$DX_DELEGATE";
function template(html, isImportNode, isSVG, isMathML) {
	let node;
	const create = () => {
		const t = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
		t.innerHTML = html;
		return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;
	};
	const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
	fn.cloneNode = fn;
	return fn;
}
function delegateEvents(eventNames, document$1 = window.document) {
	const e = document$1[$$EVENTS] || (document$1[$$EVENTS] = /* @__PURE__ */ new Set());
	for (let i = 0, l = eventNames.length; i < l; i++) {
		const name = eventNames[i];
		if (!e.has(name)) {
			e.add(name);
			document$1.addEventListener(name, eventHandler);
		}
	}
}
function insert(parent, accessor, marker, initial) {
	if (marker !== void 0 && !initial) initial = [];
	if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
	createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function isHydrating(node) {
	return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function eventHandler(e) {
	if (sharedConfig.registry && sharedConfig.events) {
		if (sharedConfig.events.find(([el, ev]) => ev === e)) return;
	}
	let node = e.target;
	const key = \`$$\${e.type}\`;
	const oriTarget = e.target;
	const oriCurrentTarget = e.currentTarget;
	const retarget = (value) => Object.defineProperty(e, "target", {
		configurable: true,
		value
	});
	const handleNode = () => {
		const handler = node[key];
		if (handler && !node.disabled) {
			const data = node[\`\${key}Data\`];
			data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
			if (e.cancelBubble) return;
		}
		node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
		return true;
	};
	const walkUpTree = () => {
		while (handleNode() && (node = node._$host || node.parentNode || node.host));
	};
	Object.defineProperty(e, "currentTarget", {
		configurable: true,
		get() {
			return node || document;
		}
	});
	if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
	if (e.composedPath) {
		const path = e.composedPath();
		retarget(path[0]);
		for (let i = 0; i < path.length - 2; i++) {
			node = path[i];
			if (!handleNode()) break;
			if (node._$host) {
				node = node._$host;
				walkUpTree();
				break;
			}
			if (node.parentNode === oriCurrentTarget) break;
		}
	} else walkUpTree();
	retarget(oriTarget);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
	const hydrating = isHydrating(parent);
	if (hydrating) {
		!current && (current = [...parent.childNodes]);
		let cleaned = [];
		for (let i = 0; i < current.length; i++) {
			const node = current[i];
			if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
			else cleaned.push(node);
		}
		current = cleaned;
	}
	while (typeof current === "function") current = current();
	if (value === current) return current;
	const t = typeof value, multi = marker !== void 0;
	parent = multi && current[0] && current[0].parentNode || parent;
	if (t === "string" || t === "number") {
		if (hydrating) return current;
		if (t === "number") {
			value = value.toString();
			if (value === current) return current;
		}
		if (multi) {
			let node = current[0];
			if (node && node.nodeType === 3) node.data !== value && (node.data = value);
			else node = document.createTextNode(value);
			current = cleanChildren(parent, current, marker, node);
		} else if (current !== "" && typeof current === "string") current = parent.firstChild.data = value;
		else current = parent.textContent = value;
	} else if (value == null || t === "boolean") {
		if (hydrating) return current;
		current = cleanChildren(parent, current, marker);
	} else if (t === "function") {
		createRenderEffect(() => {
			let v = value();
			while (typeof v === "function") v = v();
			current = insertExpression(parent, v, current, marker);
		});
		return () => current;
	} else if (Array.isArray(value)) {
		const array = [];
		const currentArray = current && Array.isArray(current);
		if (normalizeIncomingArray(array, value, current, unwrapArray)) {
			createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
			return () => current;
		}
		if (hydrating) {
			if (!array.length) return current;
			if (marker === void 0) return current = [...parent.childNodes];
			let node = array[0];
			if (node.parentNode !== parent) return current;
			const nodes = [node];
			while ((node = node.nextSibling) !== marker) nodes.push(node);
			return current = nodes;
		}
		if (array.length === 0) {
			current = cleanChildren(parent, current, marker);
			if (multi) return current;
		} else if (currentArray) if (current.length === 0) appendNodes(parent, array, marker);
		else reconcileArrays(parent, current, array);
		else {
			current && cleanChildren(parent);
			appendNodes(parent, array);
		}
		current = array;
	} else if (value.nodeType) {
		if (hydrating && value.parentNode) return current = multi ? [value] : value;
		if (Array.isArray(current)) {
			if (multi) return current = cleanChildren(parent, current, marker, value);
			cleanChildren(parent, current, null, value);
		} else if (current == null || current === "" || !parent.firstChild) parent.appendChild(value);
		else parent.replaceChild(value, parent.firstChild);
		current = value;
	}
	return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
	let dynamic = false;
	for (let i = 0, len = array.length; i < len; i++) {
		let item = array[i], prev = current && current[normalized.length], t;
		if (item == null || item === true || item === false);
		else if ((t = typeof item) === "object" && item.nodeType) normalized.push(item);
		else if (Array.isArray(item)) dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
		else if (t === "function") if (unwrap) {
			while (typeof item === "function") item = item();
			dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
		} else {
			normalized.push(item);
			dynamic = true;
		}
		else {
			const value = String(item);
			if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
			else normalized.push(document.createTextNode(value));
		}
	}
	return dynamic;
}
function appendNodes(parent, array, marker = null) {
	for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
	if (marker === void 0) return parent.textContent = "";
	const node = replacement || document.createTextNode("");
	if (current.length) {
		let inserted = false;
		for (let i = current.length - 1; i >= 0; i--) {
			const el = current[i];
			if (node !== el) {
				const isParent = el.parentNode === parent;
				if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
				else isParent && el.remove();
			} else inserted = true;
		}
	} else parent.insertBefore(node, marker);
	return [node];
}

//#endregion
//#region tests/fixtures/component.tsx
var _tmpl$ = /* @__PURE__ */ template(\`<div class=counter><h1>Count: </h1><button>+</button><button>-\`);
const Counter = () => {
	const [count, setCount] = createSignal(0);
	const inc = () => setCount((c) => c + 1);
	const dec = () => setCount((c) => c - 1);
	return (() => {
		var _el$ = _tmpl$(), _el$2 = _el$.firstChild;
		_el$2.firstChild;
		var _el$4 = _el$2.nextSibling, _el$5 = _el$4.nextSibling;
		insert(_el$2, count, null);
		_el$4.$$click = inc;
		_el$5.$$click = dec;
		return _el$;
	})();
};
var component_default = Counter;
delegateEvents(["click"]);

//#endregion
export { component_default as default };"
`;
